import { AlertCircle,Database, Plus, Trash2 } from 'lucide-react'
import React, { useState } from 'react'

import { Alert, AlertDescription } from '@/components/ui/alert'
import { Badge } from '@/components/ui/badge'
import { Button } from '@/components/ui/button'
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select'
import { Textarea } from '@/components/ui/textarea'

interface ColumnDefinition {
  name: string
  type: string
}

interface SourceDefinition {
  connectionIdOrName: string
  schema: string
  table: string
}

interface SyntheticViewIRJoin {
  type: string
  table: {
    schema: string
    table: string
    connection: string
  }
  on: {
    type: string
    column: string
    operator: string
    value: string
  }
}

interface SyntheticViewIR {
  from: {
    schema: string
    table: string
    connection: string
  } | null
  joins: SyntheticViewIRJoin[]
  select: Array<{
    column: string
    alias: string
  }>
}

interface SyntheticViewOptions {
  rowLimitDefault: number
  materializeTemp: boolean
}

interface SyntheticViewConfig {
  id: string
  name: string
  description: string
  version: string
  columns: ColumnDefinition[]
  sources: SourceDefinition[]
  ir: SyntheticViewIR
  compiledDuckDBSQL: string
  options: SyntheticViewOptions
}

interface SyntheticViewCreatorProps {
  onSave?: (viewDef: SyntheticViewConfig) => void
  onCancel?: () => void
  initialView?: SyntheticViewConfig | null
}

export const SyntheticViewCreator: React.FC<SyntheticViewCreatorProps> = ({
  onSave,
  onCancel,
  initialView
}) => {
  const [name, setName] = useState(initialView?.name || '')
  const [description, setDescription] = useState(initialView?.description || '')
  const [columns, setColumns] = useState<ColumnDefinition[]>(initialView?.columns || [])
  const [sources, setSources] = useState<SourceDefinition[]>(initialView?.sources || [])
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)

  // Add column
  const addColumn = () => {
    setColumns([...columns, { name: '', type: 'text' }])
  }

  // Remove column
  const removeColumn = (index: number) => {
    setColumns(columns.filter((_, i) => i !== index))
  }

  // Update column
  const updateColumn = (index: number, field: keyof ColumnDefinition, value: string) => {
    const updated = [...columns]
    updated[index] = { ...updated[index], [field]: value }
    setColumns(updated)
  }

  // Add source
  const addSource = () => {
    setSources([...sources, { connectionIdOrName: '', schema: '', table: '' }])
  }

  // Remove source
  const removeSource = (index: number) => {
    setSources(sources.filter((_, i) => i !== index))
  }

  // Update source
  const updateSource = (index: number, field: keyof SourceDefinition, value: string) => {
    const updated = [...sources]
    updated[index] = { ...updated[index], [field]: value }
    setSources(updated)
  }

  // Save view
  const handleSave = async () => {
    if (!name.trim()) {
      setError('View name is required')
      return
    }

    if (columns.length === 0) {
      setError('At least one column is required')
      return
    }

    if (sources.length === 0) {
      setError('At least one source table is required')
      return
    }

    // Validate columns
    for (const col of columns) {
      if (!col.name.trim()) {
        setError('All columns must have a name')
        return
      }
    }

    // Validate sources
    for (const source of sources) {
      if (!source.connectionIdOrName.trim() || !source.schema.trim() || !source.table.trim()) {
        setError('All source tables must have connection, schema, and table specified')
        return
      }
    }

    try {
      setLoading(true)
      setError(null)

      const viewDef: SyntheticViewConfig = {
        id: initialView?.id || `view_${Date.now()}`,
        name: name.trim(),
        description: description.trim(),
        version: initialView?.version || '1.0.0',
        columns,
        sources,
        ir: {
          from: sources[0] ? {
            schema: sources[0].schema,
            table: sources[0].table,
            connection: sources[0].connectionIdOrName
          } : null,
          joins: sources.slice(1).map((source) => ({
            type: 'inner',
            table: {
              schema: source.schema,
              table: source.table,
              connection: source.connectionIdOrName
            },
            on: { type: 'predicate', column: 'id', operator: 'equals', value: 'id' }
          })),
          select: columns.map(col => ({
            column: col.name,
            alias: col.name
          }))
        },
        compiledDuckDBSQL: '', // Will be generated by backend
        options: {
          rowLimitDefault: 5000,
          materializeTemp: false
        }
      }

      if (onSave) {
        onSave(viewDef)
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to save view')
    } finally {
      setLoading(false)
    }
  }

  return (
    <div className="space-y-6">
      {/* Header */}
      <div>
        <h3 className="text-lg font-semibold">
          {initialView ? 'Edit Synthetic View' : 'Create Synthetic View'}
        </h3>
        <p className="text-sm text-muted-foreground">
          Define a federated view that joins tables across multiple databases
        </p>
      </div>

      {/* Error Alert */}
      {error && (
        <Alert variant="destructive">
          <AlertCircle className="h-4 w-4" />
          <AlertDescription>{error}</AlertDescription>
        </Alert>
      )}

      {/* Basic Info */}
      <Card>
        <CardHeader>
          <CardTitle className="text-base">Basic Information</CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          <div>
            <Label htmlFor="name">View Name</Label>
            <Input
              id="name"
              value={name}
              onChange={(e) => setName(e.target.value)}
              placeholder="e.g., user_orders_summary"
            />
          </div>
          
          <div>
            <Label htmlFor="description">Description</Label>
            <Textarea
              id="description"
              value={description}
              onChange={(e) => setDescription(e.target.value)}
              placeholder="Describe what this view contains..."
              rows={3}
            />
          </div>
        </CardContent>
      </Card>

      {/* Columns */}
      <Card>
        <CardHeader>
          <CardTitle className="text-base">Columns</CardTitle>
          <CardDescription>
            Define the columns that will be available in this view
          </CardDescription>
        </CardHeader>
        <CardContent className="space-y-4">
          {columns.map((column, index) => (
            <div key={index} className="flex items-center gap-2 p-3 border rounded-lg">
              <div className="flex-1">
                <Input
                  value={column.name}
                  onChange={(e) => updateColumn(index, 'name', e.target.value)}
                  placeholder="Column name"
                />
              </div>
              <div className="w-32">
                <Select
                  value={column.type}
                  onValueChange={(value) => updateColumn(index, 'type', value)}
                >
                  <SelectTrigger>
                    <SelectValue />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="text">Text</SelectItem>
                    <SelectItem value="number">Number</SelectItem>
                    <SelectItem value="boolean">Boolean</SelectItem>
                    <SelectItem value="date">Date</SelectItem>
                    <SelectItem value="datetime">DateTime</SelectItem>
                  </SelectContent>
                </Select>
              </div>
              <Button
                variant="outline"
                size="sm"
                onClick={() => removeColumn(index)}
                className="text-destructive hover:text-destructive"
              >
                <Trash2 className="h-4 w-4" />
              </Button>
            </div>
          ))}
          
          <Button variant="outline" onClick={addColumn} className="w-full">
            <Plus className="h-4 w-4 mr-2" />
            Add Column
          </Button>
        </CardContent>
      </Card>

      {/* Source Tables */}
      <Card>
        <CardHeader>
          <CardTitle className="text-base">Source Tables</CardTitle>
          <CardDescription>
            Specify the database tables to join in this view
          </CardDescription>
        </CardHeader>
        <CardContent className="space-y-4">
          {sources.map((source, index) => (
            <div key={index} className="space-y-3 p-3 border rounded-lg">
              <div className="flex items-center gap-2">
                <Database className="h-4 w-4 text-muted-foreground" />
                <span className="text-sm font-medium">Source {index + 1}</span>
                {index > 0 && (
                  <Badge variant="secondary" className="text-xs">
                    Join
                  </Badge>
                )}
              </div>
              
              <div className="grid grid-cols-3 gap-2">
                <div>
                  <Label className="text-xs">Connection</Label>
                  <Input
                    value={source.connectionIdOrName}
                    onChange={(e) => updateSource(index, 'connectionIdOrName', e.target.value)}
                    placeholder="Connection ID"
                    className="text-sm"
                  />
                </div>
                <div>
                  <Label className="text-xs">Schema</Label>
                  <Input
                    value={source.schema}
                    onChange={(e) => updateSource(index, 'schema', e.target.value)}
                    placeholder="public"
                    className="text-sm"
                  />
                </div>
                <div>
                  <Label className="text-xs">Table</Label>
                  <Input
                    value={source.table}
                    onChange={(e) => updateSource(index, 'table', e.target.value)}
                    placeholder="table_name"
                    className="text-sm"
                  />
                </div>
              </div>
              
              {index > 0 && (
                <Button
                  variant="outline"
                  size="sm"
                  onClick={() => removeSource(index)}
                  className="text-destructive hover:text-destructive"
                >
                  <Trash2 className="h-4 w-4 mr-1" />
                  Remove
                </Button>
              )}
            </div>
          ))}
          
          <Button variant="outline" onClick={addSource} className="w-full">
            <Plus className="h-4 w-4 mr-2" />
            Add Source Table
          </Button>
        </CardContent>
      </Card>

      {/* Actions */}
      <div className="flex justify-end gap-2">
        <Button variant="outline" onClick={onCancel} disabled={loading}>
          Cancel
        </Button>
        <Button onClick={handleSave} disabled={loading}>
          {loading ? 'Saving...' : (initialView ? 'Update View' : 'Create View')}
        </Button>
      </div>
    </div>
  )
}
