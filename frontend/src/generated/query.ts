// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v5.29.3
// source: query.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Any } from "./google/protobuf/any";
import { Timestamp } from "./google/protobuf/timestamp";

export const protobufPackage = "sqlstudio.query";

/** Query types */
export enum QueryType {
  QUERY_TYPE_UNSPECIFIED = "QUERY_TYPE_UNSPECIFIED",
  QUERY_TYPE_SELECT = "QUERY_TYPE_SELECT",
  QUERY_TYPE_INSERT = "QUERY_TYPE_INSERT",
  QUERY_TYPE_UPDATE = "QUERY_TYPE_UPDATE",
  QUERY_TYPE_DELETE = "QUERY_TYPE_DELETE",
  QUERY_TYPE_DDL = "QUERY_TYPE_DDL",
  QUERY_TYPE_TRANSACTION = "QUERY_TYPE_TRANSACTION",
  QUERY_TYPE_EXPLAIN = "QUERY_TYPE_EXPLAIN",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function queryTypeFromJSON(object: any): QueryType {
  switch (object) {
    case 0:
    case "QUERY_TYPE_UNSPECIFIED":
      return QueryType.QUERY_TYPE_UNSPECIFIED;
    case 1:
    case "QUERY_TYPE_SELECT":
      return QueryType.QUERY_TYPE_SELECT;
    case 2:
    case "QUERY_TYPE_INSERT":
      return QueryType.QUERY_TYPE_INSERT;
    case 3:
    case "QUERY_TYPE_UPDATE":
      return QueryType.QUERY_TYPE_UPDATE;
    case 4:
    case "QUERY_TYPE_DELETE":
      return QueryType.QUERY_TYPE_DELETE;
    case 5:
    case "QUERY_TYPE_DDL":
      return QueryType.QUERY_TYPE_DDL;
    case 6:
    case "QUERY_TYPE_TRANSACTION":
      return QueryType.QUERY_TYPE_TRANSACTION;
    case 7:
    case "QUERY_TYPE_EXPLAIN":
      return QueryType.QUERY_TYPE_EXPLAIN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return QueryType.UNRECOGNIZED;
  }
}

export function queryTypeToJSON(object: QueryType): string {
  switch (object) {
    case QueryType.QUERY_TYPE_UNSPECIFIED:
      return "QUERY_TYPE_UNSPECIFIED";
    case QueryType.QUERY_TYPE_SELECT:
      return "QUERY_TYPE_SELECT";
    case QueryType.QUERY_TYPE_INSERT:
      return "QUERY_TYPE_INSERT";
    case QueryType.QUERY_TYPE_UPDATE:
      return "QUERY_TYPE_UPDATE";
    case QueryType.QUERY_TYPE_DELETE:
      return "QUERY_TYPE_DELETE";
    case QueryType.QUERY_TYPE_DDL:
      return "QUERY_TYPE_DDL";
    case QueryType.QUERY_TYPE_TRANSACTION:
      return "QUERY_TYPE_TRANSACTION";
    case QueryType.QUERY_TYPE_EXPLAIN:
      return "QUERY_TYPE_EXPLAIN";
    case QueryType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function queryTypeToNumber(object: QueryType): number {
  switch (object) {
    case QueryType.QUERY_TYPE_UNSPECIFIED:
      return 0;
    case QueryType.QUERY_TYPE_SELECT:
      return 1;
    case QueryType.QUERY_TYPE_INSERT:
      return 2;
    case QueryType.QUERY_TYPE_UPDATE:
      return 3;
    case QueryType.QUERY_TYPE_DELETE:
      return 4;
    case QueryType.QUERY_TYPE_DDL:
      return 5;
    case QueryType.QUERY_TYPE_TRANSACTION:
      return 6;
    case QueryType.QUERY_TYPE_EXPLAIN:
      return 7;
    case QueryType.UNRECOGNIZED:
    default:
      return -1;
  }
}

/** Query execution mode */
export enum ExecutionMode {
  EXECUTION_MODE_UNSPECIFIED = "EXECUTION_MODE_UNSPECIFIED",
  EXECUTION_MODE_IMMEDIATE = "EXECUTION_MODE_IMMEDIATE",
  EXECUTION_MODE_STREAMING = "EXECUTION_MODE_STREAMING",
  EXECUTION_MODE_BATCH = "EXECUTION_MODE_BATCH",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function executionModeFromJSON(object: any): ExecutionMode {
  switch (object) {
    case 0:
    case "EXECUTION_MODE_UNSPECIFIED":
      return ExecutionMode.EXECUTION_MODE_UNSPECIFIED;
    case 1:
    case "EXECUTION_MODE_IMMEDIATE":
      return ExecutionMode.EXECUTION_MODE_IMMEDIATE;
    case 2:
    case "EXECUTION_MODE_STREAMING":
      return ExecutionMode.EXECUTION_MODE_STREAMING;
    case 3:
    case "EXECUTION_MODE_BATCH":
      return ExecutionMode.EXECUTION_MODE_BATCH;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ExecutionMode.UNRECOGNIZED;
  }
}

export function executionModeToJSON(object: ExecutionMode): string {
  switch (object) {
    case ExecutionMode.EXECUTION_MODE_UNSPECIFIED:
      return "EXECUTION_MODE_UNSPECIFIED";
    case ExecutionMode.EXECUTION_MODE_IMMEDIATE:
      return "EXECUTION_MODE_IMMEDIATE";
    case ExecutionMode.EXECUTION_MODE_STREAMING:
      return "EXECUTION_MODE_STREAMING";
    case ExecutionMode.EXECUTION_MODE_BATCH:
      return "EXECUTION_MODE_BATCH";
    case ExecutionMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function executionModeToNumber(object: ExecutionMode): number {
  switch (object) {
    case ExecutionMode.EXECUTION_MODE_UNSPECIFIED:
      return 0;
    case ExecutionMode.EXECUTION_MODE_IMMEDIATE:
      return 1;
    case ExecutionMode.EXECUTION_MODE_STREAMING:
      return 2;
    case ExecutionMode.EXECUTION_MODE_BATCH:
      return 3;
    case ExecutionMode.UNRECOGNIZED:
    default:
      return -1;
  }
}

/** Data format for streaming */
export enum DataFormat {
  DATA_FORMAT_UNSPECIFIED = "DATA_FORMAT_UNSPECIFIED",
  DATA_FORMAT_JSON = "DATA_FORMAT_JSON",
  DATA_FORMAT_NDJSON = "DATA_FORMAT_NDJSON",
  DATA_FORMAT_CSV = "DATA_FORMAT_CSV",
  DATA_FORMAT_PROTOBUF = "DATA_FORMAT_PROTOBUF",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function dataFormatFromJSON(object: any): DataFormat {
  switch (object) {
    case 0:
    case "DATA_FORMAT_UNSPECIFIED":
      return DataFormat.DATA_FORMAT_UNSPECIFIED;
    case 1:
    case "DATA_FORMAT_JSON":
      return DataFormat.DATA_FORMAT_JSON;
    case 2:
    case "DATA_FORMAT_NDJSON":
      return DataFormat.DATA_FORMAT_NDJSON;
    case 3:
    case "DATA_FORMAT_CSV":
      return DataFormat.DATA_FORMAT_CSV;
    case 4:
    case "DATA_FORMAT_PROTOBUF":
      return DataFormat.DATA_FORMAT_PROTOBUF;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DataFormat.UNRECOGNIZED;
  }
}

export function dataFormatToJSON(object: DataFormat): string {
  switch (object) {
    case DataFormat.DATA_FORMAT_UNSPECIFIED:
      return "DATA_FORMAT_UNSPECIFIED";
    case DataFormat.DATA_FORMAT_JSON:
      return "DATA_FORMAT_JSON";
    case DataFormat.DATA_FORMAT_NDJSON:
      return "DATA_FORMAT_NDJSON";
    case DataFormat.DATA_FORMAT_CSV:
      return "DATA_FORMAT_CSV";
    case DataFormat.DATA_FORMAT_PROTOBUF:
      return "DATA_FORMAT_PROTOBUF";
    case DataFormat.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function dataFormatToNumber(object: DataFormat): number {
  switch (object) {
    case DataFormat.DATA_FORMAT_UNSPECIFIED:
      return 0;
    case DataFormat.DATA_FORMAT_JSON:
      return 1;
    case DataFormat.DATA_FORMAT_NDJSON:
      return 2;
    case DataFormat.DATA_FORMAT_CSV:
      return 3;
    case DataFormat.DATA_FORMAT_PROTOBUF:
      return 4;
    case DataFormat.UNRECOGNIZED:
    default:
      return -1;
  }
}

/** Streaming query response types */
export enum StreamResponseType {
  STREAM_RESPONSE_TYPE_UNSPECIFIED = "STREAM_RESPONSE_TYPE_UNSPECIFIED",
  STREAM_RESPONSE_TYPE_METADATA = "STREAM_RESPONSE_TYPE_METADATA",
  STREAM_RESPONSE_TYPE_DATA = "STREAM_RESPONSE_TYPE_DATA",
  STREAM_RESPONSE_TYPE_PROGRESS = "STREAM_RESPONSE_TYPE_PROGRESS",
  STREAM_RESPONSE_TYPE_COMPLETE = "STREAM_RESPONSE_TYPE_COMPLETE",
  STREAM_RESPONSE_TYPE_ERROR = "STREAM_RESPONSE_TYPE_ERROR",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function streamResponseTypeFromJSON(object: any): StreamResponseType {
  switch (object) {
    case 0:
    case "STREAM_RESPONSE_TYPE_UNSPECIFIED":
      return StreamResponseType.STREAM_RESPONSE_TYPE_UNSPECIFIED;
    case 1:
    case "STREAM_RESPONSE_TYPE_METADATA":
      return StreamResponseType.STREAM_RESPONSE_TYPE_METADATA;
    case 2:
    case "STREAM_RESPONSE_TYPE_DATA":
      return StreamResponseType.STREAM_RESPONSE_TYPE_DATA;
    case 3:
    case "STREAM_RESPONSE_TYPE_PROGRESS":
      return StreamResponseType.STREAM_RESPONSE_TYPE_PROGRESS;
    case 4:
    case "STREAM_RESPONSE_TYPE_COMPLETE":
      return StreamResponseType.STREAM_RESPONSE_TYPE_COMPLETE;
    case 5:
    case "STREAM_RESPONSE_TYPE_ERROR":
      return StreamResponseType.STREAM_RESPONSE_TYPE_ERROR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return StreamResponseType.UNRECOGNIZED;
  }
}

export function streamResponseTypeToJSON(object: StreamResponseType): string {
  switch (object) {
    case StreamResponseType.STREAM_RESPONSE_TYPE_UNSPECIFIED:
      return "STREAM_RESPONSE_TYPE_UNSPECIFIED";
    case StreamResponseType.STREAM_RESPONSE_TYPE_METADATA:
      return "STREAM_RESPONSE_TYPE_METADATA";
    case StreamResponseType.STREAM_RESPONSE_TYPE_DATA:
      return "STREAM_RESPONSE_TYPE_DATA";
    case StreamResponseType.STREAM_RESPONSE_TYPE_PROGRESS:
      return "STREAM_RESPONSE_TYPE_PROGRESS";
    case StreamResponseType.STREAM_RESPONSE_TYPE_COMPLETE:
      return "STREAM_RESPONSE_TYPE_COMPLETE";
    case StreamResponseType.STREAM_RESPONSE_TYPE_ERROR:
      return "STREAM_RESPONSE_TYPE_ERROR";
    case StreamResponseType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function streamResponseTypeToNumber(object: StreamResponseType): number {
  switch (object) {
    case StreamResponseType.STREAM_RESPONSE_TYPE_UNSPECIFIED:
      return 0;
    case StreamResponseType.STREAM_RESPONSE_TYPE_METADATA:
      return 1;
    case StreamResponseType.STREAM_RESPONSE_TYPE_DATA:
      return 2;
    case StreamResponseType.STREAM_RESPONSE_TYPE_PROGRESS:
      return 3;
    case StreamResponseType.STREAM_RESPONSE_TYPE_COMPLETE:
      return 4;
    case StreamResponseType.STREAM_RESPONSE_TYPE_ERROR:
      return 5;
    case StreamResponseType.UNRECOGNIZED:
    default:
      return -1;
  }
}

/** Query status */
export enum QueryStatus {
  QUERY_STATUS_UNSPECIFIED = "QUERY_STATUS_UNSPECIFIED",
  QUERY_STATUS_PENDING = "QUERY_STATUS_PENDING",
  QUERY_STATUS_RUNNING = "QUERY_STATUS_RUNNING",
  QUERY_STATUS_COMPLETED = "QUERY_STATUS_COMPLETED",
  QUERY_STATUS_FAILED = "QUERY_STATUS_FAILED",
  QUERY_STATUS_CANCELLED = "QUERY_STATUS_CANCELLED",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function queryStatusFromJSON(object: any): QueryStatus {
  switch (object) {
    case 0:
    case "QUERY_STATUS_UNSPECIFIED":
      return QueryStatus.QUERY_STATUS_UNSPECIFIED;
    case 1:
    case "QUERY_STATUS_PENDING":
      return QueryStatus.QUERY_STATUS_PENDING;
    case 2:
    case "QUERY_STATUS_RUNNING":
      return QueryStatus.QUERY_STATUS_RUNNING;
    case 3:
    case "QUERY_STATUS_COMPLETED":
      return QueryStatus.QUERY_STATUS_COMPLETED;
    case 4:
    case "QUERY_STATUS_FAILED":
      return QueryStatus.QUERY_STATUS_FAILED;
    case 5:
    case "QUERY_STATUS_CANCELLED":
      return QueryStatus.QUERY_STATUS_CANCELLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return QueryStatus.UNRECOGNIZED;
  }
}

export function queryStatusToJSON(object: QueryStatus): string {
  switch (object) {
    case QueryStatus.QUERY_STATUS_UNSPECIFIED:
      return "QUERY_STATUS_UNSPECIFIED";
    case QueryStatus.QUERY_STATUS_PENDING:
      return "QUERY_STATUS_PENDING";
    case QueryStatus.QUERY_STATUS_RUNNING:
      return "QUERY_STATUS_RUNNING";
    case QueryStatus.QUERY_STATUS_COMPLETED:
      return "QUERY_STATUS_COMPLETED";
    case QueryStatus.QUERY_STATUS_FAILED:
      return "QUERY_STATUS_FAILED";
    case QueryStatus.QUERY_STATUS_CANCELLED:
      return "QUERY_STATUS_CANCELLED";
    case QueryStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function queryStatusToNumber(object: QueryStatus): number {
  switch (object) {
    case QueryStatus.QUERY_STATUS_UNSPECIFIED:
      return 0;
    case QueryStatus.QUERY_STATUS_PENDING:
      return 1;
    case QueryStatus.QUERY_STATUS_RUNNING:
      return 2;
    case QueryStatus.QUERY_STATUS_COMPLETED:
      return 3;
    case QueryStatus.QUERY_STATUS_FAILED:
      return 4;
    case QueryStatus.QUERY_STATUS_CANCELLED:
      return 5;
    case QueryStatus.UNRECOGNIZED:
    default:
      return -1;
  }
}

/** Execute query request */
export interface ExecuteQueryRequest {
  connectionId: string;
  sql: string;
  parameters: { [key: string]: Any };
  options:
    | QueryOptions
    | undefined;
  /** Optional client-provided ID */
  queryId: string;
}

export interface ExecuteQueryRequest_ParametersEntry {
  key: string;
  value: Any | undefined;
}

/** Query options */
export interface QueryOptions {
  limit: number;
  timeoutSeconds: number;
  readOnly: boolean;
  explain: boolean;
  format: DataFormat;
  includeMetadata: boolean;
  /** For streaming */
  fetchSize: number;
}

/** Column metadata */
export interface ColumnMetadata {
  name: string;
  type: string;
  nullable: boolean;
  ordinal: number;
  tableName: string;
  schemaName: string;
}

/** Query result row */
export interface QueryRow {
  values: Any[];
}

/** Query results */
export interface QueryResult {
  columns: ColumnMetadata[];
  rows: QueryRow[];
  rowCount: Long;
  moreResults: boolean;
  /** For pagination */
  cursor: string;
}

/** Query execution statistics */
export interface QueryStats {
  startTime: Date | undefined;
  endTime: Date | undefined;
  durationMs: Long;
  rowsAffected: Long;
  rowsReturned: Long;
  bytesProcessed: Long;
  bytesReturned: Long;
  cpuTimeMs: number;
  memoryUsedBytes: Long;
  diskReads: Long;
  diskWrites: Long;
}

/** Execute query response */
export interface ExecuteQueryResponse {
  success: boolean;
  message: string;
  queryId: string;
  result: QueryResult | undefined;
  stats: QueryStats | undefined;
  warnings: string[];
}

/** Execute streaming query request */
export interface ExecuteStreamingQueryRequest {
  connectionId: string;
  sql: string;
  parameters: { [key: string]: Any };
  options: QueryOptions | undefined;
  queryId: string;
}

export interface ExecuteStreamingQueryRequest_ParametersEntry {
  key: string;
  value: Any | undefined;
}

/** Query progress information */
export interface QueryProgress {
  rowsProcessed: Long;
  /** If known */
  totalRows: Long;
  progressPercentage: number;
  lastUpdate: Date | undefined;
  currentPhase: string;
  metrics: { [key: string]: string };
}

export interface QueryProgress_MetricsEntry {
  key: string;
  value: string;
}

/** Metadata wrapper for oneof */
export interface MetadataPayload {
  columns: ColumnMetadata[];
}

/** Streaming query response */
export interface StreamingQueryResponse {
  type: StreamResponseType;
  queryId: string;
  metadata?: MetadataPayload | undefined;
  data?: QueryRow | undefined;
  progress?: QueryProgress | undefined;
  completion?: QueryStats | undefined;
  error?: string | undefined;
}

/** Cancel query request */
export interface CancelQueryRequest {
  queryId: string;
}

/** Cancel query response */
export interface CancelQueryResponse {
  success: boolean;
  message: string;
  wasRunning: boolean;
}

/** Get query status request */
export interface GetQueryStatusRequest {
  queryId: string;
}

/** Get query status response */
export interface GetQueryStatusResponse {
  success: boolean;
  message: string;
  status: QueryStatus;
  progress: QueryProgress | undefined;
  stats: QueryStats | undefined;
}

/** List active queries request */
export interface ListActiveQueriesRequest {
  /** Optional filter */
  connectionId: string;
  /** Optional filter */
  userId: string;
}

/** Active query info */
export interface ActiveQuery {
  queryId: string;
  connectionId: string;
  userId: string;
  sql: string;
  status: QueryStatus;
  startedAt: Date | undefined;
  progress: QueryProgress | undefined;
}

/** List active queries response */
export interface ListActiveQueriesResponse {
  success: boolean;
  message: string;
  queries: ActiveQuery[];
}

/** Batch edit operation */
export interface BatchEditOperation {
  id: string;
  type: BatchEditOperation_OperationType;
  tableName: string;
  schemaName: string;
  values: { [key: string]: Any };
  whereConditions: { [key: string]: Any };
  /** For optimistic locking */
  version: Long;
}

export enum BatchEditOperation_OperationType {
  OPERATION_TYPE_UNSPECIFIED = "OPERATION_TYPE_UNSPECIFIED",
  OPERATION_TYPE_INSERT = "OPERATION_TYPE_INSERT",
  OPERATION_TYPE_UPDATE = "OPERATION_TYPE_UPDATE",
  OPERATION_TYPE_DELETE = "OPERATION_TYPE_DELETE",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function batchEditOperation_OperationTypeFromJSON(object: any): BatchEditOperation_OperationType {
  switch (object) {
    case 0:
    case "OPERATION_TYPE_UNSPECIFIED":
      return BatchEditOperation_OperationType.OPERATION_TYPE_UNSPECIFIED;
    case 1:
    case "OPERATION_TYPE_INSERT":
      return BatchEditOperation_OperationType.OPERATION_TYPE_INSERT;
    case 2:
    case "OPERATION_TYPE_UPDATE":
      return BatchEditOperation_OperationType.OPERATION_TYPE_UPDATE;
    case 3:
    case "OPERATION_TYPE_DELETE":
      return BatchEditOperation_OperationType.OPERATION_TYPE_DELETE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BatchEditOperation_OperationType.UNRECOGNIZED;
  }
}

export function batchEditOperation_OperationTypeToJSON(object: BatchEditOperation_OperationType): string {
  switch (object) {
    case BatchEditOperation_OperationType.OPERATION_TYPE_UNSPECIFIED:
      return "OPERATION_TYPE_UNSPECIFIED";
    case BatchEditOperation_OperationType.OPERATION_TYPE_INSERT:
      return "OPERATION_TYPE_INSERT";
    case BatchEditOperation_OperationType.OPERATION_TYPE_UPDATE:
      return "OPERATION_TYPE_UPDATE";
    case BatchEditOperation_OperationType.OPERATION_TYPE_DELETE:
      return "OPERATION_TYPE_DELETE";
    case BatchEditOperation_OperationType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function batchEditOperation_OperationTypeToNumber(object: BatchEditOperation_OperationType): number {
  switch (object) {
    case BatchEditOperation_OperationType.OPERATION_TYPE_UNSPECIFIED:
      return 0;
    case BatchEditOperation_OperationType.OPERATION_TYPE_INSERT:
      return 1;
    case BatchEditOperation_OperationType.OPERATION_TYPE_UPDATE:
      return 2;
    case BatchEditOperation_OperationType.OPERATION_TYPE_DELETE:
      return 3;
    case BatchEditOperation_OperationType.UNRECOGNIZED:
    default:
      return -1;
  }
}

export interface BatchEditOperation_ValuesEntry {
  key: string;
  value: Any | undefined;
}

export interface BatchEditOperation_WhereConditionsEntry {
  key: string;
  value: Any | undefined;
}

/** Execute batch edit request */
export interface ExecuteBatchEditRequest {
  connectionId: string;
  operations: BatchEditOperation[];
  useTransaction: boolean;
  options: QueryOptions | undefined;
}

/** Batch edit result */
export interface BatchEditResult {
  operationId: string;
  success: boolean;
  message: string;
  rowsAffected: Long;
  /** For INSERT with RETURNING */
  returnedValues: { [key: string]: Any };
}

export interface BatchEditResult_ReturnedValuesEntry {
  key: string;
  value: Any | undefined;
}

/** Execute batch edit response */
export interface ExecuteBatchEditResponse {
  success: boolean;
  message: string;
  results: BatchEditResult[];
  stats: QueryStats | undefined;
  transactionId: string;
}

/** Get query history request */
export interface GetQueryHistoryRequest {
  /** Optional filter */
  connectionId: string;
  /** Optional filter */
  userId: string;
  fromTime: Date | undefined;
  toTime: Date | undefined;
  limit: number;
  /** For pagination */
  cursor: string;
}

/** Query history entry */
export interface QueryHistoryEntry {
  queryId: string;
  connectionId: string;
  userId: string;
  sql: string;
  status: QueryStatus;
  startedAt: Date | undefined;
  completedAt: Date | undefined;
  stats: QueryStats | undefined;
  errorMessage: string;
}

/** Get query history response */
export interface GetQueryHistoryResponse {
  success: boolean;
  message: string;
  entries: QueryHistoryEntry[];
  nextCursor: string;
  hasMore: boolean;
}

/** Explain query request */
export interface ExplainQueryRequest {
  connectionId: string;
  sql: string;
  parameters: { [key: string]: Any };
  /** Include actual execution stats */
  analyze: boolean;
  /** JSON, TEXT, XML, YAML */
  format: string;
}

export interface ExplainQueryRequest_ParametersEntry {
  key: string;
  value: Any | undefined;
}

/** Query execution plan */
export interface ExecutionPlan {
  format: string;
  plan: string;
  estimatedStats:
    | QueryStats
    | undefined;
  /** If analyze=true */
  actualStats: QueryStats | undefined;
  warnings: string[];
}

/** Explain query response */
export interface ExplainQueryResponse {
  success: boolean;
  message: string;
  plan: ExecutionPlan | undefined;
}

function createBaseExecuteQueryRequest(): ExecuteQueryRequest {
  return { connectionId: "", sql: "", parameters: {}, options: undefined, queryId: "" };
}

export const ExecuteQueryRequest: MessageFns<ExecuteQueryRequest> = {
  encode(message: ExecuteQueryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.connectionId !== "") {
      writer.uint32(10).string(message.connectionId);
    }
    if (message.sql !== "") {
      writer.uint32(18).string(message.sql);
    }
    Object.entries(message.parameters).forEach(([key, value]) => {
      ExecuteQueryRequest_ParametersEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    if (message.options !== undefined) {
      QueryOptions.encode(message.options, writer.uint32(34).fork()).join();
    }
    if (message.queryId !== "") {
      writer.uint32(42).string(message.queryId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecuteQueryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecuteQueryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.connectionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sql = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = ExecuteQueryRequest_ParametersEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.parameters[entry3.key] = entry3.value;
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.options = QueryOptions.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.queryId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecuteQueryRequest {
    return {
      connectionId: isSet(object.connectionId) ? globalThis.String(object.connectionId) : "",
      sql: isSet(object.sql) ? globalThis.String(object.sql) : "",
      parameters: isObject(object.parameters)
        ? Object.entries(object.parameters).reduce<{ [key: string]: Any }>((acc, [key, value]) => {
          acc[key] = Any.fromJSON(value);
          return acc;
        }, {})
        : {},
      options: isSet(object.options) ? QueryOptions.fromJSON(object.options) : undefined,
      queryId: isSet(object.queryId) ? globalThis.String(object.queryId) : "",
    };
  },

  toJSON(message: ExecuteQueryRequest): unknown {
    const obj: any = {};
    if (message.connectionId !== "") {
      obj.connectionId = message.connectionId;
    }
    if (message.sql !== "") {
      obj.sql = message.sql;
    }
    if (message.parameters) {
      const entries = Object.entries(message.parameters);
      if (entries.length > 0) {
        obj.parameters = {};
        entries.forEach(([k, v]) => {
          obj.parameters[k] = Any.toJSON(v);
        });
      }
    }
    if (message.options !== undefined) {
      obj.options = QueryOptions.toJSON(message.options);
    }
    if (message.queryId !== "") {
      obj.queryId = message.queryId;
    }
    return obj;
  },

  create(base?: DeepPartial<ExecuteQueryRequest>): ExecuteQueryRequest {
    return ExecuteQueryRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExecuteQueryRequest>): ExecuteQueryRequest {
    const message = createBaseExecuteQueryRequest();
    message.connectionId = object.connectionId ?? "";
    message.sql = object.sql ?? "";
    message.parameters = Object.entries(object.parameters ?? {}).reduce<{ [key: string]: Any }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Any.fromPartial(value);
      }
      return acc;
    }, {});
    message.options = (object.options !== undefined && object.options !== null)
      ? QueryOptions.fromPartial(object.options)
      : undefined;
    message.queryId = object.queryId ?? "";
    return message;
  },
};

function createBaseExecuteQueryRequest_ParametersEntry(): ExecuteQueryRequest_ParametersEntry {
  return { key: "", value: undefined };
}

export const ExecuteQueryRequest_ParametersEntry: MessageFns<ExecuteQueryRequest_ParametersEntry> = {
  encode(message: ExecuteQueryRequest_ParametersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Any.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecuteQueryRequest_ParametersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecuteQueryRequest_ParametersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Any.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecuteQueryRequest_ParametersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Any.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: ExecuteQueryRequest_ParametersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Any.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<ExecuteQueryRequest_ParametersEntry>): ExecuteQueryRequest_ParametersEntry {
    return ExecuteQueryRequest_ParametersEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExecuteQueryRequest_ParametersEntry>): ExecuteQueryRequest_ParametersEntry {
    const message = createBaseExecuteQueryRequest_ParametersEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Any.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseQueryOptions(): QueryOptions {
  return {
    limit: 0,
    timeoutSeconds: 0,
    readOnly: false,
    explain: false,
    format: DataFormat.DATA_FORMAT_UNSPECIFIED,
    includeMetadata: false,
    fetchSize: 0,
  };
}

export const QueryOptions: MessageFns<QueryOptions> = {
  encode(message: QueryOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.limit !== 0) {
      writer.uint32(8).int32(message.limit);
    }
    if (message.timeoutSeconds !== 0) {
      writer.uint32(16).int32(message.timeoutSeconds);
    }
    if (message.readOnly !== false) {
      writer.uint32(24).bool(message.readOnly);
    }
    if (message.explain !== false) {
      writer.uint32(32).bool(message.explain);
    }
    if (message.format !== DataFormat.DATA_FORMAT_UNSPECIFIED) {
      writer.uint32(40).int32(dataFormatToNumber(message.format));
    }
    if (message.includeMetadata !== false) {
      writer.uint32(48).bool(message.includeMetadata);
    }
    if (message.fetchSize !== 0) {
      writer.uint32(56).int32(message.fetchSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.timeoutSeconds = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.readOnly = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.explain = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.format = dataFormatFromJSON(reader.int32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.includeMetadata = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.fetchSize = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryOptions {
    return {
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      timeoutSeconds: isSet(object.timeoutSeconds) ? globalThis.Number(object.timeoutSeconds) : 0,
      readOnly: isSet(object.readOnly) ? globalThis.Boolean(object.readOnly) : false,
      explain: isSet(object.explain) ? globalThis.Boolean(object.explain) : false,
      format: isSet(object.format) ? dataFormatFromJSON(object.format) : DataFormat.DATA_FORMAT_UNSPECIFIED,
      includeMetadata: isSet(object.includeMetadata) ? globalThis.Boolean(object.includeMetadata) : false,
      fetchSize: isSet(object.fetchSize) ? globalThis.Number(object.fetchSize) : 0,
    };
  },

  toJSON(message: QueryOptions): unknown {
    const obj: any = {};
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.timeoutSeconds !== 0) {
      obj.timeoutSeconds = Math.round(message.timeoutSeconds);
    }
    if (message.readOnly !== false) {
      obj.readOnly = message.readOnly;
    }
    if (message.explain !== false) {
      obj.explain = message.explain;
    }
    if (message.format !== DataFormat.DATA_FORMAT_UNSPECIFIED) {
      obj.format = dataFormatToJSON(message.format);
    }
    if (message.includeMetadata !== false) {
      obj.includeMetadata = message.includeMetadata;
    }
    if (message.fetchSize !== 0) {
      obj.fetchSize = Math.round(message.fetchSize);
    }
    return obj;
  },

  create(base?: DeepPartial<QueryOptions>): QueryOptions {
    return QueryOptions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryOptions>): QueryOptions {
    const message = createBaseQueryOptions();
    message.limit = object.limit ?? 0;
    message.timeoutSeconds = object.timeoutSeconds ?? 0;
    message.readOnly = object.readOnly ?? false;
    message.explain = object.explain ?? false;
    message.format = object.format ?? DataFormat.DATA_FORMAT_UNSPECIFIED;
    message.includeMetadata = object.includeMetadata ?? false;
    message.fetchSize = object.fetchSize ?? 0;
    return message;
  },
};

function createBaseColumnMetadata(): ColumnMetadata {
  return { name: "", type: "", nullable: false, ordinal: 0, tableName: "", schemaName: "" };
}

export const ColumnMetadata: MessageFns<ColumnMetadata> = {
  encode(message: ColumnMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.type !== "") {
      writer.uint32(18).string(message.type);
    }
    if (message.nullable !== false) {
      writer.uint32(24).bool(message.nullable);
    }
    if (message.ordinal !== 0) {
      writer.uint32(32).int32(message.ordinal);
    }
    if (message.tableName !== "") {
      writer.uint32(42).string(message.tableName);
    }
    if (message.schemaName !== "") {
      writer.uint32(50).string(message.schemaName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ColumnMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseColumnMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.nullable = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.ordinal = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.tableName = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.schemaName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ColumnMetadata {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      nullable: isSet(object.nullable) ? globalThis.Boolean(object.nullable) : false,
      ordinal: isSet(object.ordinal) ? globalThis.Number(object.ordinal) : 0,
      tableName: isSet(object.tableName) ? globalThis.String(object.tableName) : "",
      schemaName: isSet(object.schemaName) ? globalThis.String(object.schemaName) : "",
    };
  },

  toJSON(message: ColumnMetadata): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.nullable !== false) {
      obj.nullable = message.nullable;
    }
    if (message.ordinal !== 0) {
      obj.ordinal = Math.round(message.ordinal);
    }
    if (message.tableName !== "") {
      obj.tableName = message.tableName;
    }
    if (message.schemaName !== "") {
      obj.schemaName = message.schemaName;
    }
    return obj;
  },

  create(base?: DeepPartial<ColumnMetadata>): ColumnMetadata {
    return ColumnMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ColumnMetadata>): ColumnMetadata {
    const message = createBaseColumnMetadata();
    message.name = object.name ?? "";
    message.type = object.type ?? "";
    message.nullable = object.nullable ?? false;
    message.ordinal = object.ordinal ?? 0;
    message.tableName = object.tableName ?? "";
    message.schemaName = object.schemaName ?? "";
    return message;
  },
};

function createBaseQueryRow(): QueryRow {
  return { values: [] };
}

export const QueryRow: MessageFns<QueryRow> = {
  encode(message: QueryRow, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.values) {
      Any.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryRow {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryRow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.values.push(Any.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryRow {
    return { values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => Any.fromJSON(e)) : [] };
  },

  toJSON(message: QueryRow): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values.map((e) => Any.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<QueryRow>): QueryRow {
    return QueryRow.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryRow>): QueryRow {
    const message = createBaseQueryRow();
    message.values = object.values?.map((e) => Any.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryResult(): QueryResult {
  return { columns: [], rows: [], rowCount: Long.ZERO, moreResults: false, cursor: "" };
}

export const QueryResult: MessageFns<QueryResult> = {
  encode(message: QueryResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.columns) {
      ColumnMetadata.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.rows) {
      QueryRow.encode(v!, writer.uint32(18).fork()).join();
    }
    if (!message.rowCount.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.rowCount.toString());
    }
    if (message.moreResults !== false) {
      writer.uint32(32).bool(message.moreResults);
    }
    if (message.cursor !== "") {
      writer.uint32(42).string(message.cursor);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.columns.push(ColumnMetadata.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.rows.push(QueryRow.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.rowCount = Long.fromString(reader.int64().toString());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.moreResults = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.cursor = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryResult {
    return {
      columns: globalThis.Array.isArray(object?.columns)
        ? object.columns.map((e: any) => ColumnMetadata.fromJSON(e))
        : [],
      rows: globalThis.Array.isArray(object?.rows) ? object.rows.map((e: any) => QueryRow.fromJSON(e)) : [],
      rowCount: isSet(object.rowCount) ? Long.fromValue(object.rowCount) : Long.ZERO,
      moreResults: isSet(object.moreResults) ? globalThis.Boolean(object.moreResults) : false,
      cursor: isSet(object.cursor) ? globalThis.String(object.cursor) : "",
    };
  },

  toJSON(message: QueryResult): unknown {
    const obj: any = {};
    if (message.columns?.length) {
      obj.columns = message.columns.map((e) => ColumnMetadata.toJSON(e));
    }
    if (message.rows?.length) {
      obj.rows = message.rows.map((e) => QueryRow.toJSON(e));
    }
    if (!message.rowCount.equals(Long.ZERO)) {
      obj.rowCount = (message.rowCount || Long.ZERO).toString();
    }
    if (message.moreResults !== false) {
      obj.moreResults = message.moreResults;
    }
    if (message.cursor !== "") {
      obj.cursor = message.cursor;
    }
    return obj;
  },

  create(base?: DeepPartial<QueryResult>): QueryResult {
    return QueryResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryResult>): QueryResult {
    const message = createBaseQueryResult();
    message.columns = object.columns?.map((e) => ColumnMetadata.fromPartial(e)) || [];
    message.rows = object.rows?.map((e) => QueryRow.fromPartial(e)) || [];
    message.rowCount = (object.rowCount !== undefined && object.rowCount !== null)
      ? Long.fromValue(object.rowCount)
      : Long.ZERO;
    message.moreResults = object.moreResults ?? false;
    message.cursor = object.cursor ?? "";
    return message;
  },
};

function createBaseQueryStats(): QueryStats {
  return {
    startTime: undefined,
    endTime: undefined,
    durationMs: Long.ZERO,
    rowsAffected: Long.ZERO,
    rowsReturned: Long.ZERO,
    bytesProcessed: Long.ZERO,
    bytesReturned: Long.ZERO,
    cpuTimeMs: 0,
    memoryUsedBytes: Long.ZERO,
    diskReads: Long.ZERO,
    diskWrites: Long.ZERO,
  };
}

export const QueryStats: MessageFns<QueryStats> = {
  encode(message: QueryStats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(10).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(18).fork()).join();
    }
    if (!message.durationMs.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.durationMs.toString());
    }
    if (!message.rowsAffected.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.rowsAffected.toString());
    }
    if (!message.rowsReturned.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.rowsReturned.toString());
    }
    if (!message.bytesProcessed.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.bytesProcessed.toString());
    }
    if (!message.bytesReturned.equals(Long.ZERO)) {
      writer.uint32(56).int64(message.bytesReturned.toString());
    }
    if (message.cpuTimeMs !== 0) {
      writer.uint32(65).double(message.cpuTimeMs);
    }
    if (!message.memoryUsedBytes.equals(Long.ZERO)) {
      writer.uint32(72).int64(message.memoryUsedBytes.toString());
    }
    if (!message.diskReads.equals(Long.ZERO)) {
      writer.uint32(80).int64(message.diskReads.toString());
    }
    if (!message.diskWrites.equals(Long.ZERO)) {
      writer.uint32(88).int64(message.diskWrites.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.durationMs = Long.fromString(reader.int64().toString());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.rowsAffected = Long.fromString(reader.int64().toString());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.rowsReturned = Long.fromString(reader.int64().toString());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.bytesProcessed = Long.fromString(reader.int64().toString());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.bytesReturned = Long.fromString(reader.int64().toString());
          continue;
        }
        case 8: {
          if (tag !== 65) {
            break;
          }

          message.cpuTimeMs = reader.double();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.memoryUsedBytes = Long.fromString(reader.int64().toString());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.diskReads = Long.fromString(reader.int64().toString());
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.diskWrites = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryStats {
    return {
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
      durationMs: isSet(object.durationMs) ? Long.fromValue(object.durationMs) : Long.ZERO,
      rowsAffected: isSet(object.rowsAffected) ? Long.fromValue(object.rowsAffected) : Long.ZERO,
      rowsReturned: isSet(object.rowsReturned) ? Long.fromValue(object.rowsReturned) : Long.ZERO,
      bytesProcessed: isSet(object.bytesProcessed) ? Long.fromValue(object.bytesProcessed) : Long.ZERO,
      bytesReturned: isSet(object.bytesReturned) ? Long.fromValue(object.bytesReturned) : Long.ZERO,
      cpuTimeMs: isSet(object.cpuTimeMs) ? globalThis.Number(object.cpuTimeMs) : 0,
      memoryUsedBytes: isSet(object.memoryUsedBytes) ? Long.fromValue(object.memoryUsedBytes) : Long.ZERO,
      diskReads: isSet(object.diskReads) ? Long.fromValue(object.diskReads) : Long.ZERO,
      diskWrites: isSet(object.diskWrites) ? Long.fromValue(object.diskWrites) : Long.ZERO,
    };
  },

  toJSON(message: QueryStats): unknown {
    const obj: any = {};
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    if (!message.durationMs.equals(Long.ZERO)) {
      obj.durationMs = (message.durationMs || Long.ZERO).toString();
    }
    if (!message.rowsAffected.equals(Long.ZERO)) {
      obj.rowsAffected = (message.rowsAffected || Long.ZERO).toString();
    }
    if (!message.rowsReturned.equals(Long.ZERO)) {
      obj.rowsReturned = (message.rowsReturned || Long.ZERO).toString();
    }
    if (!message.bytesProcessed.equals(Long.ZERO)) {
      obj.bytesProcessed = (message.bytesProcessed || Long.ZERO).toString();
    }
    if (!message.bytesReturned.equals(Long.ZERO)) {
      obj.bytesReturned = (message.bytesReturned || Long.ZERO).toString();
    }
    if (message.cpuTimeMs !== 0) {
      obj.cpuTimeMs = message.cpuTimeMs;
    }
    if (!message.memoryUsedBytes.equals(Long.ZERO)) {
      obj.memoryUsedBytes = (message.memoryUsedBytes || Long.ZERO).toString();
    }
    if (!message.diskReads.equals(Long.ZERO)) {
      obj.diskReads = (message.diskReads || Long.ZERO).toString();
    }
    if (!message.diskWrites.equals(Long.ZERO)) {
      obj.diskWrites = (message.diskWrites || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<QueryStats>): QueryStats {
    return QueryStats.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryStats>): QueryStats {
    const message = createBaseQueryStats();
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    message.durationMs = (object.durationMs !== undefined && object.durationMs !== null)
      ? Long.fromValue(object.durationMs)
      : Long.ZERO;
    message.rowsAffected = (object.rowsAffected !== undefined && object.rowsAffected !== null)
      ? Long.fromValue(object.rowsAffected)
      : Long.ZERO;
    message.rowsReturned = (object.rowsReturned !== undefined && object.rowsReturned !== null)
      ? Long.fromValue(object.rowsReturned)
      : Long.ZERO;
    message.bytesProcessed = (object.bytesProcessed !== undefined && object.bytesProcessed !== null)
      ? Long.fromValue(object.bytesProcessed)
      : Long.ZERO;
    message.bytesReturned = (object.bytesReturned !== undefined && object.bytesReturned !== null)
      ? Long.fromValue(object.bytesReturned)
      : Long.ZERO;
    message.cpuTimeMs = object.cpuTimeMs ?? 0;
    message.memoryUsedBytes = (object.memoryUsedBytes !== undefined && object.memoryUsedBytes !== null)
      ? Long.fromValue(object.memoryUsedBytes)
      : Long.ZERO;
    message.diskReads = (object.diskReads !== undefined && object.diskReads !== null)
      ? Long.fromValue(object.diskReads)
      : Long.ZERO;
    message.diskWrites = (object.diskWrites !== undefined && object.diskWrites !== null)
      ? Long.fromValue(object.diskWrites)
      : Long.ZERO;
    return message;
  },
};

function createBaseExecuteQueryResponse(): ExecuteQueryResponse {
  return { success: false, message: "", queryId: "", result: undefined, stats: undefined, warnings: [] };
}

export const ExecuteQueryResponse: MessageFns<ExecuteQueryResponse> = {
  encode(message: ExecuteQueryResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.queryId !== "") {
      writer.uint32(26).string(message.queryId);
    }
    if (message.result !== undefined) {
      QueryResult.encode(message.result, writer.uint32(34).fork()).join();
    }
    if (message.stats !== undefined) {
      QueryStats.encode(message.stats, writer.uint32(42).fork()).join();
    }
    for (const v of message.warnings) {
      writer.uint32(50).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecuteQueryResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecuteQueryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.queryId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.result = QueryResult.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.stats = QueryStats.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.warnings.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecuteQueryResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      queryId: isSet(object.queryId) ? globalThis.String(object.queryId) : "",
      result: isSet(object.result) ? QueryResult.fromJSON(object.result) : undefined,
      stats: isSet(object.stats) ? QueryStats.fromJSON(object.stats) : undefined,
      warnings: globalThis.Array.isArray(object?.warnings) ? object.warnings.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: ExecuteQueryResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.queryId !== "") {
      obj.queryId = message.queryId;
    }
    if (message.result !== undefined) {
      obj.result = QueryResult.toJSON(message.result);
    }
    if (message.stats !== undefined) {
      obj.stats = QueryStats.toJSON(message.stats);
    }
    if (message.warnings?.length) {
      obj.warnings = message.warnings;
    }
    return obj;
  },

  create(base?: DeepPartial<ExecuteQueryResponse>): ExecuteQueryResponse {
    return ExecuteQueryResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExecuteQueryResponse>): ExecuteQueryResponse {
    const message = createBaseExecuteQueryResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.queryId = object.queryId ?? "";
    message.result = (object.result !== undefined && object.result !== null)
      ? QueryResult.fromPartial(object.result)
      : undefined;
    message.stats = (object.stats !== undefined && object.stats !== null)
      ? QueryStats.fromPartial(object.stats)
      : undefined;
    message.warnings = object.warnings?.map((e) => e) || [];
    return message;
  },
};

function createBaseExecuteStreamingQueryRequest(): ExecuteStreamingQueryRequest {
  return { connectionId: "", sql: "", parameters: {}, options: undefined, queryId: "" };
}

export const ExecuteStreamingQueryRequest: MessageFns<ExecuteStreamingQueryRequest> = {
  encode(message: ExecuteStreamingQueryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.connectionId !== "") {
      writer.uint32(10).string(message.connectionId);
    }
    if (message.sql !== "") {
      writer.uint32(18).string(message.sql);
    }
    Object.entries(message.parameters).forEach(([key, value]) => {
      ExecuteStreamingQueryRequest_ParametersEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    if (message.options !== undefined) {
      QueryOptions.encode(message.options, writer.uint32(34).fork()).join();
    }
    if (message.queryId !== "") {
      writer.uint32(42).string(message.queryId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecuteStreamingQueryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecuteStreamingQueryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.connectionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sql = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = ExecuteStreamingQueryRequest_ParametersEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.parameters[entry3.key] = entry3.value;
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.options = QueryOptions.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.queryId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecuteStreamingQueryRequest {
    return {
      connectionId: isSet(object.connectionId) ? globalThis.String(object.connectionId) : "",
      sql: isSet(object.sql) ? globalThis.String(object.sql) : "",
      parameters: isObject(object.parameters)
        ? Object.entries(object.parameters).reduce<{ [key: string]: Any }>((acc, [key, value]) => {
          acc[key] = Any.fromJSON(value);
          return acc;
        }, {})
        : {},
      options: isSet(object.options) ? QueryOptions.fromJSON(object.options) : undefined,
      queryId: isSet(object.queryId) ? globalThis.String(object.queryId) : "",
    };
  },

  toJSON(message: ExecuteStreamingQueryRequest): unknown {
    const obj: any = {};
    if (message.connectionId !== "") {
      obj.connectionId = message.connectionId;
    }
    if (message.sql !== "") {
      obj.sql = message.sql;
    }
    if (message.parameters) {
      const entries = Object.entries(message.parameters);
      if (entries.length > 0) {
        obj.parameters = {};
        entries.forEach(([k, v]) => {
          obj.parameters[k] = Any.toJSON(v);
        });
      }
    }
    if (message.options !== undefined) {
      obj.options = QueryOptions.toJSON(message.options);
    }
    if (message.queryId !== "") {
      obj.queryId = message.queryId;
    }
    return obj;
  },

  create(base?: DeepPartial<ExecuteStreamingQueryRequest>): ExecuteStreamingQueryRequest {
    return ExecuteStreamingQueryRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExecuteStreamingQueryRequest>): ExecuteStreamingQueryRequest {
    const message = createBaseExecuteStreamingQueryRequest();
    message.connectionId = object.connectionId ?? "";
    message.sql = object.sql ?? "";
    message.parameters = Object.entries(object.parameters ?? {}).reduce<{ [key: string]: Any }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Any.fromPartial(value);
      }
      return acc;
    }, {});
    message.options = (object.options !== undefined && object.options !== null)
      ? QueryOptions.fromPartial(object.options)
      : undefined;
    message.queryId = object.queryId ?? "";
    return message;
  },
};

function createBaseExecuteStreamingQueryRequest_ParametersEntry(): ExecuteStreamingQueryRequest_ParametersEntry {
  return { key: "", value: undefined };
}

export const ExecuteStreamingQueryRequest_ParametersEntry: MessageFns<ExecuteStreamingQueryRequest_ParametersEntry> = {
  encode(
    message: ExecuteStreamingQueryRequest_ParametersEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Any.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecuteStreamingQueryRequest_ParametersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecuteStreamingQueryRequest_ParametersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Any.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecuteStreamingQueryRequest_ParametersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Any.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: ExecuteStreamingQueryRequest_ParametersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Any.toJSON(message.value);
    }
    return obj;
  },

  create(
    base?: DeepPartial<ExecuteStreamingQueryRequest_ParametersEntry>,
  ): ExecuteStreamingQueryRequest_ParametersEntry {
    return ExecuteStreamingQueryRequest_ParametersEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ExecuteStreamingQueryRequest_ParametersEntry>,
  ): ExecuteStreamingQueryRequest_ParametersEntry {
    const message = createBaseExecuteStreamingQueryRequest_ParametersEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Any.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseQueryProgress(): QueryProgress {
  return {
    rowsProcessed: Long.ZERO,
    totalRows: Long.ZERO,
    progressPercentage: 0,
    lastUpdate: undefined,
    currentPhase: "",
    metrics: {},
  };
}

export const QueryProgress: MessageFns<QueryProgress> = {
  encode(message: QueryProgress, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.rowsProcessed.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.rowsProcessed.toString());
    }
    if (!message.totalRows.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.totalRows.toString());
    }
    if (message.progressPercentage !== 0) {
      writer.uint32(25).double(message.progressPercentage);
    }
    if (message.lastUpdate !== undefined) {
      Timestamp.encode(toTimestamp(message.lastUpdate), writer.uint32(34).fork()).join();
    }
    if (message.currentPhase !== "") {
      writer.uint32(42).string(message.currentPhase);
    }
    Object.entries(message.metrics).forEach(([key, value]) => {
      QueryProgress_MetricsEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryProgress {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryProgress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.rowsProcessed = Long.fromString(reader.int64().toString());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalRows = Long.fromString(reader.int64().toString());
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.progressPercentage = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.lastUpdate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.currentPhase = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          const entry6 = QueryProgress_MetricsEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.metrics[entry6.key] = entry6.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryProgress {
    return {
      rowsProcessed: isSet(object.rowsProcessed) ? Long.fromValue(object.rowsProcessed) : Long.ZERO,
      totalRows: isSet(object.totalRows) ? Long.fromValue(object.totalRows) : Long.ZERO,
      progressPercentage: isSet(object.progressPercentage) ? globalThis.Number(object.progressPercentage) : 0,
      lastUpdate: isSet(object.lastUpdate) ? fromJsonTimestamp(object.lastUpdate) : undefined,
      currentPhase: isSet(object.currentPhase) ? globalThis.String(object.currentPhase) : "",
      metrics: isObject(object.metrics)
        ? Object.entries(object.metrics).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: QueryProgress): unknown {
    const obj: any = {};
    if (!message.rowsProcessed.equals(Long.ZERO)) {
      obj.rowsProcessed = (message.rowsProcessed || Long.ZERO).toString();
    }
    if (!message.totalRows.equals(Long.ZERO)) {
      obj.totalRows = (message.totalRows || Long.ZERO).toString();
    }
    if (message.progressPercentage !== 0) {
      obj.progressPercentage = message.progressPercentage;
    }
    if (message.lastUpdate !== undefined) {
      obj.lastUpdate = message.lastUpdate.toISOString();
    }
    if (message.currentPhase !== "") {
      obj.currentPhase = message.currentPhase;
    }
    if (message.metrics) {
      const entries = Object.entries(message.metrics);
      if (entries.length > 0) {
        obj.metrics = {};
        entries.forEach(([k, v]) => {
          obj.metrics[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<QueryProgress>): QueryProgress {
    return QueryProgress.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryProgress>): QueryProgress {
    const message = createBaseQueryProgress();
    message.rowsProcessed = (object.rowsProcessed !== undefined && object.rowsProcessed !== null)
      ? Long.fromValue(object.rowsProcessed)
      : Long.ZERO;
    message.totalRows = (object.totalRows !== undefined && object.totalRows !== null)
      ? Long.fromValue(object.totalRows)
      : Long.ZERO;
    message.progressPercentage = object.progressPercentage ?? 0;
    message.lastUpdate = object.lastUpdate ?? undefined;
    message.currentPhase = object.currentPhase ?? "";
    message.metrics = Object.entries(object.metrics ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseQueryProgress_MetricsEntry(): QueryProgress_MetricsEntry {
  return { key: "", value: "" };
}

export const QueryProgress_MetricsEntry: MessageFns<QueryProgress_MetricsEntry> = {
  encode(message: QueryProgress_MetricsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryProgress_MetricsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryProgress_MetricsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryProgress_MetricsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: QueryProgress_MetricsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<QueryProgress_MetricsEntry>): QueryProgress_MetricsEntry {
    return QueryProgress_MetricsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryProgress_MetricsEntry>): QueryProgress_MetricsEntry {
    const message = createBaseQueryProgress_MetricsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseMetadataPayload(): MetadataPayload {
  return { columns: [] };
}

export const MetadataPayload: MessageFns<MetadataPayload> = {
  encode(message: MetadataPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.columns) {
      ColumnMetadata.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MetadataPayload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetadataPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.columns.push(ColumnMetadata.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MetadataPayload {
    return {
      columns: globalThis.Array.isArray(object?.columns)
        ? object.columns.map((e: any) => ColumnMetadata.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MetadataPayload): unknown {
    const obj: any = {};
    if (message.columns?.length) {
      obj.columns = message.columns.map((e) => ColumnMetadata.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<MetadataPayload>): MetadataPayload {
    return MetadataPayload.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MetadataPayload>): MetadataPayload {
    const message = createBaseMetadataPayload();
    message.columns = object.columns?.map((e) => ColumnMetadata.fromPartial(e)) || [];
    return message;
  },
};

function createBaseStreamingQueryResponse(): StreamingQueryResponse {
  return {
    type: StreamResponseType.STREAM_RESPONSE_TYPE_UNSPECIFIED,
    queryId: "",
    metadata: undefined,
    data: undefined,
    progress: undefined,
    completion: undefined,
    error: undefined,
  };
}

export const StreamingQueryResponse: MessageFns<StreamingQueryResponse> = {
  encode(message: StreamingQueryResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== StreamResponseType.STREAM_RESPONSE_TYPE_UNSPECIFIED) {
      writer.uint32(8).int32(streamResponseTypeToNumber(message.type));
    }
    if (message.queryId !== "") {
      writer.uint32(18).string(message.queryId);
    }
    if (message.metadata !== undefined) {
      MetadataPayload.encode(message.metadata, writer.uint32(26).fork()).join();
    }
    if (message.data !== undefined) {
      QueryRow.encode(message.data, writer.uint32(34).fork()).join();
    }
    if (message.progress !== undefined) {
      QueryProgress.encode(message.progress, writer.uint32(42).fork()).join();
    }
    if (message.completion !== undefined) {
      QueryStats.encode(message.completion, writer.uint32(50).fork()).join();
    }
    if (message.error !== undefined) {
      writer.uint32(58).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamingQueryResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamingQueryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = streamResponseTypeFromJSON(reader.int32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.queryId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.metadata = MetadataPayload.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.data = QueryRow.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.progress = QueryProgress.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.completion = QueryStats.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamingQueryResponse {
    return {
      type: isSet(object.type)
        ? streamResponseTypeFromJSON(object.type)
        : StreamResponseType.STREAM_RESPONSE_TYPE_UNSPECIFIED,
      queryId: isSet(object.queryId) ? globalThis.String(object.queryId) : "",
      metadata: isSet(object.metadata) ? MetadataPayload.fromJSON(object.metadata) : undefined,
      data: isSet(object.data) ? QueryRow.fromJSON(object.data) : undefined,
      progress: isSet(object.progress) ? QueryProgress.fromJSON(object.progress) : undefined,
      completion: isSet(object.completion) ? QueryStats.fromJSON(object.completion) : undefined,
      error: isSet(object.error) ? globalThis.String(object.error) : undefined,
    };
  },

  toJSON(message: StreamingQueryResponse): unknown {
    const obj: any = {};
    if (message.type !== StreamResponseType.STREAM_RESPONSE_TYPE_UNSPECIFIED) {
      obj.type = streamResponseTypeToJSON(message.type);
    }
    if (message.queryId !== "") {
      obj.queryId = message.queryId;
    }
    if (message.metadata !== undefined) {
      obj.metadata = MetadataPayload.toJSON(message.metadata);
    }
    if (message.data !== undefined) {
      obj.data = QueryRow.toJSON(message.data);
    }
    if (message.progress !== undefined) {
      obj.progress = QueryProgress.toJSON(message.progress);
    }
    if (message.completion !== undefined) {
      obj.completion = QueryStats.toJSON(message.completion);
    }
    if (message.error !== undefined) {
      obj.error = message.error;
    }
    return obj;
  },

  create(base?: DeepPartial<StreamingQueryResponse>): StreamingQueryResponse {
    return StreamingQueryResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamingQueryResponse>): StreamingQueryResponse {
    const message = createBaseStreamingQueryResponse();
    message.type = object.type ?? StreamResponseType.STREAM_RESPONSE_TYPE_UNSPECIFIED;
    message.queryId = object.queryId ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? MetadataPayload.fromPartial(object.metadata)
      : undefined;
    message.data = (object.data !== undefined && object.data !== null) ? QueryRow.fromPartial(object.data) : undefined;
    message.progress = (object.progress !== undefined && object.progress !== null)
      ? QueryProgress.fromPartial(object.progress)
      : undefined;
    message.completion = (object.completion !== undefined && object.completion !== null)
      ? QueryStats.fromPartial(object.completion)
      : undefined;
    message.error = object.error ?? undefined;
    return message;
  },
};

function createBaseCancelQueryRequest(): CancelQueryRequest {
  return { queryId: "" };
}

export const CancelQueryRequest: MessageFns<CancelQueryRequest> = {
  encode(message: CancelQueryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.queryId !== "") {
      writer.uint32(10).string(message.queryId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelQueryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelQueryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.queryId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelQueryRequest {
    return { queryId: isSet(object.queryId) ? globalThis.String(object.queryId) : "" };
  },

  toJSON(message: CancelQueryRequest): unknown {
    const obj: any = {};
    if (message.queryId !== "") {
      obj.queryId = message.queryId;
    }
    return obj;
  },

  create(base?: DeepPartial<CancelQueryRequest>): CancelQueryRequest {
    return CancelQueryRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CancelQueryRequest>): CancelQueryRequest {
    const message = createBaseCancelQueryRequest();
    message.queryId = object.queryId ?? "";
    return message;
  },
};

function createBaseCancelQueryResponse(): CancelQueryResponse {
  return { success: false, message: "", wasRunning: false };
}

export const CancelQueryResponse: MessageFns<CancelQueryResponse> = {
  encode(message: CancelQueryResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.wasRunning !== false) {
      writer.uint32(24).bool(message.wasRunning);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelQueryResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelQueryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.wasRunning = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelQueryResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      wasRunning: isSet(object.wasRunning) ? globalThis.Boolean(object.wasRunning) : false,
    };
  },

  toJSON(message: CancelQueryResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.wasRunning !== false) {
      obj.wasRunning = message.wasRunning;
    }
    return obj;
  },

  create(base?: DeepPartial<CancelQueryResponse>): CancelQueryResponse {
    return CancelQueryResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CancelQueryResponse>): CancelQueryResponse {
    const message = createBaseCancelQueryResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.wasRunning = object.wasRunning ?? false;
    return message;
  },
};

function createBaseGetQueryStatusRequest(): GetQueryStatusRequest {
  return { queryId: "" };
}

export const GetQueryStatusRequest: MessageFns<GetQueryStatusRequest> = {
  encode(message: GetQueryStatusRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.queryId !== "") {
      writer.uint32(10).string(message.queryId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetQueryStatusRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetQueryStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.queryId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetQueryStatusRequest {
    return { queryId: isSet(object.queryId) ? globalThis.String(object.queryId) : "" };
  },

  toJSON(message: GetQueryStatusRequest): unknown {
    const obj: any = {};
    if (message.queryId !== "") {
      obj.queryId = message.queryId;
    }
    return obj;
  },

  create(base?: DeepPartial<GetQueryStatusRequest>): GetQueryStatusRequest {
    return GetQueryStatusRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetQueryStatusRequest>): GetQueryStatusRequest {
    const message = createBaseGetQueryStatusRequest();
    message.queryId = object.queryId ?? "";
    return message;
  },
};

function createBaseGetQueryStatusResponse(): GetQueryStatusResponse {
  return {
    success: false,
    message: "",
    status: QueryStatus.QUERY_STATUS_UNSPECIFIED,
    progress: undefined,
    stats: undefined,
  };
}

export const GetQueryStatusResponse: MessageFns<GetQueryStatusResponse> = {
  encode(message: GetQueryStatusResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.status !== QueryStatus.QUERY_STATUS_UNSPECIFIED) {
      writer.uint32(24).int32(queryStatusToNumber(message.status));
    }
    if (message.progress !== undefined) {
      QueryProgress.encode(message.progress, writer.uint32(34).fork()).join();
    }
    if (message.stats !== undefined) {
      QueryStats.encode(message.stats, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetQueryStatusResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetQueryStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.status = queryStatusFromJSON(reader.int32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.progress = QueryProgress.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.stats = QueryStats.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetQueryStatusResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      status: isSet(object.status) ? queryStatusFromJSON(object.status) : QueryStatus.QUERY_STATUS_UNSPECIFIED,
      progress: isSet(object.progress) ? QueryProgress.fromJSON(object.progress) : undefined,
      stats: isSet(object.stats) ? QueryStats.fromJSON(object.stats) : undefined,
    };
  },

  toJSON(message: GetQueryStatusResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.status !== QueryStatus.QUERY_STATUS_UNSPECIFIED) {
      obj.status = queryStatusToJSON(message.status);
    }
    if (message.progress !== undefined) {
      obj.progress = QueryProgress.toJSON(message.progress);
    }
    if (message.stats !== undefined) {
      obj.stats = QueryStats.toJSON(message.stats);
    }
    return obj;
  },

  create(base?: DeepPartial<GetQueryStatusResponse>): GetQueryStatusResponse {
    return GetQueryStatusResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetQueryStatusResponse>): GetQueryStatusResponse {
    const message = createBaseGetQueryStatusResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.status = object.status ?? QueryStatus.QUERY_STATUS_UNSPECIFIED;
    message.progress = (object.progress !== undefined && object.progress !== null)
      ? QueryProgress.fromPartial(object.progress)
      : undefined;
    message.stats = (object.stats !== undefined && object.stats !== null)
      ? QueryStats.fromPartial(object.stats)
      : undefined;
    return message;
  },
};

function createBaseListActiveQueriesRequest(): ListActiveQueriesRequest {
  return { connectionId: "", userId: "" };
}

export const ListActiveQueriesRequest: MessageFns<ListActiveQueriesRequest> = {
  encode(message: ListActiveQueriesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.connectionId !== "") {
      writer.uint32(10).string(message.connectionId);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListActiveQueriesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListActiveQueriesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.connectionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListActiveQueriesRequest {
    return {
      connectionId: isSet(object.connectionId) ? globalThis.String(object.connectionId) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
    };
  },

  toJSON(message: ListActiveQueriesRequest): unknown {
    const obj: any = {};
    if (message.connectionId !== "") {
      obj.connectionId = message.connectionId;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    return obj;
  },

  create(base?: DeepPartial<ListActiveQueriesRequest>): ListActiveQueriesRequest {
    return ListActiveQueriesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListActiveQueriesRequest>): ListActiveQueriesRequest {
    const message = createBaseListActiveQueriesRequest();
    message.connectionId = object.connectionId ?? "";
    message.userId = object.userId ?? "";
    return message;
  },
};

function createBaseActiveQuery(): ActiveQuery {
  return {
    queryId: "",
    connectionId: "",
    userId: "",
    sql: "",
    status: QueryStatus.QUERY_STATUS_UNSPECIFIED,
    startedAt: undefined,
    progress: undefined,
  };
}

export const ActiveQuery: MessageFns<ActiveQuery> = {
  encode(message: ActiveQuery, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.queryId !== "") {
      writer.uint32(10).string(message.queryId);
    }
    if (message.connectionId !== "") {
      writer.uint32(18).string(message.connectionId);
    }
    if (message.userId !== "") {
      writer.uint32(26).string(message.userId);
    }
    if (message.sql !== "") {
      writer.uint32(34).string(message.sql);
    }
    if (message.status !== QueryStatus.QUERY_STATUS_UNSPECIFIED) {
      writer.uint32(40).int32(queryStatusToNumber(message.status));
    }
    if (message.startedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.startedAt), writer.uint32(50).fork()).join();
    }
    if (message.progress !== undefined) {
      QueryProgress.encode(message.progress, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ActiveQuery {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActiveQuery();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.queryId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.connectionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sql = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.status = queryStatusFromJSON(reader.int32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.startedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.progress = QueryProgress.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ActiveQuery {
    return {
      queryId: isSet(object.queryId) ? globalThis.String(object.queryId) : "",
      connectionId: isSet(object.connectionId) ? globalThis.String(object.connectionId) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      sql: isSet(object.sql) ? globalThis.String(object.sql) : "",
      status: isSet(object.status) ? queryStatusFromJSON(object.status) : QueryStatus.QUERY_STATUS_UNSPECIFIED,
      startedAt: isSet(object.startedAt) ? fromJsonTimestamp(object.startedAt) : undefined,
      progress: isSet(object.progress) ? QueryProgress.fromJSON(object.progress) : undefined,
    };
  },

  toJSON(message: ActiveQuery): unknown {
    const obj: any = {};
    if (message.queryId !== "") {
      obj.queryId = message.queryId;
    }
    if (message.connectionId !== "") {
      obj.connectionId = message.connectionId;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.sql !== "") {
      obj.sql = message.sql;
    }
    if (message.status !== QueryStatus.QUERY_STATUS_UNSPECIFIED) {
      obj.status = queryStatusToJSON(message.status);
    }
    if (message.startedAt !== undefined) {
      obj.startedAt = message.startedAt.toISOString();
    }
    if (message.progress !== undefined) {
      obj.progress = QueryProgress.toJSON(message.progress);
    }
    return obj;
  },

  create(base?: DeepPartial<ActiveQuery>): ActiveQuery {
    return ActiveQuery.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ActiveQuery>): ActiveQuery {
    const message = createBaseActiveQuery();
    message.queryId = object.queryId ?? "";
    message.connectionId = object.connectionId ?? "";
    message.userId = object.userId ?? "";
    message.sql = object.sql ?? "";
    message.status = object.status ?? QueryStatus.QUERY_STATUS_UNSPECIFIED;
    message.startedAt = object.startedAt ?? undefined;
    message.progress = (object.progress !== undefined && object.progress !== null)
      ? QueryProgress.fromPartial(object.progress)
      : undefined;
    return message;
  },
};

function createBaseListActiveQueriesResponse(): ListActiveQueriesResponse {
  return { success: false, message: "", queries: [] };
}

export const ListActiveQueriesResponse: MessageFns<ListActiveQueriesResponse> = {
  encode(message: ListActiveQueriesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    for (const v of message.queries) {
      ActiveQuery.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListActiveQueriesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListActiveQueriesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.queries.push(ActiveQuery.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListActiveQueriesResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      queries: globalThis.Array.isArray(object?.queries) ? object.queries.map((e: any) => ActiveQuery.fromJSON(e)) : [],
    };
  },

  toJSON(message: ListActiveQueriesResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.queries?.length) {
      obj.queries = message.queries.map((e) => ActiveQuery.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ListActiveQueriesResponse>): ListActiveQueriesResponse {
    return ListActiveQueriesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListActiveQueriesResponse>): ListActiveQueriesResponse {
    const message = createBaseListActiveQueriesResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.queries = object.queries?.map((e) => ActiveQuery.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBatchEditOperation(): BatchEditOperation {
  return {
    id: "",
    type: BatchEditOperation_OperationType.OPERATION_TYPE_UNSPECIFIED,
    tableName: "",
    schemaName: "",
    values: {},
    whereConditions: {},
    version: Long.ZERO,
  };
}

export const BatchEditOperation: MessageFns<BatchEditOperation> = {
  encode(message: BatchEditOperation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.type !== BatchEditOperation_OperationType.OPERATION_TYPE_UNSPECIFIED) {
      writer.uint32(16).int32(batchEditOperation_OperationTypeToNumber(message.type));
    }
    if (message.tableName !== "") {
      writer.uint32(26).string(message.tableName);
    }
    if (message.schemaName !== "") {
      writer.uint32(34).string(message.schemaName);
    }
    Object.entries(message.values).forEach(([key, value]) => {
      BatchEditOperation_ValuesEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    Object.entries(message.whereConditions).forEach(([key, value]) => {
      BatchEditOperation_WhereConditionsEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).join();
    });
    if (!message.version.equals(Long.ZERO)) {
      writer.uint32(56).int64(message.version.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchEditOperation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchEditOperation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.type = batchEditOperation_OperationTypeFromJSON(reader.int32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tableName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.schemaName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          const entry5 = BatchEditOperation_ValuesEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.values[entry5.key] = entry5.value;
          }
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          const entry6 = BatchEditOperation_WhereConditionsEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.whereConditions[entry6.key] = entry6.value;
          }
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.version = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchEditOperation {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      type: isSet(object.type)
        ? batchEditOperation_OperationTypeFromJSON(object.type)
        : BatchEditOperation_OperationType.OPERATION_TYPE_UNSPECIFIED,
      tableName: isSet(object.tableName) ? globalThis.String(object.tableName) : "",
      schemaName: isSet(object.schemaName) ? globalThis.String(object.schemaName) : "",
      values: isObject(object.values)
        ? Object.entries(object.values).reduce<{ [key: string]: Any }>((acc, [key, value]) => {
          acc[key] = Any.fromJSON(value);
          return acc;
        }, {})
        : {},
      whereConditions: isObject(object.whereConditions)
        ? Object.entries(object.whereConditions).reduce<{ [key: string]: Any }>((acc, [key, value]) => {
          acc[key] = Any.fromJSON(value);
          return acc;
        }, {})
        : {},
      version: isSet(object.version) ? Long.fromValue(object.version) : Long.ZERO,
    };
  },

  toJSON(message: BatchEditOperation): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.type !== BatchEditOperation_OperationType.OPERATION_TYPE_UNSPECIFIED) {
      obj.type = batchEditOperation_OperationTypeToJSON(message.type);
    }
    if (message.tableName !== "") {
      obj.tableName = message.tableName;
    }
    if (message.schemaName !== "") {
      obj.schemaName = message.schemaName;
    }
    if (message.values) {
      const entries = Object.entries(message.values);
      if (entries.length > 0) {
        obj.values = {};
        entries.forEach(([k, v]) => {
          obj.values[k] = Any.toJSON(v);
        });
      }
    }
    if (message.whereConditions) {
      const entries = Object.entries(message.whereConditions);
      if (entries.length > 0) {
        obj.whereConditions = {};
        entries.forEach(([k, v]) => {
          obj.whereConditions[k] = Any.toJSON(v);
        });
      }
    }
    if (!message.version.equals(Long.ZERO)) {
      obj.version = (message.version || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<BatchEditOperation>): BatchEditOperation {
    return BatchEditOperation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchEditOperation>): BatchEditOperation {
    const message = createBaseBatchEditOperation();
    message.id = object.id ?? "";
    message.type = object.type ?? BatchEditOperation_OperationType.OPERATION_TYPE_UNSPECIFIED;
    message.tableName = object.tableName ?? "";
    message.schemaName = object.schemaName ?? "";
    message.values = Object.entries(object.values ?? {}).reduce<{ [key: string]: Any }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Any.fromPartial(value);
      }
      return acc;
    }, {});
    message.whereConditions = Object.entries(object.whereConditions ?? {}).reduce<{ [key: string]: Any }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = Any.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.version = (object.version !== undefined && object.version !== null)
      ? Long.fromValue(object.version)
      : Long.ZERO;
    return message;
  },
};

function createBaseBatchEditOperation_ValuesEntry(): BatchEditOperation_ValuesEntry {
  return { key: "", value: undefined };
}

export const BatchEditOperation_ValuesEntry: MessageFns<BatchEditOperation_ValuesEntry> = {
  encode(message: BatchEditOperation_ValuesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Any.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchEditOperation_ValuesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchEditOperation_ValuesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Any.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchEditOperation_ValuesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Any.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: BatchEditOperation_ValuesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Any.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<BatchEditOperation_ValuesEntry>): BatchEditOperation_ValuesEntry {
    return BatchEditOperation_ValuesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchEditOperation_ValuesEntry>): BatchEditOperation_ValuesEntry {
    const message = createBaseBatchEditOperation_ValuesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Any.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseBatchEditOperation_WhereConditionsEntry(): BatchEditOperation_WhereConditionsEntry {
  return { key: "", value: undefined };
}

export const BatchEditOperation_WhereConditionsEntry: MessageFns<BatchEditOperation_WhereConditionsEntry> = {
  encode(message: BatchEditOperation_WhereConditionsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Any.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchEditOperation_WhereConditionsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchEditOperation_WhereConditionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Any.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchEditOperation_WhereConditionsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Any.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: BatchEditOperation_WhereConditionsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Any.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<BatchEditOperation_WhereConditionsEntry>): BatchEditOperation_WhereConditionsEntry {
    return BatchEditOperation_WhereConditionsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchEditOperation_WhereConditionsEntry>): BatchEditOperation_WhereConditionsEntry {
    const message = createBaseBatchEditOperation_WhereConditionsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Any.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseExecuteBatchEditRequest(): ExecuteBatchEditRequest {
  return { connectionId: "", operations: [], useTransaction: false, options: undefined };
}

export const ExecuteBatchEditRequest: MessageFns<ExecuteBatchEditRequest> = {
  encode(message: ExecuteBatchEditRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.connectionId !== "") {
      writer.uint32(10).string(message.connectionId);
    }
    for (const v of message.operations) {
      BatchEditOperation.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.useTransaction !== false) {
      writer.uint32(24).bool(message.useTransaction);
    }
    if (message.options !== undefined) {
      QueryOptions.encode(message.options, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecuteBatchEditRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecuteBatchEditRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.connectionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.operations.push(BatchEditOperation.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.useTransaction = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.options = QueryOptions.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecuteBatchEditRequest {
    return {
      connectionId: isSet(object.connectionId) ? globalThis.String(object.connectionId) : "",
      operations: globalThis.Array.isArray(object?.operations)
        ? object.operations.map((e: any) => BatchEditOperation.fromJSON(e))
        : [],
      useTransaction: isSet(object.useTransaction) ? globalThis.Boolean(object.useTransaction) : false,
      options: isSet(object.options) ? QueryOptions.fromJSON(object.options) : undefined,
    };
  },

  toJSON(message: ExecuteBatchEditRequest): unknown {
    const obj: any = {};
    if (message.connectionId !== "") {
      obj.connectionId = message.connectionId;
    }
    if (message.operations?.length) {
      obj.operations = message.operations.map((e) => BatchEditOperation.toJSON(e));
    }
    if (message.useTransaction !== false) {
      obj.useTransaction = message.useTransaction;
    }
    if (message.options !== undefined) {
      obj.options = QueryOptions.toJSON(message.options);
    }
    return obj;
  },

  create(base?: DeepPartial<ExecuteBatchEditRequest>): ExecuteBatchEditRequest {
    return ExecuteBatchEditRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExecuteBatchEditRequest>): ExecuteBatchEditRequest {
    const message = createBaseExecuteBatchEditRequest();
    message.connectionId = object.connectionId ?? "";
    message.operations = object.operations?.map((e) => BatchEditOperation.fromPartial(e)) || [];
    message.useTransaction = object.useTransaction ?? false;
    message.options = (object.options !== undefined && object.options !== null)
      ? QueryOptions.fromPartial(object.options)
      : undefined;
    return message;
  },
};

function createBaseBatchEditResult(): BatchEditResult {
  return { operationId: "", success: false, message: "", rowsAffected: Long.ZERO, returnedValues: {} };
}

export const BatchEditResult: MessageFns<BatchEditResult> = {
  encode(message: BatchEditResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.operationId !== "") {
      writer.uint32(10).string(message.operationId);
    }
    if (message.success !== false) {
      writer.uint32(16).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    if (!message.rowsAffected.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.rowsAffected.toString());
    }
    Object.entries(message.returnedValues).forEach(([key, value]) => {
      BatchEditResult_ReturnedValuesEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchEditResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchEditResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.operationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.rowsAffected = Long.fromString(reader.int64().toString());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          const entry5 = BatchEditResult_ReturnedValuesEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.returnedValues[entry5.key] = entry5.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchEditResult {
    return {
      operationId: isSet(object.operationId) ? globalThis.String(object.operationId) : "",
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      rowsAffected: isSet(object.rowsAffected) ? Long.fromValue(object.rowsAffected) : Long.ZERO,
      returnedValues: isObject(object.returnedValues)
        ? Object.entries(object.returnedValues).reduce<{ [key: string]: Any }>((acc, [key, value]) => {
          acc[key] = Any.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: BatchEditResult): unknown {
    const obj: any = {};
    if (message.operationId !== "") {
      obj.operationId = message.operationId;
    }
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (!message.rowsAffected.equals(Long.ZERO)) {
      obj.rowsAffected = (message.rowsAffected || Long.ZERO).toString();
    }
    if (message.returnedValues) {
      const entries = Object.entries(message.returnedValues);
      if (entries.length > 0) {
        obj.returnedValues = {};
        entries.forEach(([k, v]) => {
          obj.returnedValues[k] = Any.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<BatchEditResult>): BatchEditResult {
    return BatchEditResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchEditResult>): BatchEditResult {
    const message = createBaseBatchEditResult();
    message.operationId = object.operationId ?? "";
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.rowsAffected = (object.rowsAffected !== undefined && object.rowsAffected !== null)
      ? Long.fromValue(object.rowsAffected)
      : Long.ZERO;
    message.returnedValues = Object.entries(object.returnedValues ?? {}).reduce<{ [key: string]: Any }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = Any.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseBatchEditResult_ReturnedValuesEntry(): BatchEditResult_ReturnedValuesEntry {
  return { key: "", value: undefined };
}

export const BatchEditResult_ReturnedValuesEntry: MessageFns<BatchEditResult_ReturnedValuesEntry> = {
  encode(message: BatchEditResult_ReturnedValuesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Any.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchEditResult_ReturnedValuesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchEditResult_ReturnedValuesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Any.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchEditResult_ReturnedValuesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Any.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: BatchEditResult_ReturnedValuesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Any.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<BatchEditResult_ReturnedValuesEntry>): BatchEditResult_ReturnedValuesEntry {
    return BatchEditResult_ReturnedValuesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchEditResult_ReturnedValuesEntry>): BatchEditResult_ReturnedValuesEntry {
    const message = createBaseBatchEditResult_ReturnedValuesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Any.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseExecuteBatchEditResponse(): ExecuteBatchEditResponse {
  return { success: false, message: "", results: [], stats: undefined, transactionId: "" };
}

export const ExecuteBatchEditResponse: MessageFns<ExecuteBatchEditResponse> = {
  encode(message: ExecuteBatchEditResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    for (const v of message.results) {
      BatchEditResult.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.stats !== undefined) {
      QueryStats.encode(message.stats, writer.uint32(34).fork()).join();
    }
    if (message.transactionId !== "") {
      writer.uint32(42).string(message.transactionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecuteBatchEditResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecuteBatchEditResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.results.push(BatchEditResult.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.stats = QueryStats.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.transactionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecuteBatchEditResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      results: globalThis.Array.isArray(object?.results)
        ? object.results.map((e: any) => BatchEditResult.fromJSON(e))
        : [],
      stats: isSet(object.stats) ? QueryStats.fromJSON(object.stats) : undefined,
      transactionId: isSet(object.transactionId) ? globalThis.String(object.transactionId) : "",
    };
  },

  toJSON(message: ExecuteBatchEditResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.results?.length) {
      obj.results = message.results.map((e) => BatchEditResult.toJSON(e));
    }
    if (message.stats !== undefined) {
      obj.stats = QueryStats.toJSON(message.stats);
    }
    if (message.transactionId !== "") {
      obj.transactionId = message.transactionId;
    }
    return obj;
  },

  create(base?: DeepPartial<ExecuteBatchEditResponse>): ExecuteBatchEditResponse {
    return ExecuteBatchEditResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExecuteBatchEditResponse>): ExecuteBatchEditResponse {
    const message = createBaseExecuteBatchEditResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.results = object.results?.map((e) => BatchEditResult.fromPartial(e)) || [];
    message.stats = (object.stats !== undefined && object.stats !== null)
      ? QueryStats.fromPartial(object.stats)
      : undefined;
    message.transactionId = object.transactionId ?? "";
    return message;
  },
};

function createBaseGetQueryHistoryRequest(): GetQueryHistoryRequest {
  return { connectionId: "", userId: "", fromTime: undefined, toTime: undefined, limit: 0, cursor: "" };
}

export const GetQueryHistoryRequest: MessageFns<GetQueryHistoryRequest> = {
  encode(message: GetQueryHistoryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.connectionId !== "") {
      writer.uint32(10).string(message.connectionId);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.fromTime !== undefined) {
      Timestamp.encode(toTimestamp(message.fromTime), writer.uint32(26).fork()).join();
    }
    if (message.toTime !== undefined) {
      Timestamp.encode(toTimestamp(message.toTime), writer.uint32(34).fork()).join();
    }
    if (message.limit !== 0) {
      writer.uint32(40).int32(message.limit);
    }
    if (message.cursor !== "") {
      writer.uint32(50).string(message.cursor);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetQueryHistoryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetQueryHistoryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.connectionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.fromTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.toTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.cursor = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetQueryHistoryRequest {
    return {
      connectionId: isSet(object.connectionId) ? globalThis.String(object.connectionId) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      fromTime: isSet(object.fromTime) ? fromJsonTimestamp(object.fromTime) : undefined,
      toTime: isSet(object.toTime) ? fromJsonTimestamp(object.toTime) : undefined,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      cursor: isSet(object.cursor) ? globalThis.String(object.cursor) : "",
    };
  },

  toJSON(message: GetQueryHistoryRequest): unknown {
    const obj: any = {};
    if (message.connectionId !== "") {
      obj.connectionId = message.connectionId;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.fromTime !== undefined) {
      obj.fromTime = message.fromTime.toISOString();
    }
    if (message.toTime !== undefined) {
      obj.toTime = message.toTime.toISOString();
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.cursor !== "") {
      obj.cursor = message.cursor;
    }
    return obj;
  },

  create(base?: DeepPartial<GetQueryHistoryRequest>): GetQueryHistoryRequest {
    return GetQueryHistoryRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetQueryHistoryRequest>): GetQueryHistoryRequest {
    const message = createBaseGetQueryHistoryRequest();
    message.connectionId = object.connectionId ?? "";
    message.userId = object.userId ?? "";
    message.fromTime = object.fromTime ?? undefined;
    message.toTime = object.toTime ?? undefined;
    message.limit = object.limit ?? 0;
    message.cursor = object.cursor ?? "";
    return message;
  },
};

function createBaseQueryHistoryEntry(): QueryHistoryEntry {
  return {
    queryId: "",
    connectionId: "",
    userId: "",
    sql: "",
    status: QueryStatus.QUERY_STATUS_UNSPECIFIED,
    startedAt: undefined,
    completedAt: undefined,
    stats: undefined,
    errorMessage: "",
  };
}

export const QueryHistoryEntry: MessageFns<QueryHistoryEntry> = {
  encode(message: QueryHistoryEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.queryId !== "") {
      writer.uint32(10).string(message.queryId);
    }
    if (message.connectionId !== "") {
      writer.uint32(18).string(message.connectionId);
    }
    if (message.userId !== "") {
      writer.uint32(26).string(message.userId);
    }
    if (message.sql !== "") {
      writer.uint32(34).string(message.sql);
    }
    if (message.status !== QueryStatus.QUERY_STATUS_UNSPECIFIED) {
      writer.uint32(40).int32(queryStatusToNumber(message.status));
    }
    if (message.startedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.startedAt), writer.uint32(50).fork()).join();
    }
    if (message.completedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.completedAt), writer.uint32(58).fork()).join();
    }
    if (message.stats !== undefined) {
      QueryStats.encode(message.stats, writer.uint32(66).fork()).join();
    }
    if (message.errorMessage !== "") {
      writer.uint32(74).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryHistoryEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryHistoryEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.queryId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.connectionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sql = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.status = queryStatusFromJSON(reader.int32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.startedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.completedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.stats = QueryStats.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryHistoryEntry {
    return {
      queryId: isSet(object.queryId) ? globalThis.String(object.queryId) : "",
      connectionId: isSet(object.connectionId) ? globalThis.String(object.connectionId) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      sql: isSet(object.sql) ? globalThis.String(object.sql) : "",
      status: isSet(object.status) ? queryStatusFromJSON(object.status) : QueryStatus.QUERY_STATUS_UNSPECIFIED,
      startedAt: isSet(object.startedAt) ? fromJsonTimestamp(object.startedAt) : undefined,
      completedAt: isSet(object.completedAt) ? fromJsonTimestamp(object.completedAt) : undefined,
      stats: isSet(object.stats) ? QueryStats.fromJSON(object.stats) : undefined,
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
    };
  },

  toJSON(message: QueryHistoryEntry): unknown {
    const obj: any = {};
    if (message.queryId !== "") {
      obj.queryId = message.queryId;
    }
    if (message.connectionId !== "") {
      obj.connectionId = message.connectionId;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.sql !== "") {
      obj.sql = message.sql;
    }
    if (message.status !== QueryStatus.QUERY_STATUS_UNSPECIFIED) {
      obj.status = queryStatusToJSON(message.status);
    }
    if (message.startedAt !== undefined) {
      obj.startedAt = message.startedAt.toISOString();
    }
    if (message.completedAt !== undefined) {
      obj.completedAt = message.completedAt.toISOString();
    }
    if (message.stats !== undefined) {
      obj.stats = QueryStats.toJSON(message.stats);
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    return obj;
  },

  create(base?: DeepPartial<QueryHistoryEntry>): QueryHistoryEntry {
    return QueryHistoryEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryHistoryEntry>): QueryHistoryEntry {
    const message = createBaseQueryHistoryEntry();
    message.queryId = object.queryId ?? "";
    message.connectionId = object.connectionId ?? "";
    message.userId = object.userId ?? "";
    message.sql = object.sql ?? "";
    message.status = object.status ?? QueryStatus.QUERY_STATUS_UNSPECIFIED;
    message.startedAt = object.startedAt ?? undefined;
    message.completedAt = object.completedAt ?? undefined;
    message.stats = (object.stats !== undefined && object.stats !== null)
      ? QueryStats.fromPartial(object.stats)
      : undefined;
    message.errorMessage = object.errorMessage ?? "";
    return message;
  },
};

function createBaseGetQueryHistoryResponse(): GetQueryHistoryResponse {
  return { success: false, message: "", entries: [], nextCursor: "", hasMore: false };
}

export const GetQueryHistoryResponse: MessageFns<GetQueryHistoryResponse> = {
  encode(message: GetQueryHistoryResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    for (const v of message.entries) {
      QueryHistoryEntry.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.nextCursor !== "") {
      writer.uint32(34).string(message.nextCursor);
    }
    if (message.hasMore !== false) {
      writer.uint32(40).bool(message.hasMore);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetQueryHistoryResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetQueryHistoryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.entries.push(QueryHistoryEntry.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.nextCursor = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.hasMore = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetQueryHistoryResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      entries: globalThis.Array.isArray(object?.entries)
        ? object.entries.map((e: any) => QueryHistoryEntry.fromJSON(e))
        : [],
      nextCursor: isSet(object.nextCursor) ? globalThis.String(object.nextCursor) : "",
      hasMore: isSet(object.hasMore) ? globalThis.Boolean(object.hasMore) : false,
    };
  },

  toJSON(message: GetQueryHistoryResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.entries?.length) {
      obj.entries = message.entries.map((e) => QueryHistoryEntry.toJSON(e));
    }
    if (message.nextCursor !== "") {
      obj.nextCursor = message.nextCursor;
    }
    if (message.hasMore !== false) {
      obj.hasMore = message.hasMore;
    }
    return obj;
  },

  create(base?: DeepPartial<GetQueryHistoryResponse>): GetQueryHistoryResponse {
    return GetQueryHistoryResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetQueryHistoryResponse>): GetQueryHistoryResponse {
    const message = createBaseGetQueryHistoryResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.entries = object.entries?.map((e) => QueryHistoryEntry.fromPartial(e)) || [];
    message.nextCursor = object.nextCursor ?? "";
    message.hasMore = object.hasMore ?? false;
    return message;
  },
};

function createBaseExplainQueryRequest(): ExplainQueryRequest {
  return { connectionId: "", sql: "", parameters: {}, analyze: false, format: "" };
}

export const ExplainQueryRequest: MessageFns<ExplainQueryRequest> = {
  encode(message: ExplainQueryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.connectionId !== "") {
      writer.uint32(10).string(message.connectionId);
    }
    if (message.sql !== "") {
      writer.uint32(18).string(message.sql);
    }
    Object.entries(message.parameters).forEach(([key, value]) => {
      ExplainQueryRequest_ParametersEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    if (message.analyze !== false) {
      writer.uint32(32).bool(message.analyze);
    }
    if (message.format !== "") {
      writer.uint32(42).string(message.format);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExplainQueryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExplainQueryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.connectionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sql = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = ExplainQueryRequest_ParametersEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.parameters[entry3.key] = entry3.value;
          }
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.analyze = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.format = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExplainQueryRequest {
    return {
      connectionId: isSet(object.connectionId) ? globalThis.String(object.connectionId) : "",
      sql: isSet(object.sql) ? globalThis.String(object.sql) : "",
      parameters: isObject(object.parameters)
        ? Object.entries(object.parameters).reduce<{ [key: string]: Any }>((acc, [key, value]) => {
          acc[key] = Any.fromJSON(value);
          return acc;
        }, {})
        : {},
      analyze: isSet(object.analyze) ? globalThis.Boolean(object.analyze) : false,
      format: isSet(object.format) ? globalThis.String(object.format) : "",
    };
  },

  toJSON(message: ExplainQueryRequest): unknown {
    const obj: any = {};
    if (message.connectionId !== "") {
      obj.connectionId = message.connectionId;
    }
    if (message.sql !== "") {
      obj.sql = message.sql;
    }
    if (message.parameters) {
      const entries = Object.entries(message.parameters);
      if (entries.length > 0) {
        obj.parameters = {};
        entries.forEach(([k, v]) => {
          obj.parameters[k] = Any.toJSON(v);
        });
      }
    }
    if (message.analyze !== false) {
      obj.analyze = message.analyze;
    }
    if (message.format !== "") {
      obj.format = message.format;
    }
    return obj;
  },

  create(base?: DeepPartial<ExplainQueryRequest>): ExplainQueryRequest {
    return ExplainQueryRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExplainQueryRequest>): ExplainQueryRequest {
    const message = createBaseExplainQueryRequest();
    message.connectionId = object.connectionId ?? "";
    message.sql = object.sql ?? "";
    message.parameters = Object.entries(object.parameters ?? {}).reduce<{ [key: string]: Any }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Any.fromPartial(value);
      }
      return acc;
    }, {});
    message.analyze = object.analyze ?? false;
    message.format = object.format ?? "";
    return message;
  },
};

function createBaseExplainQueryRequest_ParametersEntry(): ExplainQueryRequest_ParametersEntry {
  return { key: "", value: undefined };
}

export const ExplainQueryRequest_ParametersEntry: MessageFns<ExplainQueryRequest_ParametersEntry> = {
  encode(message: ExplainQueryRequest_ParametersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Any.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExplainQueryRequest_ParametersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExplainQueryRequest_ParametersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Any.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExplainQueryRequest_ParametersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Any.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: ExplainQueryRequest_ParametersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Any.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<ExplainQueryRequest_ParametersEntry>): ExplainQueryRequest_ParametersEntry {
    return ExplainQueryRequest_ParametersEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExplainQueryRequest_ParametersEntry>): ExplainQueryRequest_ParametersEntry {
    const message = createBaseExplainQueryRequest_ParametersEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Any.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseExecutionPlan(): ExecutionPlan {
  return { format: "", plan: "", estimatedStats: undefined, actualStats: undefined, warnings: [] };
}

export const ExecutionPlan: MessageFns<ExecutionPlan> = {
  encode(message: ExecutionPlan, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.format !== "") {
      writer.uint32(10).string(message.format);
    }
    if (message.plan !== "") {
      writer.uint32(18).string(message.plan);
    }
    if (message.estimatedStats !== undefined) {
      QueryStats.encode(message.estimatedStats, writer.uint32(26).fork()).join();
    }
    if (message.actualStats !== undefined) {
      QueryStats.encode(message.actualStats, writer.uint32(34).fork()).join();
    }
    for (const v of message.warnings) {
      writer.uint32(42).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecutionPlan {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecutionPlan();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.format = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.plan = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.estimatedStats = QueryStats.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.actualStats = QueryStats.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.warnings.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecutionPlan {
    return {
      format: isSet(object.format) ? globalThis.String(object.format) : "",
      plan: isSet(object.plan) ? globalThis.String(object.plan) : "",
      estimatedStats: isSet(object.estimatedStats) ? QueryStats.fromJSON(object.estimatedStats) : undefined,
      actualStats: isSet(object.actualStats) ? QueryStats.fromJSON(object.actualStats) : undefined,
      warnings: globalThis.Array.isArray(object?.warnings) ? object.warnings.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: ExecutionPlan): unknown {
    const obj: any = {};
    if (message.format !== "") {
      obj.format = message.format;
    }
    if (message.plan !== "") {
      obj.plan = message.plan;
    }
    if (message.estimatedStats !== undefined) {
      obj.estimatedStats = QueryStats.toJSON(message.estimatedStats);
    }
    if (message.actualStats !== undefined) {
      obj.actualStats = QueryStats.toJSON(message.actualStats);
    }
    if (message.warnings?.length) {
      obj.warnings = message.warnings;
    }
    return obj;
  },

  create(base?: DeepPartial<ExecutionPlan>): ExecutionPlan {
    return ExecutionPlan.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExecutionPlan>): ExecutionPlan {
    const message = createBaseExecutionPlan();
    message.format = object.format ?? "";
    message.plan = object.plan ?? "";
    message.estimatedStats = (object.estimatedStats !== undefined && object.estimatedStats !== null)
      ? QueryStats.fromPartial(object.estimatedStats)
      : undefined;
    message.actualStats = (object.actualStats !== undefined && object.actualStats !== null)
      ? QueryStats.fromPartial(object.actualStats)
      : undefined;
    message.warnings = object.warnings?.map((e) => e) || [];
    return message;
  },
};

function createBaseExplainQueryResponse(): ExplainQueryResponse {
  return { success: false, message: "", plan: undefined };
}

export const ExplainQueryResponse: MessageFns<ExplainQueryResponse> = {
  encode(message: ExplainQueryResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.plan !== undefined) {
      ExecutionPlan.encode(message.plan, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExplainQueryResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExplainQueryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.plan = ExecutionPlan.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExplainQueryResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      plan: isSet(object.plan) ? ExecutionPlan.fromJSON(object.plan) : undefined,
    };
  },

  toJSON(message: ExplainQueryResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.plan !== undefined) {
      obj.plan = ExecutionPlan.toJSON(message.plan);
    }
    return obj;
  },

  create(base?: DeepPartial<ExplainQueryResponse>): ExplainQueryResponse {
    return ExplainQueryResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExplainQueryResponse>): ExplainQueryResponse {
    const message = createBaseExplainQueryResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.plan = (object.plan !== undefined && object.plan !== null)
      ? ExecutionPlan.fromPartial(object.plan)
      : undefined;
    return message;
  },
};

/** Query service definition */
export type QueryServiceDefinition = typeof QueryServiceDefinition;
export const QueryServiceDefinition = {
  name: "QueryService",
  fullName: "sqlstudio.query.QueryService",
  methods: {
    executeQuery: {
      name: "ExecuteQuery",
      requestType: ExecuteQueryRequest,
      requestStream: false,
      responseType: ExecuteQueryResponse,
      responseStream: false,
      options: {},
    },
    executeStreamingQuery: {
      name: "ExecuteStreamingQuery",
      requestType: ExecuteStreamingQueryRequest,
      requestStream: false,
      responseType: StreamingQueryResponse,
      responseStream: true,
      options: {},
    },
    cancelQuery: {
      name: "CancelQuery",
      requestType: CancelQueryRequest,
      requestStream: false,
      responseType: CancelQueryResponse,
      responseStream: false,
      options: {},
    },
    getQueryStatus: {
      name: "GetQueryStatus",
      requestType: GetQueryStatusRequest,
      requestStream: false,
      responseType: GetQueryStatusResponse,
      responseStream: false,
      options: {},
    },
    listActiveQueries: {
      name: "ListActiveQueries",
      requestType: ListActiveQueriesRequest,
      requestStream: false,
      responseType: ListActiveQueriesResponse,
      responseStream: false,
      options: {},
    },
    executeBatchEdit: {
      name: "ExecuteBatchEdit",
      requestType: ExecuteBatchEditRequest,
      requestStream: false,
      responseType: ExecuteBatchEditResponse,
      responseStream: false,
      options: {},
    },
    getQueryHistory: {
      name: "GetQueryHistory",
      requestType: GetQueryHistoryRequest,
      requestStream: false,
      responseType: GetQueryHistoryResponse,
      responseStream: false,
      options: {},
    },
    explainQuery: {
      name: "ExplainQuery",
      requestType: ExplainQueryRequest,
      requestStream: false,
      responseType: ExplainQueryResponse,
      responseStream: false,
      options: {},
    },
  },
} as const;

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
