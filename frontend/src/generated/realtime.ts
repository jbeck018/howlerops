// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v5.29.3
// source: realtime.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Any } from "./google/protobuf/any";
import { Timestamp } from "./google/protobuf/timestamp";

export const protobufPackage = "sqlstudio.realtime";

/** Event types */
export enum EventType {
  EVENT_TYPE_UNSPECIFIED = "EVENT_TYPE_UNSPECIFIED",
  EVENT_TYPE_QUERY_PROGRESS = "EVENT_TYPE_QUERY_PROGRESS",
  EVENT_TYPE_QUERY_RESULT = "EVENT_TYPE_QUERY_RESULT",
  EVENT_TYPE_QUERY_ERROR = "EVENT_TYPE_QUERY_ERROR",
  EVENT_TYPE_CONNECTION_STATUS = "EVENT_TYPE_CONNECTION_STATUS",
  EVENT_TYPE_TABLE_CHANGED = "EVENT_TYPE_TABLE_CHANGED",
  EVENT_TYPE_SCHEMA_CHANGED = "EVENT_TYPE_SCHEMA_CHANGED",
  EVENT_TYPE_USER_ACTION = "EVENT_TYPE_USER_ACTION",
  EVENT_TYPE_SYSTEM_ALERT = "EVENT_TYPE_SYSTEM_ALERT",
  EVENT_TYPE_HEARTBEAT = "EVENT_TYPE_HEARTBEAT",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function eventTypeFromJSON(object: any): EventType {
  switch (object) {
    case 0:
    case "EVENT_TYPE_UNSPECIFIED":
      return EventType.EVENT_TYPE_UNSPECIFIED;
    case 1:
    case "EVENT_TYPE_QUERY_PROGRESS":
      return EventType.EVENT_TYPE_QUERY_PROGRESS;
    case 2:
    case "EVENT_TYPE_QUERY_RESULT":
      return EventType.EVENT_TYPE_QUERY_RESULT;
    case 3:
    case "EVENT_TYPE_QUERY_ERROR":
      return EventType.EVENT_TYPE_QUERY_ERROR;
    case 4:
    case "EVENT_TYPE_CONNECTION_STATUS":
      return EventType.EVENT_TYPE_CONNECTION_STATUS;
    case 5:
    case "EVENT_TYPE_TABLE_CHANGED":
      return EventType.EVENT_TYPE_TABLE_CHANGED;
    case 6:
    case "EVENT_TYPE_SCHEMA_CHANGED":
      return EventType.EVENT_TYPE_SCHEMA_CHANGED;
    case 7:
    case "EVENT_TYPE_USER_ACTION":
      return EventType.EVENT_TYPE_USER_ACTION;
    case 8:
    case "EVENT_TYPE_SYSTEM_ALERT":
      return EventType.EVENT_TYPE_SYSTEM_ALERT;
    case 9:
    case "EVENT_TYPE_HEARTBEAT":
      return EventType.EVENT_TYPE_HEARTBEAT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EventType.UNRECOGNIZED;
  }
}

export function eventTypeToJSON(object: EventType): string {
  switch (object) {
    case EventType.EVENT_TYPE_UNSPECIFIED:
      return "EVENT_TYPE_UNSPECIFIED";
    case EventType.EVENT_TYPE_QUERY_PROGRESS:
      return "EVENT_TYPE_QUERY_PROGRESS";
    case EventType.EVENT_TYPE_QUERY_RESULT:
      return "EVENT_TYPE_QUERY_RESULT";
    case EventType.EVENT_TYPE_QUERY_ERROR:
      return "EVENT_TYPE_QUERY_ERROR";
    case EventType.EVENT_TYPE_CONNECTION_STATUS:
      return "EVENT_TYPE_CONNECTION_STATUS";
    case EventType.EVENT_TYPE_TABLE_CHANGED:
      return "EVENT_TYPE_TABLE_CHANGED";
    case EventType.EVENT_TYPE_SCHEMA_CHANGED:
      return "EVENT_TYPE_SCHEMA_CHANGED";
    case EventType.EVENT_TYPE_USER_ACTION:
      return "EVENT_TYPE_USER_ACTION";
    case EventType.EVENT_TYPE_SYSTEM_ALERT:
      return "EVENT_TYPE_SYSTEM_ALERT";
    case EventType.EVENT_TYPE_HEARTBEAT:
      return "EVENT_TYPE_HEARTBEAT";
    case EventType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function eventTypeToNumber(object: EventType): number {
  switch (object) {
    case EventType.EVENT_TYPE_UNSPECIFIED:
      return 0;
    case EventType.EVENT_TYPE_QUERY_PROGRESS:
      return 1;
    case EventType.EVENT_TYPE_QUERY_RESULT:
      return 2;
    case EventType.EVENT_TYPE_QUERY_ERROR:
      return 3;
    case EventType.EVENT_TYPE_CONNECTION_STATUS:
      return 4;
    case EventType.EVENT_TYPE_TABLE_CHANGED:
      return 5;
    case EventType.EVENT_TYPE_SCHEMA_CHANGED:
      return 6;
    case EventType.EVENT_TYPE_USER_ACTION:
      return 7;
    case EventType.EVENT_TYPE_SYSTEM_ALERT:
      return 8;
    case EventType.EVENT_TYPE_HEARTBEAT:
      return 9;
    case EventType.UNRECOGNIZED:
    default:
      return -1;
  }
}

/** Subscription types */
export enum SubscriptionType {
  SUBSCRIPTION_TYPE_UNSPECIFIED = "SUBSCRIPTION_TYPE_UNSPECIFIED",
  SUBSCRIPTION_TYPE_QUERY_UPDATES = "SUBSCRIPTION_TYPE_QUERY_UPDATES",
  SUBSCRIPTION_TYPE_CONNECTION_UPDATES = "SUBSCRIPTION_TYPE_CONNECTION_UPDATES",
  SUBSCRIPTION_TYPE_TABLE_UPDATES = "SUBSCRIPTION_TYPE_TABLE_UPDATES",
  SUBSCRIPTION_TYPE_SCHEMA_UPDATES = "SUBSCRIPTION_TYPE_SCHEMA_UPDATES",
  SUBSCRIPTION_TYPE_USER_ACTIVITIES = "SUBSCRIPTION_TYPE_USER_ACTIVITIES",
  SUBSCRIPTION_TYPE_SYSTEM_EVENTS = "SUBSCRIPTION_TYPE_SYSTEM_EVENTS",
  SUBSCRIPTION_TYPE_ALL = "SUBSCRIPTION_TYPE_ALL",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function subscriptionTypeFromJSON(object: any): SubscriptionType {
  switch (object) {
    case 0:
    case "SUBSCRIPTION_TYPE_UNSPECIFIED":
      return SubscriptionType.SUBSCRIPTION_TYPE_UNSPECIFIED;
    case 1:
    case "SUBSCRIPTION_TYPE_QUERY_UPDATES":
      return SubscriptionType.SUBSCRIPTION_TYPE_QUERY_UPDATES;
    case 2:
    case "SUBSCRIPTION_TYPE_CONNECTION_UPDATES":
      return SubscriptionType.SUBSCRIPTION_TYPE_CONNECTION_UPDATES;
    case 3:
    case "SUBSCRIPTION_TYPE_TABLE_UPDATES":
      return SubscriptionType.SUBSCRIPTION_TYPE_TABLE_UPDATES;
    case 4:
    case "SUBSCRIPTION_TYPE_SCHEMA_UPDATES":
      return SubscriptionType.SUBSCRIPTION_TYPE_SCHEMA_UPDATES;
    case 5:
    case "SUBSCRIPTION_TYPE_USER_ACTIVITIES":
      return SubscriptionType.SUBSCRIPTION_TYPE_USER_ACTIVITIES;
    case 6:
    case "SUBSCRIPTION_TYPE_SYSTEM_EVENTS":
      return SubscriptionType.SUBSCRIPTION_TYPE_SYSTEM_EVENTS;
    case 7:
    case "SUBSCRIPTION_TYPE_ALL":
      return SubscriptionType.SUBSCRIPTION_TYPE_ALL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SubscriptionType.UNRECOGNIZED;
  }
}

export function subscriptionTypeToJSON(object: SubscriptionType): string {
  switch (object) {
    case SubscriptionType.SUBSCRIPTION_TYPE_UNSPECIFIED:
      return "SUBSCRIPTION_TYPE_UNSPECIFIED";
    case SubscriptionType.SUBSCRIPTION_TYPE_QUERY_UPDATES:
      return "SUBSCRIPTION_TYPE_QUERY_UPDATES";
    case SubscriptionType.SUBSCRIPTION_TYPE_CONNECTION_UPDATES:
      return "SUBSCRIPTION_TYPE_CONNECTION_UPDATES";
    case SubscriptionType.SUBSCRIPTION_TYPE_TABLE_UPDATES:
      return "SUBSCRIPTION_TYPE_TABLE_UPDATES";
    case SubscriptionType.SUBSCRIPTION_TYPE_SCHEMA_UPDATES:
      return "SUBSCRIPTION_TYPE_SCHEMA_UPDATES";
    case SubscriptionType.SUBSCRIPTION_TYPE_USER_ACTIVITIES:
      return "SUBSCRIPTION_TYPE_USER_ACTIVITIES";
    case SubscriptionType.SUBSCRIPTION_TYPE_SYSTEM_EVENTS:
      return "SUBSCRIPTION_TYPE_SYSTEM_EVENTS";
    case SubscriptionType.SUBSCRIPTION_TYPE_ALL:
      return "SUBSCRIPTION_TYPE_ALL";
    case SubscriptionType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function subscriptionTypeToNumber(object: SubscriptionType): number {
  switch (object) {
    case SubscriptionType.SUBSCRIPTION_TYPE_UNSPECIFIED:
      return 0;
    case SubscriptionType.SUBSCRIPTION_TYPE_QUERY_UPDATES:
      return 1;
    case SubscriptionType.SUBSCRIPTION_TYPE_CONNECTION_UPDATES:
      return 2;
    case SubscriptionType.SUBSCRIPTION_TYPE_TABLE_UPDATES:
      return 3;
    case SubscriptionType.SUBSCRIPTION_TYPE_SCHEMA_UPDATES:
      return 4;
    case SubscriptionType.SUBSCRIPTION_TYPE_USER_ACTIVITIES:
      return 5;
    case SubscriptionType.SUBSCRIPTION_TYPE_SYSTEM_EVENTS:
      return 6;
    case SubscriptionType.SUBSCRIPTION_TYPE_ALL:
      return 7;
    case SubscriptionType.UNRECOGNIZED:
    default:
      return -1;
  }
}

/** Subscribe request */
export interface SubscribeRequest {
  clientId: string;
  types: SubscriptionType[];
  /** e.g., connection_id, table_name */
  filters: { [key: string]: string };
  authToken: string;
}

export interface SubscribeRequest_FiltersEntry {
  key: string;
  value: string;
}

/** Unsubscribe request */
export interface UnsubscribeRequest {
  clientId: string;
  /** Empty means unsubscribe from all */
  types: SubscriptionType[];
}

/** Unsubscribe response */
export interface UnsubscribeResponse {
  success: boolean;
  message: string;
}

/** Query progress event */
export interface QueryProgressEvent {
  queryId: string;
  connectionId: string;
  userId: string;
  rowsProcessed: Long;
  totalRows: Long;
  progressPercentage: number;
  currentPhase: string;
  timestamp: Date | undefined;
}

/** Query result event */
export interface QueryResultEvent {
  queryId: string;
  connectionId: string;
  userId: string;
  success: boolean;
  rowsAffected: Long;
  durationMs: Long;
  timestamp: Date | undefined;
}

/** Query error event */
export interface QueryErrorEvent {
  queryId: string;
  connectionId: string;
  userId: string;
  errorMessage: string;
  errorCode: string;
  sqlState: string;
  timestamp: Date | undefined;
}

/** Connection status event */
export interface ConnectionStatusEvent {
  connectionId: string;
  /** CONNECTED, DISCONNECTED, ERROR, RECONNECTING */
  status: string;
  message: string;
  activeConnections: number;
  idleConnections: number;
  timestamp: Date | undefined;
}

/** Table changed event */
export interface TableChangedEvent {
  connectionId: string;
  schemaName: string;
  tableName: string;
  /** INSERT, UPDATE, DELETE, TRUNCATE */
  operation: string;
  rowsAffected: Long;
  userId: string;
  timestamp: Date | undefined;
  metadata: { [key: string]: Any };
}

export interface TableChangedEvent_MetadataEntry {
  key: string;
  value: Any | undefined;
}

/** Schema changed event */
export interface SchemaChangedEvent {
  connectionId: string;
  schemaName: string;
  /** TABLE, VIEW, INDEX, FUNCTION, etc. */
  objectType: string;
  objectName: string;
  /** CREATE, ALTER, DROP */
  operation: string;
  userId: string;
  timestamp: Date | undefined;
  metadata: { [key: string]: Any };
}

export interface SchemaChangedEvent_MetadataEntry {
  key: string;
  value: Any | undefined;
}

/** User action event */
export interface UserActionEvent {
  userId: string;
  /** LOGIN, LOGOUT, QUERY_EXECUTE, CONNECTION_CREATE, etc. */
  action: string;
  /** connection_id, query_id, etc. */
  resourceId: string;
  resourceType: string;
  timestamp: Date | undefined;
  metadata: { [key: string]: Any };
}

export interface UserActionEvent_MetadataEntry {
  key: string;
  value: Any | undefined;
}

/** System alert event */
export interface SystemAlertEvent {
  alertId: string;
  /** INFO, WARNING, ERROR, CRITICAL */
  severity: string;
  /** PERFORMANCE, SECURITY, RESOURCE, etc. */
  category: string;
  message: string;
  source: string;
  timestamp: Date | undefined;
  metadata: { [key: string]: Any };
}

export interface SystemAlertEvent_MetadataEntry {
  key: string;
  value: Any | undefined;
}

/** Heartbeat event */
export interface HeartbeatEvent {
  serverId: string;
  timestamp: Date | undefined;
  status: { [key: string]: string };
}

export interface HeartbeatEvent_StatusEntry {
  key: string;
  value: string;
}

/** Real-time event */
export interface RealtimeEvent {
  type: EventType;
  eventId: string;
  timestamp: Date | undefined;
  queryProgress?: QueryProgressEvent | undefined;
  queryResult?: QueryResultEvent | undefined;
  queryError?: QueryErrorEvent | undefined;
  connectionStatus?: ConnectionStatusEvent | undefined;
  tableChanged?: TableChangedEvent | undefined;
  schemaChanged?: SchemaChangedEvent | undefined;
  userAction?: UserActionEvent | undefined;
  systemAlert?: SystemAlertEvent | undefined;
  heartbeat?: HeartbeatEvent | undefined;
}

/** Publish event request */
export interface PublishEventRequest {
  event:
    | RealtimeEvent
    | undefined;
  /** Empty means broadcast to all matching subscribers */
  targetClients: string[];
  /** Additional filters */
  filters: { [key: string]: string };
}

export interface PublishEventRequest_FiltersEntry {
  key: string;
  value: string;
}

/** Publish event response */
export interface PublishEventResponse {
  success: boolean;
  message: string;
  clientsNotified: number;
}

/** Get active subscriptions request */
export interface GetActiveSubscriptionsRequest {
  /** Empty means all clients */
  clientId: string;
}

/** Active subscription info */
export interface ActiveSubscription {
  clientId: string;
  types: SubscriptionType[];
  filters: { [key: string]: string };
  subscribedAt: Date | undefined;
  lastActivity: Date | undefined;
}

export interface ActiveSubscription_FiltersEntry {
  key: string;
  value: string;
}

/** Get active subscriptions response */
export interface GetActiveSubscriptionsResponse {
  success: boolean;
  message: string;
  subscriptions: ActiveSubscription[];
  totalClients: number;
}

function createBaseSubscribeRequest(): SubscribeRequest {
  return { clientId: "", types: [], filters: {}, authToken: "" };
}

export const SubscribeRequest: MessageFns<SubscribeRequest> = {
  encode(message: SubscribeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clientId !== "") {
      writer.uint32(10).string(message.clientId);
    }
    writer.uint32(18).fork();
    for (const v of message.types) {
      writer.int32(subscriptionTypeToNumber(v));
    }
    writer.join();
    Object.entries(message.filters).forEach(([key, value]) => {
      SubscribeRequest_FiltersEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    if (message.authToken !== "") {
      writer.uint32(34).string(message.authToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubscribeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscribeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.types.push(subscriptionTypeFromJSON(reader.int32()));

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.types.push(subscriptionTypeFromJSON(reader.int32()));
            }

            continue;
          }

          break;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = SubscribeRequest_FiltersEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.filters[entry3.key] = entry3.value;
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.authToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubscribeRequest {
    return {
      clientId: isSet(object.clientId) ? globalThis.String(object.clientId) : "",
      types: globalThis.Array.isArray(object?.types) ? object.types.map((e: any) => subscriptionTypeFromJSON(e)) : [],
      filters: isObject(object.filters)
        ? Object.entries(object.filters).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      authToken: isSet(object.authToken) ? globalThis.String(object.authToken) : "",
    };
  },

  toJSON(message: SubscribeRequest): unknown {
    const obj: any = {};
    if (message.clientId !== "") {
      obj.clientId = message.clientId;
    }
    if (message.types?.length) {
      obj.types = message.types.map((e) => subscriptionTypeToJSON(e));
    }
    if (message.filters) {
      const entries = Object.entries(message.filters);
      if (entries.length > 0) {
        obj.filters = {};
        entries.forEach(([k, v]) => {
          obj.filters[k] = v;
        });
      }
    }
    if (message.authToken !== "") {
      obj.authToken = message.authToken;
    }
    return obj;
  },

  create(base?: DeepPartial<SubscribeRequest>): SubscribeRequest {
    return SubscribeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SubscribeRequest>): SubscribeRequest {
    const message = createBaseSubscribeRequest();
    message.clientId = object.clientId ?? "";
    message.types = object.types?.map((e) => e) || [];
    message.filters = Object.entries(object.filters ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.authToken = object.authToken ?? "";
    return message;
  },
};

function createBaseSubscribeRequest_FiltersEntry(): SubscribeRequest_FiltersEntry {
  return { key: "", value: "" };
}

export const SubscribeRequest_FiltersEntry: MessageFns<SubscribeRequest_FiltersEntry> = {
  encode(message: SubscribeRequest_FiltersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubscribeRequest_FiltersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscribeRequest_FiltersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubscribeRequest_FiltersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: SubscribeRequest_FiltersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<SubscribeRequest_FiltersEntry>): SubscribeRequest_FiltersEntry {
    return SubscribeRequest_FiltersEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SubscribeRequest_FiltersEntry>): SubscribeRequest_FiltersEntry {
    const message = createBaseSubscribeRequest_FiltersEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseUnsubscribeRequest(): UnsubscribeRequest {
  return { clientId: "", types: [] };
}

export const UnsubscribeRequest: MessageFns<UnsubscribeRequest> = {
  encode(message: UnsubscribeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clientId !== "") {
      writer.uint32(10).string(message.clientId);
    }
    writer.uint32(18).fork();
    for (const v of message.types) {
      writer.int32(subscriptionTypeToNumber(v));
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnsubscribeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnsubscribeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.types.push(subscriptionTypeFromJSON(reader.int32()));

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.types.push(subscriptionTypeFromJSON(reader.int32()));
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnsubscribeRequest {
    return {
      clientId: isSet(object.clientId) ? globalThis.String(object.clientId) : "",
      types: globalThis.Array.isArray(object?.types) ? object.types.map((e: any) => subscriptionTypeFromJSON(e)) : [],
    };
  },

  toJSON(message: UnsubscribeRequest): unknown {
    const obj: any = {};
    if (message.clientId !== "") {
      obj.clientId = message.clientId;
    }
    if (message.types?.length) {
      obj.types = message.types.map((e) => subscriptionTypeToJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<UnsubscribeRequest>): UnsubscribeRequest {
    return UnsubscribeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UnsubscribeRequest>): UnsubscribeRequest {
    const message = createBaseUnsubscribeRequest();
    message.clientId = object.clientId ?? "";
    message.types = object.types?.map((e) => e) || [];
    return message;
  },
};

function createBaseUnsubscribeResponse(): UnsubscribeResponse {
  return { success: false, message: "" };
}

export const UnsubscribeResponse: MessageFns<UnsubscribeResponse> = {
  encode(message: UnsubscribeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnsubscribeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnsubscribeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnsubscribeResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: UnsubscribeResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create(base?: DeepPartial<UnsubscribeResponse>): UnsubscribeResponse {
    return UnsubscribeResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UnsubscribeResponse>): UnsubscribeResponse {
    const message = createBaseUnsubscribeResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseQueryProgressEvent(): QueryProgressEvent {
  return {
    queryId: "",
    connectionId: "",
    userId: "",
    rowsProcessed: Long.ZERO,
    totalRows: Long.ZERO,
    progressPercentage: 0,
    currentPhase: "",
    timestamp: undefined,
  };
}

export const QueryProgressEvent: MessageFns<QueryProgressEvent> = {
  encode(message: QueryProgressEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.queryId !== "") {
      writer.uint32(10).string(message.queryId);
    }
    if (message.connectionId !== "") {
      writer.uint32(18).string(message.connectionId);
    }
    if (message.userId !== "") {
      writer.uint32(26).string(message.userId);
    }
    if (!message.rowsProcessed.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.rowsProcessed.toString());
    }
    if (!message.totalRows.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.totalRows.toString());
    }
    if (message.progressPercentage !== 0) {
      writer.uint32(49).double(message.progressPercentage);
    }
    if (message.currentPhase !== "") {
      writer.uint32(58).string(message.currentPhase);
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryProgressEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryProgressEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.queryId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.connectionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.rowsProcessed = Long.fromString(reader.int64().toString());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.totalRows = Long.fromString(reader.int64().toString());
          continue;
        }
        case 6: {
          if (tag !== 49) {
            break;
          }

          message.progressPercentage = reader.double();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.currentPhase = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryProgressEvent {
    return {
      queryId: isSet(object.queryId) ? globalThis.String(object.queryId) : "",
      connectionId: isSet(object.connectionId) ? globalThis.String(object.connectionId) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      rowsProcessed: isSet(object.rowsProcessed) ? Long.fromValue(object.rowsProcessed) : Long.ZERO,
      totalRows: isSet(object.totalRows) ? Long.fromValue(object.totalRows) : Long.ZERO,
      progressPercentage: isSet(object.progressPercentage) ? globalThis.Number(object.progressPercentage) : 0,
      currentPhase: isSet(object.currentPhase) ? globalThis.String(object.currentPhase) : "",
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
    };
  },

  toJSON(message: QueryProgressEvent): unknown {
    const obj: any = {};
    if (message.queryId !== "") {
      obj.queryId = message.queryId;
    }
    if (message.connectionId !== "") {
      obj.connectionId = message.connectionId;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (!message.rowsProcessed.equals(Long.ZERO)) {
      obj.rowsProcessed = (message.rowsProcessed || Long.ZERO).toString();
    }
    if (!message.totalRows.equals(Long.ZERO)) {
      obj.totalRows = (message.totalRows || Long.ZERO).toString();
    }
    if (message.progressPercentage !== 0) {
      obj.progressPercentage = message.progressPercentage;
    }
    if (message.currentPhase !== "") {
      obj.currentPhase = message.currentPhase;
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<QueryProgressEvent>): QueryProgressEvent {
    return QueryProgressEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryProgressEvent>): QueryProgressEvent {
    const message = createBaseQueryProgressEvent();
    message.queryId = object.queryId ?? "";
    message.connectionId = object.connectionId ?? "";
    message.userId = object.userId ?? "";
    message.rowsProcessed = (object.rowsProcessed !== undefined && object.rowsProcessed !== null)
      ? Long.fromValue(object.rowsProcessed)
      : Long.ZERO;
    message.totalRows = (object.totalRows !== undefined && object.totalRows !== null)
      ? Long.fromValue(object.totalRows)
      : Long.ZERO;
    message.progressPercentage = object.progressPercentage ?? 0;
    message.currentPhase = object.currentPhase ?? "";
    message.timestamp = object.timestamp ?? undefined;
    return message;
  },
};

function createBaseQueryResultEvent(): QueryResultEvent {
  return {
    queryId: "",
    connectionId: "",
    userId: "",
    success: false,
    rowsAffected: Long.ZERO,
    durationMs: Long.ZERO,
    timestamp: undefined,
  };
}

export const QueryResultEvent: MessageFns<QueryResultEvent> = {
  encode(message: QueryResultEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.queryId !== "") {
      writer.uint32(10).string(message.queryId);
    }
    if (message.connectionId !== "") {
      writer.uint32(18).string(message.connectionId);
    }
    if (message.userId !== "") {
      writer.uint32(26).string(message.userId);
    }
    if (message.success !== false) {
      writer.uint32(32).bool(message.success);
    }
    if (!message.rowsAffected.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.rowsAffected.toString());
    }
    if (!message.durationMs.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.durationMs.toString());
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryResultEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryResultEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.queryId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.connectionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.rowsAffected = Long.fromString(reader.int64().toString());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.durationMs = Long.fromString(reader.int64().toString());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryResultEvent {
    return {
      queryId: isSet(object.queryId) ? globalThis.String(object.queryId) : "",
      connectionId: isSet(object.connectionId) ? globalThis.String(object.connectionId) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      rowsAffected: isSet(object.rowsAffected) ? Long.fromValue(object.rowsAffected) : Long.ZERO,
      durationMs: isSet(object.durationMs) ? Long.fromValue(object.durationMs) : Long.ZERO,
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
    };
  },

  toJSON(message: QueryResultEvent): unknown {
    const obj: any = {};
    if (message.queryId !== "") {
      obj.queryId = message.queryId;
    }
    if (message.connectionId !== "") {
      obj.connectionId = message.connectionId;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (!message.rowsAffected.equals(Long.ZERO)) {
      obj.rowsAffected = (message.rowsAffected || Long.ZERO).toString();
    }
    if (!message.durationMs.equals(Long.ZERO)) {
      obj.durationMs = (message.durationMs || Long.ZERO).toString();
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<QueryResultEvent>): QueryResultEvent {
    return QueryResultEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryResultEvent>): QueryResultEvent {
    const message = createBaseQueryResultEvent();
    message.queryId = object.queryId ?? "";
    message.connectionId = object.connectionId ?? "";
    message.userId = object.userId ?? "";
    message.success = object.success ?? false;
    message.rowsAffected = (object.rowsAffected !== undefined && object.rowsAffected !== null)
      ? Long.fromValue(object.rowsAffected)
      : Long.ZERO;
    message.durationMs = (object.durationMs !== undefined && object.durationMs !== null)
      ? Long.fromValue(object.durationMs)
      : Long.ZERO;
    message.timestamp = object.timestamp ?? undefined;
    return message;
  },
};

function createBaseQueryErrorEvent(): QueryErrorEvent {
  return {
    queryId: "",
    connectionId: "",
    userId: "",
    errorMessage: "",
    errorCode: "",
    sqlState: "",
    timestamp: undefined,
  };
}

export const QueryErrorEvent: MessageFns<QueryErrorEvent> = {
  encode(message: QueryErrorEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.queryId !== "") {
      writer.uint32(10).string(message.queryId);
    }
    if (message.connectionId !== "") {
      writer.uint32(18).string(message.connectionId);
    }
    if (message.userId !== "") {
      writer.uint32(26).string(message.userId);
    }
    if (message.errorMessage !== "") {
      writer.uint32(34).string(message.errorMessage);
    }
    if (message.errorCode !== "") {
      writer.uint32(42).string(message.errorCode);
    }
    if (message.sqlState !== "") {
      writer.uint32(50).string(message.sqlState);
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryErrorEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryErrorEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.queryId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.connectionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.errorCode = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.sqlState = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryErrorEvent {
    return {
      queryId: isSet(object.queryId) ? globalThis.String(object.queryId) : "",
      connectionId: isSet(object.connectionId) ? globalThis.String(object.connectionId) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
      errorCode: isSet(object.errorCode) ? globalThis.String(object.errorCode) : "",
      sqlState: isSet(object.sqlState) ? globalThis.String(object.sqlState) : "",
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
    };
  },

  toJSON(message: QueryErrorEvent): unknown {
    const obj: any = {};
    if (message.queryId !== "") {
      obj.queryId = message.queryId;
    }
    if (message.connectionId !== "") {
      obj.connectionId = message.connectionId;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    if (message.errorCode !== "") {
      obj.errorCode = message.errorCode;
    }
    if (message.sqlState !== "") {
      obj.sqlState = message.sqlState;
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<QueryErrorEvent>): QueryErrorEvent {
    return QueryErrorEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryErrorEvent>): QueryErrorEvent {
    const message = createBaseQueryErrorEvent();
    message.queryId = object.queryId ?? "";
    message.connectionId = object.connectionId ?? "";
    message.userId = object.userId ?? "";
    message.errorMessage = object.errorMessage ?? "";
    message.errorCode = object.errorCode ?? "";
    message.sqlState = object.sqlState ?? "";
    message.timestamp = object.timestamp ?? undefined;
    return message;
  },
};

function createBaseConnectionStatusEvent(): ConnectionStatusEvent {
  return { connectionId: "", status: "", message: "", activeConnections: 0, idleConnections: 0, timestamp: undefined };
}

export const ConnectionStatusEvent: MessageFns<ConnectionStatusEvent> = {
  encode(message: ConnectionStatusEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.connectionId !== "") {
      writer.uint32(10).string(message.connectionId);
    }
    if (message.status !== "") {
      writer.uint32(18).string(message.status);
    }
    if (message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    if (message.activeConnections !== 0) {
      writer.uint32(32).int32(message.activeConnections);
    }
    if (message.idleConnections !== 0) {
      writer.uint32(40).int32(message.idleConnections);
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConnectionStatusEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnectionStatusEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.connectionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.activeConnections = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.idleConnections = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConnectionStatusEvent {
    return {
      connectionId: isSet(object.connectionId) ? globalThis.String(object.connectionId) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      activeConnections: isSet(object.activeConnections) ? globalThis.Number(object.activeConnections) : 0,
      idleConnections: isSet(object.idleConnections) ? globalThis.Number(object.idleConnections) : 0,
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
    };
  },

  toJSON(message: ConnectionStatusEvent): unknown {
    const obj: any = {};
    if (message.connectionId !== "") {
      obj.connectionId = message.connectionId;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.activeConnections !== 0) {
      obj.activeConnections = Math.round(message.activeConnections);
    }
    if (message.idleConnections !== 0) {
      obj.idleConnections = Math.round(message.idleConnections);
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<ConnectionStatusEvent>): ConnectionStatusEvent {
    return ConnectionStatusEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConnectionStatusEvent>): ConnectionStatusEvent {
    const message = createBaseConnectionStatusEvent();
    message.connectionId = object.connectionId ?? "";
    message.status = object.status ?? "";
    message.message = object.message ?? "";
    message.activeConnections = object.activeConnections ?? 0;
    message.idleConnections = object.idleConnections ?? 0;
    message.timestamp = object.timestamp ?? undefined;
    return message;
  },
};

function createBaseTableChangedEvent(): TableChangedEvent {
  return {
    connectionId: "",
    schemaName: "",
    tableName: "",
    operation: "",
    rowsAffected: Long.ZERO,
    userId: "",
    timestamp: undefined,
    metadata: {},
  };
}

export const TableChangedEvent: MessageFns<TableChangedEvent> = {
  encode(message: TableChangedEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.connectionId !== "") {
      writer.uint32(10).string(message.connectionId);
    }
    if (message.schemaName !== "") {
      writer.uint32(18).string(message.schemaName);
    }
    if (message.tableName !== "") {
      writer.uint32(26).string(message.tableName);
    }
    if (message.operation !== "") {
      writer.uint32(34).string(message.operation);
    }
    if (!message.rowsAffected.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.rowsAffected.toString());
    }
    if (message.userId !== "") {
      writer.uint32(50).string(message.userId);
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(58).fork()).join();
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      TableChangedEvent_MetadataEntry.encode({ key: key as any, value }, writer.uint32(66).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TableChangedEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTableChangedEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.connectionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.schemaName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tableName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.operation = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.rowsAffected = Long.fromString(reader.int64().toString());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          const entry8 = TableChangedEvent_MetadataEntry.decode(reader, reader.uint32());
          if (entry8.value !== undefined) {
            message.metadata[entry8.key] = entry8.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TableChangedEvent {
    return {
      connectionId: isSet(object.connectionId) ? globalThis.String(object.connectionId) : "",
      schemaName: isSet(object.schemaName) ? globalThis.String(object.schemaName) : "",
      tableName: isSet(object.tableName) ? globalThis.String(object.tableName) : "",
      operation: isSet(object.operation) ? globalThis.String(object.operation) : "",
      rowsAffected: isSet(object.rowsAffected) ? Long.fromValue(object.rowsAffected) : Long.ZERO,
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: Any }>((acc, [key, value]) => {
          acc[key] = Any.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: TableChangedEvent): unknown {
    const obj: any = {};
    if (message.connectionId !== "") {
      obj.connectionId = message.connectionId;
    }
    if (message.schemaName !== "") {
      obj.schemaName = message.schemaName;
    }
    if (message.tableName !== "") {
      obj.tableName = message.tableName;
    }
    if (message.operation !== "") {
      obj.operation = message.operation;
    }
    if (!message.rowsAffected.equals(Long.ZERO)) {
      obj.rowsAffected = (message.rowsAffected || Long.ZERO).toString();
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = Any.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<TableChangedEvent>): TableChangedEvent {
    return TableChangedEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TableChangedEvent>): TableChangedEvent {
    const message = createBaseTableChangedEvent();
    message.connectionId = object.connectionId ?? "";
    message.schemaName = object.schemaName ?? "";
    message.tableName = object.tableName ?? "";
    message.operation = object.operation ?? "";
    message.rowsAffected = (object.rowsAffected !== undefined && object.rowsAffected !== null)
      ? Long.fromValue(object.rowsAffected)
      : Long.ZERO;
    message.userId = object.userId ?? "";
    message.timestamp = object.timestamp ?? undefined;
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: Any }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Any.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseTableChangedEvent_MetadataEntry(): TableChangedEvent_MetadataEntry {
  return { key: "", value: undefined };
}

export const TableChangedEvent_MetadataEntry: MessageFns<TableChangedEvent_MetadataEntry> = {
  encode(message: TableChangedEvent_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Any.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TableChangedEvent_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTableChangedEvent_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Any.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TableChangedEvent_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Any.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: TableChangedEvent_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Any.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<TableChangedEvent_MetadataEntry>): TableChangedEvent_MetadataEntry {
    return TableChangedEvent_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TableChangedEvent_MetadataEntry>): TableChangedEvent_MetadataEntry {
    const message = createBaseTableChangedEvent_MetadataEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Any.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseSchemaChangedEvent(): SchemaChangedEvent {
  return {
    connectionId: "",
    schemaName: "",
    objectType: "",
    objectName: "",
    operation: "",
    userId: "",
    timestamp: undefined,
    metadata: {},
  };
}

export const SchemaChangedEvent: MessageFns<SchemaChangedEvent> = {
  encode(message: SchemaChangedEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.connectionId !== "") {
      writer.uint32(10).string(message.connectionId);
    }
    if (message.schemaName !== "") {
      writer.uint32(18).string(message.schemaName);
    }
    if (message.objectType !== "") {
      writer.uint32(26).string(message.objectType);
    }
    if (message.objectName !== "") {
      writer.uint32(34).string(message.objectName);
    }
    if (message.operation !== "") {
      writer.uint32(42).string(message.operation);
    }
    if (message.userId !== "") {
      writer.uint32(50).string(message.userId);
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(58).fork()).join();
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      SchemaChangedEvent_MetadataEntry.encode({ key: key as any, value }, writer.uint32(66).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SchemaChangedEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSchemaChangedEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.connectionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.schemaName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.objectType = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.objectName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.operation = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          const entry8 = SchemaChangedEvent_MetadataEntry.decode(reader, reader.uint32());
          if (entry8.value !== undefined) {
            message.metadata[entry8.key] = entry8.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SchemaChangedEvent {
    return {
      connectionId: isSet(object.connectionId) ? globalThis.String(object.connectionId) : "",
      schemaName: isSet(object.schemaName) ? globalThis.String(object.schemaName) : "",
      objectType: isSet(object.objectType) ? globalThis.String(object.objectType) : "",
      objectName: isSet(object.objectName) ? globalThis.String(object.objectName) : "",
      operation: isSet(object.operation) ? globalThis.String(object.operation) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: Any }>((acc, [key, value]) => {
          acc[key] = Any.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: SchemaChangedEvent): unknown {
    const obj: any = {};
    if (message.connectionId !== "") {
      obj.connectionId = message.connectionId;
    }
    if (message.schemaName !== "") {
      obj.schemaName = message.schemaName;
    }
    if (message.objectType !== "") {
      obj.objectType = message.objectType;
    }
    if (message.objectName !== "") {
      obj.objectName = message.objectName;
    }
    if (message.operation !== "") {
      obj.operation = message.operation;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = Any.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<SchemaChangedEvent>): SchemaChangedEvent {
    return SchemaChangedEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SchemaChangedEvent>): SchemaChangedEvent {
    const message = createBaseSchemaChangedEvent();
    message.connectionId = object.connectionId ?? "";
    message.schemaName = object.schemaName ?? "";
    message.objectType = object.objectType ?? "";
    message.objectName = object.objectName ?? "";
    message.operation = object.operation ?? "";
    message.userId = object.userId ?? "";
    message.timestamp = object.timestamp ?? undefined;
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: Any }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Any.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseSchemaChangedEvent_MetadataEntry(): SchemaChangedEvent_MetadataEntry {
  return { key: "", value: undefined };
}

export const SchemaChangedEvent_MetadataEntry: MessageFns<SchemaChangedEvent_MetadataEntry> = {
  encode(message: SchemaChangedEvent_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Any.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SchemaChangedEvent_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSchemaChangedEvent_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Any.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SchemaChangedEvent_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Any.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: SchemaChangedEvent_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Any.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<SchemaChangedEvent_MetadataEntry>): SchemaChangedEvent_MetadataEntry {
    return SchemaChangedEvent_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SchemaChangedEvent_MetadataEntry>): SchemaChangedEvent_MetadataEntry {
    const message = createBaseSchemaChangedEvent_MetadataEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Any.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseUserActionEvent(): UserActionEvent {
  return { userId: "", action: "", resourceId: "", resourceType: "", timestamp: undefined, metadata: {} };
}

export const UserActionEvent: MessageFns<UserActionEvent> = {
  encode(message: UserActionEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.action !== "") {
      writer.uint32(18).string(message.action);
    }
    if (message.resourceId !== "") {
      writer.uint32(26).string(message.resourceId);
    }
    if (message.resourceType !== "") {
      writer.uint32(34).string(message.resourceType);
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(42).fork()).join();
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      UserActionEvent_MetadataEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserActionEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserActionEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.action = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.resourceId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.resourceType = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          const entry6 = UserActionEvent_MetadataEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.metadata[entry6.key] = entry6.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserActionEvent {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      action: isSet(object.action) ? globalThis.String(object.action) : "",
      resourceId: isSet(object.resourceId) ? globalThis.String(object.resourceId) : "",
      resourceType: isSet(object.resourceType) ? globalThis.String(object.resourceType) : "",
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: Any }>((acc, [key, value]) => {
          acc[key] = Any.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: UserActionEvent): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    if (message.resourceId !== "") {
      obj.resourceId = message.resourceId;
    }
    if (message.resourceType !== "") {
      obj.resourceType = message.resourceType;
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = Any.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<UserActionEvent>): UserActionEvent {
    return UserActionEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserActionEvent>): UserActionEvent {
    const message = createBaseUserActionEvent();
    message.userId = object.userId ?? "";
    message.action = object.action ?? "";
    message.resourceId = object.resourceId ?? "";
    message.resourceType = object.resourceType ?? "";
    message.timestamp = object.timestamp ?? undefined;
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: Any }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Any.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseUserActionEvent_MetadataEntry(): UserActionEvent_MetadataEntry {
  return { key: "", value: undefined };
}

export const UserActionEvent_MetadataEntry: MessageFns<UserActionEvent_MetadataEntry> = {
  encode(message: UserActionEvent_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Any.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserActionEvent_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserActionEvent_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Any.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserActionEvent_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Any.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: UserActionEvent_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Any.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<UserActionEvent_MetadataEntry>): UserActionEvent_MetadataEntry {
    return UserActionEvent_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserActionEvent_MetadataEntry>): UserActionEvent_MetadataEntry {
    const message = createBaseUserActionEvent_MetadataEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Any.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseSystemAlertEvent(): SystemAlertEvent {
  return { alertId: "", severity: "", category: "", message: "", source: "", timestamp: undefined, metadata: {} };
}

export const SystemAlertEvent: MessageFns<SystemAlertEvent> = {
  encode(message: SystemAlertEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.alertId !== "") {
      writer.uint32(10).string(message.alertId);
    }
    if (message.severity !== "") {
      writer.uint32(18).string(message.severity);
    }
    if (message.category !== "") {
      writer.uint32(26).string(message.category);
    }
    if (message.message !== "") {
      writer.uint32(34).string(message.message);
    }
    if (message.source !== "") {
      writer.uint32(42).string(message.source);
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(50).fork()).join();
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      SystemAlertEvent_MetadataEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SystemAlertEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSystemAlertEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.alertId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.severity = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.category = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.source = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          const entry7 = SystemAlertEvent_MetadataEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.metadata[entry7.key] = entry7.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SystemAlertEvent {
    return {
      alertId: isSet(object.alertId) ? globalThis.String(object.alertId) : "",
      severity: isSet(object.severity) ? globalThis.String(object.severity) : "",
      category: isSet(object.category) ? globalThis.String(object.category) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      source: isSet(object.source) ? globalThis.String(object.source) : "",
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: Any }>((acc, [key, value]) => {
          acc[key] = Any.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: SystemAlertEvent): unknown {
    const obj: any = {};
    if (message.alertId !== "") {
      obj.alertId = message.alertId;
    }
    if (message.severity !== "") {
      obj.severity = message.severity;
    }
    if (message.category !== "") {
      obj.category = message.category;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.source !== "") {
      obj.source = message.source;
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = Any.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<SystemAlertEvent>): SystemAlertEvent {
    return SystemAlertEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SystemAlertEvent>): SystemAlertEvent {
    const message = createBaseSystemAlertEvent();
    message.alertId = object.alertId ?? "";
    message.severity = object.severity ?? "";
    message.category = object.category ?? "";
    message.message = object.message ?? "";
    message.source = object.source ?? "";
    message.timestamp = object.timestamp ?? undefined;
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: Any }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Any.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseSystemAlertEvent_MetadataEntry(): SystemAlertEvent_MetadataEntry {
  return { key: "", value: undefined };
}

export const SystemAlertEvent_MetadataEntry: MessageFns<SystemAlertEvent_MetadataEntry> = {
  encode(message: SystemAlertEvent_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Any.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SystemAlertEvent_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSystemAlertEvent_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Any.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SystemAlertEvent_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Any.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: SystemAlertEvent_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Any.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<SystemAlertEvent_MetadataEntry>): SystemAlertEvent_MetadataEntry {
    return SystemAlertEvent_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SystemAlertEvent_MetadataEntry>): SystemAlertEvent_MetadataEntry {
    const message = createBaseSystemAlertEvent_MetadataEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Any.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseHeartbeatEvent(): HeartbeatEvent {
  return { serverId: "", timestamp: undefined, status: {} };
}

export const HeartbeatEvent: MessageFns<HeartbeatEvent> = {
  encode(message: HeartbeatEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serverId !== "") {
      writer.uint32(10).string(message.serverId);
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(18).fork()).join();
    }
    Object.entries(message.status).forEach(([key, value]) => {
      HeartbeatEvent_StatusEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HeartbeatEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHeartbeatEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.serverId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = HeartbeatEvent_StatusEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.status[entry3.key] = entry3.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HeartbeatEvent {
    return {
      serverId: isSet(object.serverId) ? globalThis.String(object.serverId) : "",
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      status: isObject(object.status)
        ? Object.entries(object.status).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: HeartbeatEvent): unknown {
    const obj: any = {};
    if (message.serverId !== "") {
      obj.serverId = message.serverId;
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.status) {
      const entries = Object.entries(message.status);
      if (entries.length > 0) {
        obj.status = {};
        entries.forEach(([k, v]) => {
          obj.status[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<HeartbeatEvent>): HeartbeatEvent {
    return HeartbeatEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HeartbeatEvent>): HeartbeatEvent {
    const message = createBaseHeartbeatEvent();
    message.serverId = object.serverId ?? "";
    message.timestamp = object.timestamp ?? undefined;
    message.status = Object.entries(object.status ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseHeartbeatEvent_StatusEntry(): HeartbeatEvent_StatusEntry {
  return { key: "", value: "" };
}

export const HeartbeatEvent_StatusEntry: MessageFns<HeartbeatEvent_StatusEntry> = {
  encode(message: HeartbeatEvent_StatusEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HeartbeatEvent_StatusEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHeartbeatEvent_StatusEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HeartbeatEvent_StatusEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: HeartbeatEvent_StatusEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<HeartbeatEvent_StatusEntry>): HeartbeatEvent_StatusEntry {
    return HeartbeatEvent_StatusEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HeartbeatEvent_StatusEntry>): HeartbeatEvent_StatusEntry {
    const message = createBaseHeartbeatEvent_StatusEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseRealtimeEvent(): RealtimeEvent {
  return {
    type: EventType.EVENT_TYPE_UNSPECIFIED,
    eventId: "",
    timestamp: undefined,
    queryProgress: undefined,
    queryResult: undefined,
    queryError: undefined,
    connectionStatus: undefined,
    tableChanged: undefined,
    schemaChanged: undefined,
    userAction: undefined,
    systemAlert: undefined,
    heartbeat: undefined,
  };
}

export const RealtimeEvent: MessageFns<RealtimeEvent> = {
  encode(message: RealtimeEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== EventType.EVENT_TYPE_UNSPECIFIED) {
      writer.uint32(8).int32(eventTypeToNumber(message.type));
    }
    if (message.eventId !== "") {
      writer.uint32(18).string(message.eventId);
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(26).fork()).join();
    }
    if (message.queryProgress !== undefined) {
      QueryProgressEvent.encode(message.queryProgress, writer.uint32(34).fork()).join();
    }
    if (message.queryResult !== undefined) {
      QueryResultEvent.encode(message.queryResult, writer.uint32(42).fork()).join();
    }
    if (message.queryError !== undefined) {
      QueryErrorEvent.encode(message.queryError, writer.uint32(50).fork()).join();
    }
    if (message.connectionStatus !== undefined) {
      ConnectionStatusEvent.encode(message.connectionStatus, writer.uint32(58).fork()).join();
    }
    if (message.tableChanged !== undefined) {
      TableChangedEvent.encode(message.tableChanged, writer.uint32(66).fork()).join();
    }
    if (message.schemaChanged !== undefined) {
      SchemaChangedEvent.encode(message.schemaChanged, writer.uint32(74).fork()).join();
    }
    if (message.userAction !== undefined) {
      UserActionEvent.encode(message.userAction, writer.uint32(82).fork()).join();
    }
    if (message.systemAlert !== undefined) {
      SystemAlertEvent.encode(message.systemAlert, writer.uint32(90).fork()).join();
    }
    if (message.heartbeat !== undefined) {
      HeartbeatEvent.encode(message.heartbeat, writer.uint32(98).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RealtimeEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRealtimeEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = eventTypeFromJSON(reader.int32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.eventId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.queryProgress = QueryProgressEvent.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.queryResult = QueryResultEvent.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.queryError = QueryErrorEvent.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.connectionStatus = ConnectionStatusEvent.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.tableChanged = TableChangedEvent.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.schemaChanged = SchemaChangedEvent.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.userAction = UserActionEvent.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.systemAlert = SystemAlertEvent.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.heartbeat = HeartbeatEvent.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RealtimeEvent {
    return {
      type: isSet(object.type) ? eventTypeFromJSON(object.type) : EventType.EVENT_TYPE_UNSPECIFIED,
      eventId: isSet(object.eventId) ? globalThis.String(object.eventId) : "",
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      queryProgress: isSet(object.queryProgress) ? QueryProgressEvent.fromJSON(object.queryProgress) : undefined,
      queryResult: isSet(object.queryResult) ? QueryResultEvent.fromJSON(object.queryResult) : undefined,
      queryError: isSet(object.queryError) ? QueryErrorEvent.fromJSON(object.queryError) : undefined,
      connectionStatus: isSet(object.connectionStatus)
        ? ConnectionStatusEvent.fromJSON(object.connectionStatus)
        : undefined,
      tableChanged: isSet(object.tableChanged) ? TableChangedEvent.fromJSON(object.tableChanged) : undefined,
      schemaChanged: isSet(object.schemaChanged) ? SchemaChangedEvent.fromJSON(object.schemaChanged) : undefined,
      userAction: isSet(object.userAction) ? UserActionEvent.fromJSON(object.userAction) : undefined,
      systemAlert: isSet(object.systemAlert) ? SystemAlertEvent.fromJSON(object.systemAlert) : undefined,
      heartbeat: isSet(object.heartbeat) ? HeartbeatEvent.fromJSON(object.heartbeat) : undefined,
    };
  },

  toJSON(message: RealtimeEvent): unknown {
    const obj: any = {};
    if (message.type !== EventType.EVENT_TYPE_UNSPECIFIED) {
      obj.type = eventTypeToJSON(message.type);
    }
    if (message.eventId !== "") {
      obj.eventId = message.eventId;
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.queryProgress !== undefined) {
      obj.queryProgress = QueryProgressEvent.toJSON(message.queryProgress);
    }
    if (message.queryResult !== undefined) {
      obj.queryResult = QueryResultEvent.toJSON(message.queryResult);
    }
    if (message.queryError !== undefined) {
      obj.queryError = QueryErrorEvent.toJSON(message.queryError);
    }
    if (message.connectionStatus !== undefined) {
      obj.connectionStatus = ConnectionStatusEvent.toJSON(message.connectionStatus);
    }
    if (message.tableChanged !== undefined) {
      obj.tableChanged = TableChangedEvent.toJSON(message.tableChanged);
    }
    if (message.schemaChanged !== undefined) {
      obj.schemaChanged = SchemaChangedEvent.toJSON(message.schemaChanged);
    }
    if (message.userAction !== undefined) {
      obj.userAction = UserActionEvent.toJSON(message.userAction);
    }
    if (message.systemAlert !== undefined) {
      obj.systemAlert = SystemAlertEvent.toJSON(message.systemAlert);
    }
    if (message.heartbeat !== undefined) {
      obj.heartbeat = HeartbeatEvent.toJSON(message.heartbeat);
    }
    return obj;
  },

  create(base?: DeepPartial<RealtimeEvent>): RealtimeEvent {
    return RealtimeEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RealtimeEvent>): RealtimeEvent {
    const message = createBaseRealtimeEvent();
    message.type = object.type ?? EventType.EVENT_TYPE_UNSPECIFIED;
    message.eventId = object.eventId ?? "";
    message.timestamp = object.timestamp ?? undefined;
    message.queryProgress = (object.queryProgress !== undefined && object.queryProgress !== null)
      ? QueryProgressEvent.fromPartial(object.queryProgress)
      : undefined;
    message.queryResult = (object.queryResult !== undefined && object.queryResult !== null)
      ? QueryResultEvent.fromPartial(object.queryResult)
      : undefined;
    message.queryError = (object.queryError !== undefined && object.queryError !== null)
      ? QueryErrorEvent.fromPartial(object.queryError)
      : undefined;
    message.connectionStatus = (object.connectionStatus !== undefined && object.connectionStatus !== null)
      ? ConnectionStatusEvent.fromPartial(object.connectionStatus)
      : undefined;
    message.tableChanged = (object.tableChanged !== undefined && object.tableChanged !== null)
      ? TableChangedEvent.fromPartial(object.tableChanged)
      : undefined;
    message.schemaChanged = (object.schemaChanged !== undefined && object.schemaChanged !== null)
      ? SchemaChangedEvent.fromPartial(object.schemaChanged)
      : undefined;
    message.userAction = (object.userAction !== undefined && object.userAction !== null)
      ? UserActionEvent.fromPartial(object.userAction)
      : undefined;
    message.systemAlert = (object.systemAlert !== undefined && object.systemAlert !== null)
      ? SystemAlertEvent.fromPartial(object.systemAlert)
      : undefined;
    message.heartbeat = (object.heartbeat !== undefined && object.heartbeat !== null)
      ? HeartbeatEvent.fromPartial(object.heartbeat)
      : undefined;
    return message;
  },
};

function createBasePublishEventRequest(): PublishEventRequest {
  return { event: undefined, targetClients: [], filters: {} };
}

export const PublishEventRequest: MessageFns<PublishEventRequest> = {
  encode(message: PublishEventRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.event !== undefined) {
      RealtimeEvent.encode(message.event, writer.uint32(10).fork()).join();
    }
    for (const v of message.targetClients) {
      writer.uint32(18).string(v!);
    }
    Object.entries(message.filters).forEach(([key, value]) => {
      PublishEventRequest_FiltersEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PublishEventRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublishEventRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.event = RealtimeEvent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.targetClients.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = PublishEventRequest_FiltersEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.filters[entry3.key] = entry3.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PublishEventRequest {
    return {
      event: isSet(object.event) ? RealtimeEvent.fromJSON(object.event) : undefined,
      targetClients: globalThis.Array.isArray(object?.targetClients)
        ? object.targetClients.map((e: any) => globalThis.String(e))
        : [],
      filters: isObject(object.filters)
        ? Object.entries(object.filters).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: PublishEventRequest): unknown {
    const obj: any = {};
    if (message.event !== undefined) {
      obj.event = RealtimeEvent.toJSON(message.event);
    }
    if (message.targetClients?.length) {
      obj.targetClients = message.targetClients;
    }
    if (message.filters) {
      const entries = Object.entries(message.filters);
      if (entries.length > 0) {
        obj.filters = {};
        entries.forEach(([k, v]) => {
          obj.filters[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<PublishEventRequest>): PublishEventRequest {
    return PublishEventRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PublishEventRequest>): PublishEventRequest {
    const message = createBasePublishEventRequest();
    message.event = (object.event !== undefined && object.event !== null)
      ? RealtimeEvent.fromPartial(object.event)
      : undefined;
    message.targetClients = object.targetClients?.map((e) => e) || [];
    message.filters = Object.entries(object.filters ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBasePublishEventRequest_FiltersEntry(): PublishEventRequest_FiltersEntry {
  return { key: "", value: "" };
}

export const PublishEventRequest_FiltersEntry: MessageFns<PublishEventRequest_FiltersEntry> = {
  encode(message: PublishEventRequest_FiltersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PublishEventRequest_FiltersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublishEventRequest_FiltersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PublishEventRequest_FiltersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: PublishEventRequest_FiltersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<PublishEventRequest_FiltersEntry>): PublishEventRequest_FiltersEntry {
    return PublishEventRequest_FiltersEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PublishEventRequest_FiltersEntry>): PublishEventRequest_FiltersEntry {
    const message = createBasePublishEventRequest_FiltersEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBasePublishEventResponse(): PublishEventResponse {
  return { success: false, message: "", clientsNotified: 0 };
}

export const PublishEventResponse: MessageFns<PublishEventResponse> = {
  encode(message: PublishEventResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.clientsNotified !== 0) {
      writer.uint32(24).int32(message.clientsNotified);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PublishEventResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublishEventResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.clientsNotified = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PublishEventResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      clientsNotified: isSet(object.clientsNotified) ? globalThis.Number(object.clientsNotified) : 0,
    };
  },

  toJSON(message: PublishEventResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.clientsNotified !== 0) {
      obj.clientsNotified = Math.round(message.clientsNotified);
    }
    return obj;
  },

  create(base?: DeepPartial<PublishEventResponse>): PublishEventResponse {
    return PublishEventResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PublishEventResponse>): PublishEventResponse {
    const message = createBasePublishEventResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.clientsNotified = object.clientsNotified ?? 0;
    return message;
  },
};

function createBaseGetActiveSubscriptionsRequest(): GetActiveSubscriptionsRequest {
  return { clientId: "" };
}

export const GetActiveSubscriptionsRequest: MessageFns<GetActiveSubscriptionsRequest> = {
  encode(message: GetActiveSubscriptionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clientId !== "") {
      writer.uint32(10).string(message.clientId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetActiveSubscriptionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetActiveSubscriptionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetActiveSubscriptionsRequest {
    return { clientId: isSet(object.clientId) ? globalThis.String(object.clientId) : "" };
  },

  toJSON(message: GetActiveSubscriptionsRequest): unknown {
    const obj: any = {};
    if (message.clientId !== "") {
      obj.clientId = message.clientId;
    }
    return obj;
  },

  create(base?: DeepPartial<GetActiveSubscriptionsRequest>): GetActiveSubscriptionsRequest {
    return GetActiveSubscriptionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetActiveSubscriptionsRequest>): GetActiveSubscriptionsRequest {
    const message = createBaseGetActiveSubscriptionsRequest();
    message.clientId = object.clientId ?? "";
    return message;
  },
};

function createBaseActiveSubscription(): ActiveSubscription {
  return { clientId: "", types: [], filters: {}, subscribedAt: undefined, lastActivity: undefined };
}

export const ActiveSubscription: MessageFns<ActiveSubscription> = {
  encode(message: ActiveSubscription, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clientId !== "") {
      writer.uint32(10).string(message.clientId);
    }
    writer.uint32(18).fork();
    for (const v of message.types) {
      writer.int32(subscriptionTypeToNumber(v));
    }
    writer.join();
    Object.entries(message.filters).forEach(([key, value]) => {
      ActiveSubscription_FiltersEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    if (message.subscribedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.subscribedAt), writer.uint32(34).fork()).join();
    }
    if (message.lastActivity !== undefined) {
      Timestamp.encode(toTimestamp(message.lastActivity), writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ActiveSubscription {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActiveSubscription();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.types.push(subscriptionTypeFromJSON(reader.int32()));

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.types.push(subscriptionTypeFromJSON(reader.int32()));
            }

            continue;
          }

          break;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = ActiveSubscription_FiltersEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.filters[entry3.key] = entry3.value;
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.subscribedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.lastActivity = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ActiveSubscription {
    return {
      clientId: isSet(object.clientId) ? globalThis.String(object.clientId) : "",
      types: globalThis.Array.isArray(object?.types) ? object.types.map((e: any) => subscriptionTypeFromJSON(e)) : [],
      filters: isObject(object.filters)
        ? Object.entries(object.filters).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      subscribedAt: isSet(object.subscribedAt) ? fromJsonTimestamp(object.subscribedAt) : undefined,
      lastActivity: isSet(object.lastActivity) ? fromJsonTimestamp(object.lastActivity) : undefined,
    };
  },

  toJSON(message: ActiveSubscription): unknown {
    const obj: any = {};
    if (message.clientId !== "") {
      obj.clientId = message.clientId;
    }
    if (message.types?.length) {
      obj.types = message.types.map((e) => subscriptionTypeToJSON(e));
    }
    if (message.filters) {
      const entries = Object.entries(message.filters);
      if (entries.length > 0) {
        obj.filters = {};
        entries.forEach(([k, v]) => {
          obj.filters[k] = v;
        });
      }
    }
    if (message.subscribedAt !== undefined) {
      obj.subscribedAt = message.subscribedAt.toISOString();
    }
    if (message.lastActivity !== undefined) {
      obj.lastActivity = message.lastActivity.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<ActiveSubscription>): ActiveSubscription {
    return ActiveSubscription.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ActiveSubscription>): ActiveSubscription {
    const message = createBaseActiveSubscription();
    message.clientId = object.clientId ?? "";
    message.types = object.types?.map((e) => e) || [];
    message.filters = Object.entries(object.filters ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.subscribedAt = object.subscribedAt ?? undefined;
    message.lastActivity = object.lastActivity ?? undefined;
    return message;
  },
};

function createBaseActiveSubscription_FiltersEntry(): ActiveSubscription_FiltersEntry {
  return { key: "", value: "" };
}

export const ActiveSubscription_FiltersEntry: MessageFns<ActiveSubscription_FiltersEntry> = {
  encode(message: ActiveSubscription_FiltersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ActiveSubscription_FiltersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActiveSubscription_FiltersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ActiveSubscription_FiltersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ActiveSubscription_FiltersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<ActiveSubscription_FiltersEntry>): ActiveSubscription_FiltersEntry {
    return ActiveSubscription_FiltersEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ActiveSubscription_FiltersEntry>): ActiveSubscription_FiltersEntry {
    const message = createBaseActiveSubscription_FiltersEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseGetActiveSubscriptionsResponse(): GetActiveSubscriptionsResponse {
  return { success: false, message: "", subscriptions: [], totalClients: 0 };
}

export const GetActiveSubscriptionsResponse: MessageFns<GetActiveSubscriptionsResponse> = {
  encode(message: GetActiveSubscriptionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    for (const v of message.subscriptions) {
      ActiveSubscription.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.totalClients !== 0) {
      writer.uint32(32).int32(message.totalClients);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetActiveSubscriptionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetActiveSubscriptionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.subscriptions.push(ActiveSubscription.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalClients = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetActiveSubscriptionsResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      subscriptions: globalThis.Array.isArray(object?.subscriptions)
        ? object.subscriptions.map((e: any) => ActiveSubscription.fromJSON(e))
        : [],
      totalClients: isSet(object.totalClients) ? globalThis.Number(object.totalClients) : 0,
    };
  },

  toJSON(message: GetActiveSubscriptionsResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.subscriptions?.length) {
      obj.subscriptions = message.subscriptions.map((e) => ActiveSubscription.toJSON(e));
    }
    if (message.totalClients !== 0) {
      obj.totalClients = Math.round(message.totalClients);
    }
    return obj;
  },

  create(base?: DeepPartial<GetActiveSubscriptionsResponse>): GetActiveSubscriptionsResponse {
    return GetActiveSubscriptionsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetActiveSubscriptionsResponse>): GetActiveSubscriptionsResponse {
    const message = createBaseGetActiveSubscriptionsResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.subscriptions = object.subscriptions?.map((e) => ActiveSubscription.fromPartial(e)) || [];
    message.totalClients = object.totalClients ?? 0;
    return message;
  },
};

/** Real-time service for WebSocket-like functionality */
export type RealtimeServiceDefinition = typeof RealtimeServiceDefinition;
export const RealtimeServiceDefinition = {
  name: "RealtimeService",
  fullName: "sqlstudio.realtime.RealtimeService",
  methods: {
    subscribe: {
      name: "Subscribe",
      requestType: SubscribeRequest,
      requestStream: false,
      responseType: RealtimeEvent,
      responseStream: true,
      options: {},
    },
    unsubscribe: {
      name: "Unsubscribe",
      requestType: UnsubscribeRequest,
      requestStream: false,
      responseType: UnsubscribeResponse,
      responseStream: false,
      options: {},
    },
    publishEvent: {
      name: "PublishEvent",
      requestType: PublishEventRequest,
      requestStream: false,
      responseType: PublishEventResponse,
      responseStream: false,
      options: {},
    },
    getActiveSubscriptions: {
      name: "GetActiveSubscriptions",
      requestType: GetActiveSubscriptionsRequest,
      requestStream: false,
      responseType: GetActiveSubscriptionsResponse,
      responseStream: false,
      options: {},
    },
  },
} as const;

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
