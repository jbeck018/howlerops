// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.1
//   protoc               v5.29.3
// source: ai_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Duration } from "./google/protobuf/duration";
import { Timestamp } from "./google/protobuf/timestamp";

export const protobufPackage = "ai";

/** Enums */
export enum Provider {
  PROVIDER_UNSPECIFIED = "PROVIDER_UNSPECIFIED",
  PROVIDER_OPENAI = "PROVIDER_OPENAI",
  PROVIDER_ANTHROPIC = "PROVIDER_ANTHROPIC",
  PROVIDER_OLLAMA = "PROVIDER_OLLAMA",
  PROVIDER_HUGGINGFACE = "PROVIDER_HUGGINGFACE",
  PROVIDER_CLAUDECODE = "PROVIDER_CLAUDECODE",
  PROVIDER_CODEX = "PROVIDER_CODEX",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function providerFromJSON(object: any): Provider {
  switch (object) {
    case 0:
    case "PROVIDER_UNSPECIFIED":
      return Provider.PROVIDER_UNSPECIFIED;
    case 1:
    case "PROVIDER_OPENAI":
      return Provider.PROVIDER_OPENAI;
    case 2:
    case "PROVIDER_ANTHROPIC":
      return Provider.PROVIDER_ANTHROPIC;
    case 3:
    case "PROVIDER_OLLAMA":
      return Provider.PROVIDER_OLLAMA;
    case 4:
    case "PROVIDER_HUGGINGFACE":
      return Provider.PROVIDER_HUGGINGFACE;
    case 5:
    case "PROVIDER_CLAUDECODE":
      return Provider.PROVIDER_CLAUDECODE;
    case 6:
    case "PROVIDER_CODEX":
      return Provider.PROVIDER_CODEX;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Provider.UNRECOGNIZED;
  }
}

export function providerToJSON(object: Provider): string {
  switch (object) {
    case Provider.PROVIDER_UNSPECIFIED:
      return "PROVIDER_UNSPECIFIED";
    case Provider.PROVIDER_OPENAI:
      return "PROVIDER_OPENAI";
    case Provider.PROVIDER_ANTHROPIC:
      return "PROVIDER_ANTHROPIC";
    case Provider.PROVIDER_OLLAMA:
      return "PROVIDER_OLLAMA";
    case Provider.PROVIDER_HUGGINGFACE:
      return "PROVIDER_HUGGINGFACE";
    case Provider.PROVIDER_CLAUDECODE:
      return "PROVIDER_CLAUDECODE";
    case Provider.PROVIDER_CODEX:
      return "PROVIDER_CODEX";
    case Provider.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function providerToNumber(object: Provider): number {
  switch (object) {
    case Provider.PROVIDER_UNSPECIFIED:
      return 0;
    case Provider.PROVIDER_OPENAI:
      return 1;
    case Provider.PROVIDER_ANTHROPIC:
      return 2;
    case Provider.PROVIDER_OLLAMA:
      return 3;
    case Provider.PROVIDER_HUGGINGFACE:
      return 4;
    case Provider.PROVIDER_CLAUDECODE:
      return 5;
    case Provider.PROVIDER_CODEX:
      return 6;
    case Provider.UNRECOGNIZED:
    default:
      return -1;
  }
}

export enum HealthStatus {
  HEALTH_UNKNOWN = "HEALTH_UNKNOWN",
  HEALTH_HEALTHY = "HEALTH_HEALTHY",
  HEALTH_UNHEALTHY = "HEALTH_UNHEALTHY",
  HEALTH_ERROR = "HEALTH_ERROR",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function healthStatusFromJSON(object: any): HealthStatus {
  switch (object) {
    case 0:
    case "HEALTH_UNKNOWN":
      return HealthStatus.HEALTH_UNKNOWN;
    case 1:
    case "HEALTH_HEALTHY":
      return HealthStatus.HEALTH_HEALTHY;
    case 2:
    case "HEALTH_UNHEALTHY":
      return HealthStatus.HEALTH_UNHEALTHY;
    case 3:
    case "HEALTH_ERROR":
      return HealthStatus.HEALTH_ERROR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return HealthStatus.UNRECOGNIZED;
  }
}

export function healthStatusToJSON(object: HealthStatus): string {
  switch (object) {
    case HealthStatus.HEALTH_UNKNOWN:
      return "HEALTH_UNKNOWN";
    case HealthStatus.HEALTH_HEALTHY:
      return "HEALTH_HEALTHY";
    case HealthStatus.HEALTH_UNHEALTHY:
      return "HEALTH_UNHEALTHY";
    case HealthStatus.HEALTH_ERROR:
      return "HEALTH_ERROR";
    case HealthStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function healthStatusToNumber(object: HealthStatus): number {
  switch (object) {
    case HealthStatus.HEALTH_UNKNOWN:
      return 0;
    case HealthStatus.HEALTH_HEALTHY:
      return 1;
    case HealthStatus.HEALTH_UNHEALTHY:
      return 2;
    case HealthStatus.HEALTH_ERROR:
      return 3;
    case HealthStatus.UNRECOGNIZED:
    default:
      return -1;
  }
}

export enum ErrorType {
  ERROR_UNKNOWN = "ERROR_UNKNOWN",
  ERROR_INVALID_REQUEST = "ERROR_INVALID_REQUEST",
  ERROR_PROVIDER_ERROR = "ERROR_PROVIDER_ERROR",
  ERROR_CONFIG_ERROR = "ERROR_CONFIG_ERROR",
  ERROR_RATE_LIMIT = "ERROR_RATE_LIMIT",
  ERROR_TIMEOUT = "ERROR_TIMEOUT",
  ERROR_INTERNAL = "ERROR_INTERNAL",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function errorTypeFromJSON(object: any): ErrorType {
  switch (object) {
    case 0:
    case "ERROR_UNKNOWN":
      return ErrorType.ERROR_UNKNOWN;
    case 1:
    case "ERROR_INVALID_REQUEST":
      return ErrorType.ERROR_INVALID_REQUEST;
    case 2:
    case "ERROR_PROVIDER_ERROR":
      return ErrorType.ERROR_PROVIDER_ERROR;
    case 3:
    case "ERROR_CONFIG_ERROR":
      return ErrorType.ERROR_CONFIG_ERROR;
    case 4:
    case "ERROR_RATE_LIMIT":
      return ErrorType.ERROR_RATE_LIMIT;
    case 5:
    case "ERROR_TIMEOUT":
      return ErrorType.ERROR_TIMEOUT;
    case 6:
    case "ERROR_INTERNAL":
      return ErrorType.ERROR_INTERNAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ErrorType.UNRECOGNIZED;
  }
}

export function errorTypeToJSON(object: ErrorType): string {
  switch (object) {
    case ErrorType.ERROR_UNKNOWN:
      return "ERROR_UNKNOWN";
    case ErrorType.ERROR_INVALID_REQUEST:
      return "ERROR_INVALID_REQUEST";
    case ErrorType.ERROR_PROVIDER_ERROR:
      return "ERROR_PROVIDER_ERROR";
    case ErrorType.ERROR_CONFIG_ERROR:
      return "ERROR_CONFIG_ERROR";
    case ErrorType.ERROR_RATE_LIMIT:
      return "ERROR_RATE_LIMIT";
    case ErrorType.ERROR_TIMEOUT:
      return "ERROR_TIMEOUT";
    case ErrorType.ERROR_INTERNAL:
      return "ERROR_INTERNAL";
    case ErrorType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function errorTypeToNumber(object: ErrorType): number {
  switch (object) {
    case ErrorType.ERROR_UNKNOWN:
      return 0;
    case ErrorType.ERROR_INVALID_REQUEST:
      return 1;
    case ErrorType.ERROR_PROVIDER_ERROR:
      return 2;
    case ErrorType.ERROR_CONFIG_ERROR:
      return 3;
    case ErrorType.ERROR_RATE_LIMIT:
      return 4;
    case ErrorType.ERROR_TIMEOUT:
      return 5;
    case ErrorType.ERROR_INTERNAL:
      return 6;
    case ErrorType.UNRECOGNIZED:
    default:
      return -1;
  }
}

/** Core message types */
export interface SQLRequest {
  prompt: string;
  /** For fixing existing queries */
  query: string;
  /** Error message to fix */
  error: string;
  /** Database schema context */
  schema: string;
  provider: Provider;
  model: string;
  maxTokens: number;
  temperature: number;
  /** Additional context */
  context: { [key: string]: string };
}

export interface SQLRequest_ContextEntry {
  key: string;
  value: string;
}

export interface SQLResponse {
  query: string;
  explanation: string;
  confidence: number;
  suggestions: string[];
  warnings: string[];
  provider: Provider;
  model: string;
  tokensUsed: number;
  timeTaken: Duration | undefined;
  metadata: { [key: string]: string };
}

export interface SQLResponse_MetadataEntry {
  key: string;
  value: string;
}

export interface ModelInfo {
  id: string;
  name: string;
  provider: Provider;
  description: string;
  maxTokens: number;
  capabilities: string[];
  metadata: { [key: string]: string };
}

export interface ModelInfo_MetadataEntry {
  key: string;
  value: string;
}

export interface ProviderHealth {
  provider: Provider;
  status: HealthStatus;
  message: string;
  lastChecked: Date | undefined;
  responseTime: Duration | undefined;
}

export interface Usage {
  provider: Provider;
  model: string;
  requestCount: Long;
  tokensUsed: Long;
  successRate: number;
  avgResponseTime: Duration | undefined;
  lastUsed: Date | undefined;
}

export interface AIError {
  type: ErrorType;
  message: string;
  provider: Provider;
  code: string;
  details: { [key: string]: string };
  retryable: boolean;
}

export interface AIError_DetailsEntry {
  key: string;
  value: string;
}

export interface GenerateSQLRequest {
  request: SQLRequest | undefined;
}

export interface GenerateSQLResponse {
  response: SQLResponse | undefined;
  error: AIError | undefined;
}

export interface FixSQLRequest {
  request: SQLRequest | undefined;
}

export interface FixSQLResponse {
  response: SQLResponse | undefined;
  error: AIError | undefined;
}

/** No parameters needed */
export interface GetProvidersRequest {
}

export interface GetProvidersResponse {
  providers: Provider[];
}

export interface GetProviderHealthRequest {
  provider: Provider;
}

export interface ProviderHealthResponse {
  health: ProviderHealth | undefined;
  error: AIError | undefined;
}

export interface GetProviderModelsRequest {
  provider: Provider;
}

export interface GetProviderModelsResponse {
  models: ModelInfo[];
  error: AIError | undefined;
}

export interface TestProviderRequest {
  provider: Provider;
  openaiConfig?: OpenAIConfig | undefined;
  anthropicConfig?: AnthropicConfig | undefined;
  ollamaConfig?: OllamaConfig | undefined;
  huggingfaceConfig?: HuggingFaceConfig | undefined;
  claudecodeConfig?: ClaudeCodeConfig | undefined;
  codexConfig?: CodexConfig | undefined;
}

export interface TestProviderResponse {
  success: boolean;
  message: string;
  error: AIError | undefined;
}

export interface GetUsageStatsRequest {
  /** If empty, return all providers */
  provider: Provider;
}

export interface GetUsageStatsResponse {
  /** Key is provider name */
  usageStats: { [key: string]: Usage };
  error: AIError | undefined;
}

export interface GetUsageStatsResponse_UsageStatsEntry {
  key: string;
  value: Usage | undefined;
}

/** No parameters needed */
export interface GetConfigRequest {
}

export interface GetConfigResponse {
  config: AIConfig | undefined;
}

/** Configuration messages */
export interface AIConfig {
  defaultProvider: Provider;
  maxTokens: number;
  temperature: number;
  requestTimeout: Duration | undefined;
  rateLimitPerMin: number;
  openai: OpenAIConfig | undefined;
  anthropic: AnthropicConfig | undefined;
  ollama: OllamaConfig | undefined;
  huggingface: HuggingFaceConfig | undefined;
  claudecode: ClaudeCodeConfig | undefined;
  codex: CodexConfig | undefined;
}

export interface OpenAIConfig {
  /** Should be empty in responses for security */
  apiKey: string;
  baseUrl: string;
  models: string[];
  orgId: string;
  /** Indicates if provider is configured */
  configured: boolean;
}

export interface AnthropicConfig {
  /** Should be empty in responses for security */
  apiKey: string;
  baseUrl: string;
  version: string;
  models: string[];
  /** Indicates if provider is configured */
  configured: boolean;
}

export interface OllamaConfig {
  endpoint: string;
  models: string[];
  pullTimeout: Duration | undefined;
  generateTimeout: Duration | undefined;
  autoPullModels: boolean;
  /** Indicates if provider is configured */
  configured: boolean;
}

export interface HuggingFaceConfig {
  endpoint: string;
  models: string[];
  pullTimeout: Duration | undefined;
  generateTimeout: Duration | undefined;
  autoPullModels: boolean;
  recommendedModel: string;
  /** Indicates if provider is configured */
  configured: boolean;
}

export interface ClaudeCodeConfig {
  /** Should be empty in responses for security */
  apiKey: string;
  baseUrl: string;
  models: string[];
  maxTokens: number;
  temperature: number;
  /** Indicates if provider is configured */
  configured: boolean;
}

export interface CodexConfig {
  /** Should be empty in responses for security */
  apiKey: string;
  organization: string;
  baseUrl: string;
  models: string[];
  maxTokens: number;
  temperature: number;
  /** Indicates if provider is configured */
  configured: boolean;
}

function createBaseSQLRequest(): SQLRequest {
  return {
    prompt: "",
    query: "",
    error: "",
    schema: "",
    provider: Provider.PROVIDER_UNSPECIFIED,
    model: "",
    maxTokens: 0,
    temperature: 0,
    context: {},
  };
}

export const SQLRequest: MessageFns<SQLRequest> = {
  encode(message: SQLRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.prompt !== "") {
      writer.uint32(10).string(message.prompt);
    }
    if (message.query !== "") {
      writer.uint32(18).string(message.query);
    }
    if (message.error !== "") {
      writer.uint32(26).string(message.error);
    }
    if (message.schema !== "") {
      writer.uint32(34).string(message.schema);
    }
    if (message.provider !== Provider.PROVIDER_UNSPECIFIED) {
      writer.uint32(40).int32(providerToNumber(message.provider));
    }
    if (message.model !== "") {
      writer.uint32(50).string(message.model);
    }
    if (message.maxTokens !== 0) {
      writer.uint32(56).int32(message.maxTokens);
    }
    if (message.temperature !== 0) {
      writer.uint32(65).double(message.temperature);
    }
    Object.entries(message.context).forEach(([key, value]) => {
      SQLRequest_ContextEntry.encode({ key: key as any, value }, writer.uint32(74).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SQLRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSQLRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.prompt = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.query = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.schema = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.provider = providerFromJSON(reader.int32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.model = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.maxTokens = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 65) {
            break;
          }

          message.temperature = reader.double();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          const entry9 = SQLRequest_ContextEntry.decode(reader, reader.uint32());
          if (entry9.value !== undefined) {
            message.context[entry9.key] = entry9.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SQLRequest {
    return {
      prompt: isSet(object.prompt) ? globalThis.String(object.prompt) : "",
      query: isSet(object.query) ? globalThis.String(object.query) : "",
      error: isSet(object.error) ? globalThis.String(object.error) : "",
      schema: isSet(object.schema) ? globalThis.String(object.schema) : "",
      provider: isSet(object.provider) ? providerFromJSON(object.provider) : Provider.PROVIDER_UNSPECIFIED,
      model: isSet(object.model) ? globalThis.String(object.model) : "",
      maxTokens: isSet(object.maxTokens) ? globalThis.Number(object.maxTokens) : 0,
      temperature: isSet(object.temperature) ? globalThis.Number(object.temperature) : 0,
      context: isObject(object.context)
        ? Object.entries(object.context).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: SQLRequest): unknown {
    const obj: any = {};
    if (message.prompt !== "") {
      obj.prompt = message.prompt;
    }
    if (message.query !== "") {
      obj.query = message.query;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    if (message.schema !== "") {
      obj.schema = message.schema;
    }
    if (message.provider !== Provider.PROVIDER_UNSPECIFIED) {
      obj.provider = providerToJSON(message.provider);
    }
    if (message.model !== "") {
      obj.model = message.model;
    }
    if (message.maxTokens !== 0) {
      obj.maxTokens = Math.round(message.maxTokens);
    }
    if (message.temperature !== 0) {
      obj.temperature = message.temperature;
    }
    if (message.context) {
      const entries = Object.entries(message.context);
      if (entries.length > 0) {
        obj.context = {};
        entries.forEach(([k, v]) => {
          obj.context[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<SQLRequest>): SQLRequest {
    return SQLRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SQLRequest>): SQLRequest {
    const message = createBaseSQLRequest();
    message.prompt = object.prompt ?? "";
    message.query = object.query ?? "";
    message.error = object.error ?? "";
    message.schema = object.schema ?? "";
    message.provider = object.provider ?? Provider.PROVIDER_UNSPECIFIED;
    message.model = object.model ?? "";
    message.maxTokens = object.maxTokens ?? 0;
    message.temperature = object.temperature ?? 0;
    message.context = Object.entries(object.context ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseSQLRequest_ContextEntry(): SQLRequest_ContextEntry {
  return { key: "", value: "" };
}

export const SQLRequest_ContextEntry: MessageFns<SQLRequest_ContextEntry> = {
  encode(message: SQLRequest_ContextEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SQLRequest_ContextEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSQLRequest_ContextEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SQLRequest_ContextEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: SQLRequest_ContextEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<SQLRequest_ContextEntry>): SQLRequest_ContextEntry {
    return SQLRequest_ContextEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SQLRequest_ContextEntry>): SQLRequest_ContextEntry {
    const message = createBaseSQLRequest_ContextEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSQLResponse(): SQLResponse {
  return {
    query: "",
    explanation: "",
    confidence: 0,
    suggestions: [],
    warnings: [],
    provider: Provider.PROVIDER_UNSPECIFIED,
    model: "",
    tokensUsed: 0,
    timeTaken: undefined,
    metadata: {},
  };
}

export const SQLResponse: MessageFns<SQLResponse> = {
  encode(message: SQLResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.query !== "") {
      writer.uint32(10).string(message.query);
    }
    if (message.explanation !== "") {
      writer.uint32(18).string(message.explanation);
    }
    if (message.confidence !== 0) {
      writer.uint32(25).double(message.confidence);
    }
    for (const v of message.suggestions) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.warnings) {
      writer.uint32(42).string(v!);
    }
    if (message.provider !== Provider.PROVIDER_UNSPECIFIED) {
      writer.uint32(48).int32(providerToNumber(message.provider));
    }
    if (message.model !== "") {
      writer.uint32(58).string(message.model);
    }
    if (message.tokensUsed !== 0) {
      writer.uint32(64).int32(message.tokensUsed);
    }
    if (message.timeTaken !== undefined) {
      Duration.encode(message.timeTaken, writer.uint32(74).fork()).join();
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      SQLResponse_MetadataEntry.encode({ key: key as any, value }, writer.uint32(82).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SQLResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSQLResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.query = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.explanation = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.confidence = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.suggestions.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.warnings.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.provider = providerFromJSON(reader.int32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.model = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.tokensUsed = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.timeTaken = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          const entry10 = SQLResponse_MetadataEntry.decode(reader, reader.uint32());
          if (entry10.value !== undefined) {
            message.metadata[entry10.key] = entry10.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SQLResponse {
    return {
      query: isSet(object.query) ? globalThis.String(object.query) : "",
      explanation: isSet(object.explanation) ? globalThis.String(object.explanation) : "",
      confidence: isSet(object.confidence) ? globalThis.Number(object.confidence) : 0,
      suggestions: globalThis.Array.isArray(object?.suggestions)
        ? object.suggestions.map((e: any) => globalThis.String(e))
        : [],
      warnings: globalThis.Array.isArray(object?.warnings) ? object.warnings.map((e: any) => globalThis.String(e)) : [],
      provider: isSet(object.provider) ? providerFromJSON(object.provider) : Provider.PROVIDER_UNSPECIFIED,
      model: isSet(object.model) ? globalThis.String(object.model) : "",
      tokensUsed: isSet(object.tokensUsed) ? globalThis.Number(object.tokensUsed) : 0,
      timeTaken: isSet(object.timeTaken) ? Duration.fromJSON(object.timeTaken) : undefined,
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: SQLResponse): unknown {
    const obj: any = {};
    if (message.query !== "") {
      obj.query = message.query;
    }
    if (message.explanation !== "") {
      obj.explanation = message.explanation;
    }
    if (message.confidence !== 0) {
      obj.confidence = message.confidence;
    }
    if (message.suggestions?.length) {
      obj.suggestions = message.suggestions;
    }
    if (message.warnings?.length) {
      obj.warnings = message.warnings;
    }
    if (message.provider !== Provider.PROVIDER_UNSPECIFIED) {
      obj.provider = providerToJSON(message.provider);
    }
    if (message.model !== "") {
      obj.model = message.model;
    }
    if (message.tokensUsed !== 0) {
      obj.tokensUsed = Math.round(message.tokensUsed);
    }
    if (message.timeTaken !== undefined) {
      obj.timeTaken = Duration.toJSON(message.timeTaken);
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<SQLResponse>): SQLResponse {
    return SQLResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SQLResponse>): SQLResponse {
    const message = createBaseSQLResponse();
    message.query = object.query ?? "";
    message.explanation = object.explanation ?? "";
    message.confidence = object.confidence ?? 0;
    message.suggestions = object.suggestions?.map((e) => e) || [];
    message.warnings = object.warnings?.map((e) => e) || [];
    message.provider = object.provider ?? Provider.PROVIDER_UNSPECIFIED;
    message.model = object.model ?? "";
    message.tokensUsed = object.tokensUsed ?? 0;
    message.timeTaken = (object.timeTaken !== undefined && object.timeTaken !== null)
      ? Duration.fromPartial(object.timeTaken)
      : undefined;
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseSQLResponse_MetadataEntry(): SQLResponse_MetadataEntry {
  return { key: "", value: "" };
}

export const SQLResponse_MetadataEntry: MessageFns<SQLResponse_MetadataEntry> = {
  encode(message: SQLResponse_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SQLResponse_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSQLResponse_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SQLResponse_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: SQLResponse_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<SQLResponse_MetadataEntry>): SQLResponse_MetadataEntry {
    return SQLResponse_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SQLResponse_MetadataEntry>): SQLResponse_MetadataEntry {
    const message = createBaseSQLResponse_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseModelInfo(): ModelInfo {
  return {
    id: "",
    name: "",
    provider: Provider.PROVIDER_UNSPECIFIED,
    description: "",
    maxTokens: 0,
    capabilities: [],
    metadata: {},
  };
}

export const ModelInfo: MessageFns<ModelInfo> = {
  encode(message: ModelInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.provider !== Provider.PROVIDER_UNSPECIFIED) {
      writer.uint32(24).int32(providerToNumber(message.provider));
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.maxTokens !== 0) {
      writer.uint32(40).int32(message.maxTokens);
    }
    for (const v of message.capabilities) {
      writer.uint32(50).string(v!);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      ModelInfo_MetadataEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModelInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.provider = providerFromJSON(reader.int32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.maxTokens = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.capabilities.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          const entry7 = ModelInfo_MetadataEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.metadata[entry7.key] = entry7.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelInfo {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      provider: isSet(object.provider) ? providerFromJSON(object.provider) : Provider.PROVIDER_UNSPECIFIED,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      maxTokens: isSet(object.maxTokens) ? globalThis.Number(object.maxTokens) : 0,
      capabilities: globalThis.Array.isArray(object?.capabilities)
        ? object.capabilities.map((e: any) => globalThis.String(e))
        : [],
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: ModelInfo): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.provider !== Provider.PROVIDER_UNSPECIFIED) {
      obj.provider = providerToJSON(message.provider);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.maxTokens !== 0) {
      obj.maxTokens = Math.round(message.maxTokens);
    }
    if (message.capabilities?.length) {
      obj.capabilities = message.capabilities;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<ModelInfo>): ModelInfo {
    return ModelInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ModelInfo>): ModelInfo {
    const message = createBaseModelInfo();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.provider = object.provider ?? Provider.PROVIDER_UNSPECIFIED;
    message.description = object.description ?? "";
    message.maxTokens = object.maxTokens ?? 0;
    message.capabilities = object.capabilities?.map((e) => e) || [];
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseModelInfo_MetadataEntry(): ModelInfo_MetadataEntry {
  return { key: "", value: "" };
}

export const ModelInfo_MetadataEntry: MessageFns<ModelInfo_MetadataEntry> = {
  encode(message: ModelInfo_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModelInfo_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelInfo_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelInfo_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ModelInfo_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<ModelInfo_MetadataEntry>): ModelInfo_MetadataEntry {
    return ModelInfo_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ModelInfo_MetadataEntry>): ModelInfo_MetadataEntry {
    const message = createBaseModelInfo_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseProviderHealth(): ProviderHealth {
  return {
    provider: Provider.PROVIDER_UNSPECIFIED,
    status: HealthStatus.HEALTH_UNKNOWN,
    message: "",
    lastChecked: undefined,
    responseTime: undefined,
  };
}

export const ProviderHealth: MessageFns<ProviderHealth> = {
  encode(message: ProviderHealth, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.provider !== Provider.PROVIDER_UNSPECIFIED) {
      writer.uint32(8).int32(providerToNumber(message.provider));
    }
    if (message.status !== HealthStatus.HEALTH_UNKNOWN) {
      writer.uint32(16).int32(healthStatusToNumber(message.status));
    }
    if (message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    if (message.lastChecked !== undefined) {
      Timestamp.encode(toTimestamp(message.lastChecked), writer.uint32(34).fork()).join();
    }
    if (message.responseTime !== undefined) {
      Duration.encode(message.responseTime, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProviderHealth {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProviderHealth();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.provider = providerFromJSON(reader.int32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = healthStatusFromJSON(reader.int32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.lastChecked = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.responseTime = Duration.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProviderHealth {
    return {
      provider: isSet(object.provider) ? providerFromJSON(object.provider) : Provider.PROVIDER_UNSPECIFIED,
      status: isSet(object.status) ? healthStatusFromJSON(object.status) : HealthStatus.HEALTH_UNKNOWN,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      lastChecked: isSet(object.lastChecked) ? fromJsonTimestamp(object.lastChecked) : undefined,
      responseTime: isSet(object.responseTime) ? Duration.fromJSON(object.responseTime) : undefined,
    };
  },

  toJSON(message: ProviderHealth): unknown {
    const obj: any = {};
    if (message.provider !== Provider.PROVIDER_UNSPECIFIED) {
      obj.provider = providerToJSON(message.provider);
    }
    if (message.status !== HealthStatus.HEALTH_UNKNOWN) {
      obj.status = healthStatusToJSON(message.status);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.lastChecked !== undefined) {
      obj.lastChecked = message.lastChecked.toISOString();
    }
    if (message.responseTime !== undefined) {
      obj.responseTime = Duration.toJSON(message.responseTime);
    }
    return obj;
  },

  create(base?: DeepPartial<ProviderHealth>): ProviderHealth {
    return ProviderHealth.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProviderHealth>): ProviderHealth {
    const message = createBaseProviderHealth();
    message.provider = object.provider ?? Provider.PROVIDER_UNSPECIFIED;
    message.status = object.status ?? HealthStatus.HEALTH_UNKNOWN;
    message.message = object.message ?? "";
    message.lastChecked = object.lastChecked ?? undefined;
    message.responseTime = (object.responseTime !== undefined && object.responseTime !== null)
      ? Duration.fromPartial(object.responseTime)
      : undefined;
    return message;
  },
};

function createBaseUsage(): Usage {
  return {
    provider: Provider.PROVIDER_UNSPECIFIED,
    model: "",
    requestCount: Long.ZERO,
    tokensUsed: Long.ZERO,
    successRate: 0,
    avgResponseTime: undefined,
    lastUsed: undefined,
  };
}

export const Usage: MessageFns<Usage> = {
  encode(message: Usage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.provider !== Provider.PROVIDER_UNSPECIFIED) {
      writer.uint32(8).int32(providerToNumber(message.provider));
    }
    if (message.model !== "") {
      writer.uint32(18).string(message.model);
    }
    if (!message.requestCount.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.requestCount.toString());
    }
    if (!message.tokensUsed.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.tokensUsed.toString());
    }
    if (message.successRate !== 0) {
      writer.uint32(41).double(message.successRate);
    }
    if (message.avgResponseTime !== undefined) {
      Duration.encode(message.avgResponseTime, writer.uint32(50).fork()).join();
    }
    if (message.lastUsed !== undefined) {
      Timestamp.encode(toTimestamp(message.lastUsed), writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Usage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUsage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.provider = providerFromJSON(reader.int32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.model = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.requestCount = Long.fromString(reader.int64().toString());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.tokensUsed = Long.fromString(reader.int64().toString());
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }

          message.successRate = reader.double();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.avgResponseTime = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.lastUsed = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Usage {
    return {
      provider: isSet(object.provider) ? providerFromJSON(object.provider) : Provider.PROVIDER_UNSPECIFIED,
      model: isSet(object.model) ? globalThis.String(object.model) : "",
      requestCount: isSet(object.requestCount) ? Long.fromValue(object.requestCount) : Long.ZERO,
      tokensUsed: isSet(object.tokensUsed) ? Long.fromValue(object.tokensUsed) : Long.ZERO,
      successRate: isSet(object.successRate) ? globalThis.Number(object.successRate) : 0,
      avgResponseTime: isSet(object.avgResponseTime) ? Duration.fromJSON(object.avgResponseTime) : undefined,
      lastUsed: isSet(object.lastUsed) ? fromJsonTimestamp(object.lastUsed) : undefined,
    };
  },

  toJSON(message: Usage): unknown {
    const obj: any = {};
    if (message.provider !== Provider.PROVIDER_UNSPECIFIED) {
      obj.provider = providerToJSON(message.provider);
    }
    if (message.model !== "") {
      obj.model = message.model;
    }
    if (!message.requestCount.equals(Long.ZERO)) {
      obj.requestCount = (message.requestCount || Long.ZERO).toString();
    }
    if (!message.tokensUsed.equals(Long.ZERO)) {
      obj.tokensUsed = (message.tokensUsed || Long.ZERO).toString();
    }
    if (message.successRate !== 0) {
      obj.successRate = message.successRate;
    }
    if (message.avgResponseTime !== undefined) {
      obj.avgResponseTime = Duration.toJSON(message.avgResponseTime);
    }
    if (message.lastUsed !== undefined) {
      obj.lastUsed = message.lastUsed.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<Usage>): Usage {
    return Usage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Usage>): Usage {
    const message = createBaseUsage();
    message.provider = object.provider ?? Provider.PROVIDER_UNSPECIFIED;
    message.model = object.model ?? "";
    message.requestCount = (object.requestCount !== undefined && object.requestCount !== null)
      ? Long.fromValue(object.requestCount)
      : Long.ZERO;
    message.tokensUsed = (object.tokensUsed !== undefined && object.tokensUsed !== null)
      ? Long.fromValue(object.tokensUsed)
      : Long.ZERO;
    message.successRate = object.successRate ?? 0;
    message.avgResponseTime = (object.avgResponseTime !== undefined && object.avgResponseTime !== null)
      ? Duration.fromPartial(object.avgResponseTime)
      : undefined;
    message.lastUsed = object.lastUsed ?? undefined;
    return message;
  },
};

function createBaseAIError(): AIError {
  return {
    type: ErrorType.ERROR_UNKNOWN,
    message: "",
    provider: Provider.PROVIDER_UNSPECIFIED,
    code: "",
    details: {},
    retryable: false,
  };
}

export const AIError: MessageFns<AIError> = {
  encode(message: AIError, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== ErrorType.ERROR_UNKNOWN) {
      writer.uint32(8).int32(errorTypeToNumber(message.type));
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.provider !== Provider.PROVIDER_UNSPECIFIED) {
      writer.uint32(24).int32(providerToNumber(message.provider));
    }
    if (message.code !== "") {
      writer.uint32(34).string(message.code);
    }
    Object.entries(message.details).forEach(([key, value]) => {
      AIError_DetailsEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    if (message.retryable !== false) {
      writer.uint32(48).bool(message.retryable);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AIError {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAIError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = errorTypeFromJSON(reader.int32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.provider = providerFromJSON(reader.int32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          const entry5 = AIError_DetailsEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.details[entry5.key] = entry5.value;
          }
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.retryable = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AIError {
    return {
      type: isSet(object.type) ? errorTypeFromJSON(object.type) : ErrorType.ERROR_UNKNOWN,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      provider: isSet(object.provider) ? providerFromJSON(object.provider) : Provider.PROVIDER_UNSPECIFIED,
      code: isSet(object.code) ? globalThis.String(object.code) : "",
      details: isObject(object.details)
        ? Object.entries(object.details).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      retryable: isSet(object.retryable) ? globalThis.Boolean(object.retryable) : false,
    };
  },

  toJSON(message: AIError): unknown {
    const obj: any = {};
    if (message.type !== ErrorType.ERROR_UNKNOWN) {
      obj.type = errorTypeToJSON(message.type);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.provider !== Provider.PROVIDER_UNSPECIFIED) {
      obj.provider = providerToJSON(message.provider);
    }
    if (message.code !== "") {
      obj.code = message.code;
    }
    if (message.details) {
      const entries = Object.entries(message.details);
      if (entries.length > 0) {
        obj.details = {};
        entries.forEach(([k, v]) => {
          obj.details[k] = v;
        });
      }
    }
    if (message.retryable !== false) {
      obj.retryable = message.retryable;
    }
    return obj;
  },

  create(base?: DeepPartial<AIError>): AIError {
    return AIError.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AIError>): AIError {
    const message = createBaseAIError();
    message.type = object.type ?? ErrorType.ERROR_UNKNOWN;
    message.message = object.message ?? "";
    message.provider = object.provider ?? Provider.PROVIDER_UNSPECIFIED;
    message.code = object.code ?? "";
    message.details = Object.entries(object.details ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.retryable = object.retryable ?? false;
    return message;
  },
};

function createBaseAIError_DetailsEntry(): AIError_DetailsEntry {
  return { key: "", value: "" };
}

export const AIError_DetailsEntry: MessageFns<AIError_DetailsEntry> = {
  encode(message: AIError_DetailsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AIError_DetailsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAIError_DetailsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AIError_DetailsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: AIError_DetailsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<AIError_DetailsEntry>): AIError_DetailsEntry {
    return AIError_DetailsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AIError_DetailsEntry>): AIError_DetailsEntry {
    const message = createBaseAIError_DetailsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseGenerateSQLRequest(): GenerateSQLRequest {
  return { request: undefined };
}

export const GenerateSQLRequest: MessageFns<GenerateSQLRequest> = {
  encode(message: GenerateSQLRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.request !== undefined) {
      SQLRequest.encode(message.request, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateSQLRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateSQLRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.request = SQLRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateSQLRequest {
    return { request: isSet(object.request) ? SQLRequest.fromJSON(object.request) : undefined };
  },

  toJSON(message: GenerateSQLRequest): unknown {
    const obj: any = {};
    if (message.request !== undefined) {
      obj.request = SQLRequest.toJSON(message.request);
    }
    return obj;
  },

  create(base?: DeepPartial<GenerateSQLRequest>): GenerateSQLRequest {
    return GenerateSQLRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerateSQLRequest>): GenerateSQLRequest {
    const message = createBaseGenerateSQLRequest();
    message.request = (object.request !== undefined && object.request !== null)
      ? SQLRequest.fromPartial(object.request)
      : undefined;
    return message;
  },
};

function createBaseGenerateSQLResponse(): GenerateSQLResponse {
  return { response: undefined, error: undefined };
}

export const GenerateSQLResponse: MessageFns<GenerateSQLResponse> = {
  encode(message: GenerateSQLResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.response !== undefined) {
      SQLResponse.encode(message.response, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      AIError.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateSQLResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateSQLResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.response = SQLResponse.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = AIError.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateSQLResponse {
    return {
      response: isSet(object.response) ? SQLResponse.fromJSON(object.response) : undefined,
      error: isSet(object.error) ? AIError.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: GenerateSQLResponse): unknown {
    const obj: any = {};
    if (message.response !== undefined) {
      obj.response = SQLResponse.toJSON(message.response);
    }
    if (message.error !== undefined) {
      obj.error = AIError.toJSON(message.error);
    }
    return obj;
  },

  create(base?: DeepPartial<GenerateSQLResponse>): GenerateSQLResponse {
    return GenerateSQLResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerateSQLResponse>): GenerateSQLResponse {
    const message = createBaseGenerateSQLResponse();
    message.response = (object.response !== undefined && object.response !== null)
      ? SQLResponse.fromPartial(object.response)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null)
      ? AIError.fromPartial(object.error)
      : undefined;
    return message;
  },
};

function createBaseFixSQLRequest(): FixSQLRequest {
  return { request: undefined };
}

export const FixSQLRequest: MessageFns<FixSQLRequest> = {
  encode(message: FixSQLRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.request !== undefined) {
      SQLRequest.encode(message.request, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FixSQLRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFixSQLRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.request = SQLRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FixSQLRequest {
    return { request: isSet(object.request) ? SQLRequest.fromJSON(object.request) : undefined };
  },

  toJSON(message: FixSQLRequest): unknown {
    const obj: any = {};
    if (message.request !== undefined) {
      obj.request = SQLRequest.toJSON(message.request);
    }
    return obj;
  },

  create(base?: DeepPartial<FixSQLRequest>): FixSQLRequest {
    return FixSQLRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FixSQLRequest>): FixSQLRequest {
    const message = createBaseFixSQLRequest();
    message.request = (object.request !== undefined && object.request !== null)
      ? SQLRequest.fromPartial(object.request)
      : undefined;
    return message;
  },
};

function createBaseFixSQLResponse(): FixSQLResponse {
  return { response: undefined, error: undefined };
}

export const FixSQLResponse: MessageFns<FixSQLResponse> = {
  encode(message: FixSQLResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.response !== undefined) {
      SQLResponse.encode(message.response, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      AIError.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FixSQLResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFixSQLResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.response = SQLResponse.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = AIError.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FixSQLResponse {
    return {
      response: isSet(object.response) ? SQLResponse.fromJSON(object.response) : undefined,
      error: isSet(object.error) ? AIError.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: FixSQLResponse): unknown {
    const obj: any = {};
    if (message.response !== undefined) {
      obj.response = SQLResponse.toJSON(message.response);
    }
    if (message.error !== undefined) {
      obj.error = AIError.toJSON(message.error);
    }
    return obj;
  },

  create(base?: DeepPartial<FixSQLResponse>): FixSQLResponse {
    return FixSQLResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FixSQLResponse>): FixSQLResponse {
    const message = createBaseFixSQLResponse();
    message.response = (object.response !== undefined && object.response !== null)
      ? SQLResponse.fromPartial(object.response)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null)
      ? AIError.fromPartial(object.error)
      : undefined;
    return message;
  },
};

function createBaseGetProvidersRequest(): GetProvidersRequest {
  return {};
}

export const GetProvidersRequest: MessageFns<GetProvidersRequest> = {
  encode(_: GetProvidersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProvidersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProvidersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetProvidersRequest {
    return {};
  },

  toJSON(_: GetProvidersRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<GetProvidersRequest>): GetProvidersRequest {
    return GetProvidersRequest.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<GetProvidersRequest>): GetProvidersRequest {
    const message = createBaseGetProvidersRequest();
    return message;
  },
};

function createBaseGetProvidersResponse(): GetProvidersResponse {
  return { providers: [] };
}

export const GetProvidersResponse: MessageFns<GetProvidersResponse> = {
  encode(message: GetProvidersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.providers) {
      writer.int32(providerToNumber(v));
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProvidersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProvidersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.providers.push(providerFromJSON(reader.int32()));

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.providers.push(providerFromJSON(reader.int32()));
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetProvidersResponse {
    return {
      providers: globalThis.Array.isArray(object?.providers)
        ? object.providers.map((e: any) => providerFromJSON(e))
        : [],
    };
  },

  toJSON(message: GetProvidersResponse): unknown {
    const obj: any = {};
    if (message.providers?.length) {
      obj.providers = message.providers.map((e) => providerToJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GetProvidersResponse>): GetProvidersResponse {
    return GetProvidersResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetProvidersResponse>): GetProvidersResponse {
    const message = createBaseGetProvidersResponse();
    message.providers = object.providers?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetProviderHealthRequest(): GetProviderHealthRequest {
  return { provider: Provider.PROVIDER_UNSPECIFIED };
}

export const GetProviderHealthRequest: MessageFns<GetProviderHealthRequest> = {
  encode(message: GetProviderHealthRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.provider !== Provider.PROVIDER_UNSPECIFIED) {
      writer.uint32(8).int32(providerToNumber(message.provider));
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProviderHealthRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProviderHealthRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.provider = providerFromJSON(reader.int32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetProviderHealthRequest {
    return { provider: isSet(object.provider) ? providerFromJSON(object.provider) : Provider.PROVIDER_UNSPECIFIED };
  },

  toJSON(message: GetProviderHealthRequest): unknown {
    const obj: any = {};
    if (message.provider !== Provider.PROVIDER_UNSPECIFIED) {
      obj.provider = providerToJSON(message.provider);
    }
    return obj;
  },

  create(base?: DeepPartial<GetProviderHealthRequest>): GetProviderHealthRequest {
    return GetProviderHealthRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetProviderHealthRequest>): GetProviderHealthRequest {
    const message = createBaseGetProviderHealthRequest();
    message.provider = object.provider ?? Provider.PROVIDER_UNSPECIFIED;
    return message;
  },
};

function createBaseProviderHealthResponse(): ProviderHealthResponse {
  return { health: undefined, error: undefined };
}

export const ProviderHealthResponse: MessageFns<ProviderHealthResponse> = {
  encode(message: ProviderHealthResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.health !== undefined) {
      ProviderHealth.encode(message.health, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      AIError.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProviderHealthResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProviderHealthResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.health = ProviderHealth.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = AIError.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProviderHealthResponse {
    return {
      health: isSet(object.health) ? ProviderHealth.fromJSON(object.health) : undefined,
      error: isSet(object.error) ? AIError.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: ProviderHealthResponse): unknown {
    const obj: any = {};
    if (message.health !== undefined) {
      obj.health = ProviderHealth.toJSON(message.health);
    }
    if (message.error !== undefined) {
      obj.error = AIError.toJSON(message.error);
    }
    return obj;
  },

  create(base?: DeepPartial<ProviderHealthResponse>): ProviderHealthResponse {
    return ProviderHealthResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProviderHealthResponse>): ProviderHealthResponse {
    const message = createBaseProviderHealthResponse();
    message.health = (object.health !== undefined && object.health !== null)
      ? ProviderHealth.fromPartial(object.health)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null)
      ? AIError.fromPartial(object.error)
      : undefined;
    return message;
  },
};

function createBaseGetProviderModelsRequest(): GetProviderModelsRequest {
  return { provider: Provider.PROVIDER_UNSPECIFIED };
}

export const GetProviderModelsRequest: MessageFns<GetProviderModelsRequest> = {
  encode(message: GetProviderModelsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.provider !== Provider.PROVIDER_UNSPECIFIED) {
      writer.uint32(8).int32(providerToNumber(message.provider));
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProviderModelsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProviderModelsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.provider = providerFromJSON(reader.int32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetProviderModelsRequest {
    return { provider: isSet(object.provider) ? providerFromJSON(object.provider) : Provider.PROVIDER_UNSPECIFIED };
  },

  toJSON(message: GetProviderModelsRequest): unknown {
    const obj: any = {};
    if (message.provider !== Provider.PROVIDER_UNSPECIFIED) {
      obj.provider = providerToJSON(message.provider);
    }
    return obj;
  },

  create(base?: DeepPartial<GetProviderModelsRequest>): GetProviderModelsRequest {
    return GetProviderModelsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetProviderModelsRequest>): GetProviderModelsRequest {
    const message = createBaseGetProviderModelsRequest();
    message.provider = object.provider ?? Provider.PROVIDER_UNSPECIFIED;
    return message;
  },
};

function createBaseGetProviderModelsResponse(): GetProviderModelsResponse {
  return { models: [], error: undefined };
}

export const GetProviderModelsResponse: MessageFns<GetProviderModelsResponse> = {
  encode(message: GetProviderModelsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.models) {
      ModelInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      AIError.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProviderModelsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProviderModelsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.models.push(ModelInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = AIError.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetProviderModelsResponse {
    return {
      models: globalThis.Array.isArray(object?.models) ? object.models.map((e: any) => ModelInfo.fromJSON(e)) : [],
      error: isSet(object.error) ? AIError.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: GetProviderModelsResponse): unknown {
    const obj: any = {};
    if (message.models?.length) {
      obj.models = message.models.map((e) => ModelInfo.toJSON(e));
    }
    if (message.error !== undefined) {
      obj.error = AIError.toJSON(message.error);
    }
    return obj;
  },

  create(base?: DeepPartial<GetProviderModelsResponse>): GetProviderModelsResponse {
    return GetProviderModelsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetProviderModelsResponse>): GetProviderModelsResponse {
    const message = createBaseGetProviderModelsResponse();
    message.models = object.models?.map((e) => ModelInfo.fromPartial(e)) || [];
    message.error = (object.error !== undefined && object.error !== null)
      ? AIError.fromPartial(object.error)
      : undefined;
    return message;
  },
};

function createBaseTestProviderRequest(): TestProviderRequest {
  return {
    provider: Provider.PROVIDER_UNSPECIFIED,
    openaiConfig: undefined,
    anthropicConfig: undefined,
    ollamaConfig: undefined,
    huggingfaceConfig: undefined,
    claudecodeConfig: undefined,
    codexConfig: undefined,
  };
}

export const TestProviderRequest: MessageFns<TestProviderRequest> = {
  encode(message: TestProviderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.provider !== Provider.PROVIDER_UNSPECIFIED) {
      writer.uint32(8).int32(providerToNumber(message.provider));
    }
    if (message.openaiConfig !== undefined) {
      OpenAIConfig.encode(message.openaiConfig, writer.uint32(18).fork()).join();
    }
    if (message.anthropicConfig !== undefined) {
      AnthropicConfig.encode(message.anthropicConfig, writer.uint32(26).fork()).join();
    }
    if (message.ollamaConfig !== undefined) {
      OllamaConfig.encode(message.ollamaConfig, writer.uint32(34).fork()).join();
    }
    if (message.huggingfaceConfig !== undefined) {
      HuggingFaceConfig.encode(message.huggingfaceConfig, writer.uint32(42).fork()).join();
    }
    if (message.claudecodeConfig !== undefined) {
      ClaudeCodeConfig.encode(message.claudecodeConfig, writer.uint32(50).fork()).join();
    }
    if (message.codexConfig !== undefined) {
      CodexConfig.encode(message.codexConfig, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TestProviderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestProviderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.provider = providerFromJSON(reader.int32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.openaiConfig = OpenAIConfig.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.anthropicConfig = AnthropicConfig.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.ollamaConfig = OllamaConfig.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.huggingfaceConfig = HuggingFaceConfig.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.claudecodeConfig = ClaudeCodeConfig.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.codexConfig = CodexConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TestProviderRequest {
    return {
      provider: isSet(object.provider) ? providerFromJSON(object.provider) : Provider.PROVIDER_UNSPECIFIED,
      openaiConfig: isSet(object.openaiConfig) ? OpenAIConfig.fromJSON(object.openaiConfig) : undefined,
      anthropicConfig: isSet(object.anthropicConfig) ? AnthropicConfig.fromJSON(object.anthropicConfig) : undefined,
      ollamaConfig: isSet(object.ollamaConfig) ? OllamaConfig.fromJSON(object.ollamaConfig) : undefined,
      huggingfaceConfig: isSet(object.huggingfaceConfig)
        ? HuggingFaceConfig.fromJSON(object.huggingfaceConfig)
        : undefined,
      claudecodeConfig: isSet(object.claudecodeConfig) ? ClaudeCodeConfig.fromJSON(object.claudecodeConfig) : undefined,
      codexConfig: isSet(object.codexConfig) ? CodexConfig.fromJSON(object.codexConfig) : undefined,
    };
  },

  toJSON(message: TestProviderRequest): unknown {
    const obj: any = {};
    if (message.provider !== Provider.PROVIDER_UNSPECIFIED) {
      obj.provider = providerToJSON(message.provider);
    }
    if (message.openaiConfig !== undefined) {
      obj.openaiConfig = OpenAIConfig.toJSON(message.openaiConfig);
    }
    if (message.anthropicConfig !== undefined) {
      obj.anthropicConfig = AnthropicConfig.toJSON(message.anthropicConfig);
    }
    if (message.ollamaConfig !== undefined) {
      obj.ollamaConfig = OllamaConfig.toJSON(message.ollamaConfig);
    }
    if (message.huggingfaceConfig !== undefined) {
      obj.huggingfaceConfig = HuggingFaceConfig.toJSON(message.huggingfaceConfig);
    }
    if (message.claudecodeConfig !== undefined) {
      obj.claudecodeConfig = ClaudeCodeConfig.toJSON(message.claudecodeConfig);
    }
    if (message.codexConfig !== undefined) {
      obj.codexConfig = CodexConfig.toJSON(message.codexConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<TestProviderRequest>): TestProviderRequest {
    return TestProviderRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TestProviderRequest>): TestProviderRequest {
    const message = createBaseTestProviderRequest();
    message.provider = object.provider ?? Provider.PROVIDER_UNSPECIFIED;
    message.openaiConfig = (object.openaiConfig !== undefined && object.openaiConfig !== null)
      ? OpenAIConfig.fromPartial(object.openaiConfig)
      : undefined;
    message.anthropicConfig = (object.anthropicConfig !== undefined && object.anthropicConfig !== null)
      ? AnthropicConfig.fromPartial(object.anthropicConfig)
      : undefined;
    message.ollamaConfig = (object.ollamaConfig !== undefined && object.ollamaConfig !== null)
      ? OllamaConfig.fromPartial(object.ollamaConfig)
      : undefined;
    message.huggingfaceConfig = (object.huggingfaceConfig !== undefined && object.huggingfaceConfig !== null)
      ? HuggingFaceConfig.fromPartial(object.huggingfaceConfig)
      : undefined;
    message.claudecodeConfig = (object.claudecodeConfig !== undefined && object.claudecodeConfig !== null)
      ? ClaudeCodeConfig.fromPartial(object.claudecodeConfig)
      : undefined;
    message.codexConfig = (object.codexConfig !== undefined && object.codexConfig !== null)
      ? CodexConfig.fromPartial(object.codexConfig)
      : undefined;
    return message;
  },
};

function createBaseTestProviderResponse(): TestProviderResponse {
  return { success: false, message: "", error: undefined };
}

export const TestProviderResponse: MessageFns<TestProviderResponse> = {
  encode(message: TestProviderResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.error !== undefined) {
      AIError.encode(message.error, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TestProviderResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestProviderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = AIError.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TestProviderResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      error: isSet(object.error) ? AIError.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: TestProviderResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.error !== undefined) {
      obj.error = AIError.toJSON(message.error);
    }
    return obj;
  },

  create(base?: DeepPartial<TestProviderResponse>): TestProviderResponse {
    return TestProviderResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TestProviderResponse>): TestProviderResponse {
    const message = createBaseTestProviderResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.error = (object.error !== undefined && object.error !== null)
      ? AIError.fromPartial(object.error)
      : undefined;
    return message;
  },
};

function createBaseGetUsageStatsRequest(): GetUsageStatsRequest {
  return { provider: Provider.PROVIDER_UNSPECIFIED };
}

export const GetUsageStatsRequest: MessageFns<GetUsageStatsRequest> = {
  encode(message: GetUsageStatsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.provider !== Provider.PROVIDER_UNSPECIFIED) {
      writer.uint32(8).int32(providerToNumber(message.provider));
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUsageStatsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUsageStatsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.provider = providerFromJSON(reader.int32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUsageStatsRequest {
    return { provider: isSet(object.provider) ? providerFromJSON(object.provider) : Provider.PROVIDER_UNSPECIFIED };
  },

  toJSON(message: GetUsageStatsRequest): unknown {
    const obj: any = {};
    if (message.provider !== Provider.PROVIDER_UNSPECIFIED) {
      obj.provider = providerToJSON(message.provider);
    }
    return obj;
  },

  create(base?: DeepPartial<GetUsageStatsRequest>): GetUsageStatsRequest {
    return GetUsageStatsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetUsageStatsRequest>): GetUsageStatsRequest {
    const message = createBaseGetUsageStatsRequest();
    message.provider = object.provider ?? Provider.PROVIDER_UNSPECIFIED;
    return message;
  },
};

function createBaseGetUsageStatsResponse(): GetUsageStatsResponse {
  return { usageStats: {}, error: undefined };
}

export const GetUsageStatsResponse: MessageFns<GetUsageStatsResponse> = {
  encode(message: GetUsageStatsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.usageStats).forEach(([key, value]) => {
      GetUsageStatsResponse_UsageStatsEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    if (message.error !== undefined) {
      AIError.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUsageStatsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUsageStatsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = GetUsageStatsResponse_UsageStatsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.usageStats[entry1.key] = entry1.value;
          }
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = AIError.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUsageStatsResponse {
    return {
      usageStats: isObject(object.usageStats)
        ? Object.entries(object.usageStats).reduce<{ [key: string]: Usage }>((acc, [key, value]) => {
          acc[key] = Usage.fromJSON(value);
          return acc;
        }, {})
        : {},
      error: isSet(object.error) ? AIError.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: GetUsageStatsResponse): unknown {
    const obj: any = {};
    if (message.usageStats) {
      const entries = Object.entries(message.usageStats);
      if (entries.length > 0) {
        obj.usageStats = {};
        entries.forEach(([k, v]) => {
          obj.usageStats[k] = Usage.toJSON(v);
        });
      }
    }
    if (message.error !== undefined) {
      obj.error = AIError.toJSON(message.error);
    }
    return obj;
  },

  create(base?: DeepPartial<GetUsageStatsResponse>): GetUsageStatsResponse {
    return GetUsageStatsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetUsageStatsResponse>): GetUsageStatsResponse {
    const message = createBaseGetUsageStatsResponse();
    message.usageStats = Object.entries(object.usageStats ?? {}).reduce<{ [key: string]: Usage }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = Usage.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.error = (object.error !== undefined && object.error !== null)
      ? AIError.fromPartial(object.error)
      : undefined;
    return message;
  },
};

function createBaseGetUsageStatsResponse_UsageStatsEntry(): GetUsageStatsResponse_UsageStatsEntry {
  return { key: "", value: undefined };
}

export const GetUsageStatsResponse_UsageStatsEntry: MessageFns<GetUsageStatsResponse_UsageStatsEntry> = {
  encode(message: GetUsageStatsResponse_UsageStatsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Usage.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUsageStatsResponse_UsageStatsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUsageStatsResponse_UsageStatsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Usage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUsageStatsResponse_UsageStatsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Usage.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: GetUsageStatsResponse_UsageStatsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Usage.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<GetUsageStatsResponse_UsageStatsEntry>): GetUsageStatsResponse_UsageStatsEntry {
    return GetUsageStatsResponse_UsageStatsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetUsageStatsResponse_UsageStatsEntry>): GetUsageStatsResponse_UsageStatsEntry {
    const message = createBaseGetUsageStatsResponse_UsageStatsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Usage.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseGetConfigRequest(): GetConfigRequest {
  return {};
}

export const GetConfigRequest: MessageFns<GetConfigRequest> = {
  encode(_: GetConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetConfigRequest {
    return {};
  },

  toJSON(_: GetConfigRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<GetConfigRequest>): GetConfigRequest {
    return GetConfigRequest.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<GetConfigRequest>): GetConfigRequest {
    const message = createBaseGetConfigRequest();
    return message;
  },
};

function createBaseGetConfigResponse(): GetConfigResponse {
  return { config: undefined };
}

export const GetConfigResponse: MessageFns<GetConfigResponse> = {
  encode(message: GetConfigResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.config !== undefined) {
      AIConfig.encode(message.config, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetConfigResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetConfigResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.config = AIConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetConfigResponse {
    return { config: isSet(object.config) ? AIConfig.fromJSON(object.config) : undefined };
  },

  toJSON(message: GetConfigResponse): unknown {
    const obj: any = {};
    if (message.config !== undefined) {
      obj.config = AIConfig.toJSON(message.config);
    }
    return obj;
  },

  create(base?: DeepPartial<GetConfigResponse>): GetConfigResponse {
    return GetConfigResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetConfigResponse>): GetConfigResponse {
    const message = createBaseGetConfigResponse();
    message.config = (object.config !== undefined && object.config !== null)
      ? AIConfig.fromPartial(object.config)
      : undefined;
    return message;
  },
};

function createBaseAIConfig(): AIConfig {
  return {
    defaultProvider: Provider.PROVIDER_UNSPECIFIED,
    maxTokens: 0,
    temperature: 0,
    requestTimeout: undefined,
    rateLimitPerMin: 0,
    openai: undefined,
    anthropic: undefined,
    ollama: undefined,
    huggingface: undefined,
    claudecode: undefined,
    codex: undefined,
  };
}

export const AIConfig: MessageFns<AIConfig> = {
  encode(message: AIConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.defaultProvider !== Provider.PROVIDER_UNSPECIFIED) {
      writer.uint32(8).int32(providerToNumber(message.defaultProvider));
    }
    if (message.maxTokens !== 0) {
      writer.uint32(16).int32(message.maxTokens);
    }
    if (message.temperature !== 0) {
      writer.uint32(25).double(message.temperature);
    }
    if (message.requestTimeout !== undefined) {
      Duration.encode(message.requestTimeout, writer.uint32(34).fork()).join();
    }
    if (message.rateLimitPerMin !== 0) {
      writer.uint32(40).int32(message.rateLimitPerMin);
    }
    if (message.openai !== undefined) {
      OpenAIConfig.encode(message.openai, writer.uint32(50).fork()).join();
    }
    if (message.anthropic !== undefined) {
      AnthropicConfig.encode(message.anthropic, writer.uint32(58).fork()).join();
    }
    if (message.ollama !== undefined) {
      OllamaConfig.encode(message.ollama, writer.uint32(66).fork()).join();
    }
    if (message.huggingface !== undefined) {
      HuggingFaceConfig.encode(message.huggingface, writer.uint32(74).fork()).join();
    }
    if (message.claudecode !== undefined) {
      ClaudeCodeConfig.encode(message.claudecode, writer.uint32(82).fork()).join();
    }
    if (message.codex !== undefined) {
      CodexConfig.encode(message.codex, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AIConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAIConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.defaultProvider = providerFromJSON(reader.int32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.maxTokens = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.temperature = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.requestTimeout = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.rateLimitPerMin = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.openai = OpenAIConfig.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.anthropic = AnthropicConfig.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.ollama = OllamaConfig.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.huggingface = HuggingFaceConfig.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.claudecode = ClaudeCodeConfig.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.codex = CodexConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AIConfig {
    return {
      defaultProvider: isSet(object.defaultProvider)
        ? providerFromJSON(object.defaultProvider)
        : Provider.PROVIDER_UNSPECIFIED,
      maxTokens: isSet(object.maxTokens) ? globalThis.Number(object.maxTokens) : 0,
      temperature: isSet(object.temperature) ? globalThis.Number(object.temperature) : 0,
      requestTimeout: isSet(object.requestTimeout) ? Duration.fromJSON(object.requestTimeout) : undefined,
      rateLimitPerMin: isSet(object.rateLimitPerMin) ? globalThis.Number(object.rateLimitPerMin) : 0,
      openai: isSet(object.openai) ? OpenAIConfig.fromJSON(object.openai) : undefined,
      anthropic: isSet(object.anthropic) ? AnthropicConfig.fromJSON(object.anthropic) : undefined,
      ollama: isSet(object.ollama) ? OllamaConfig.fromJSON(object.ollama) : undefined,
      huggingface: isSet(object.huggingface) ? HuggingFaceConfig.fromJSON(object.huggingface) : undefined,
      claudecode: isSet(object.claudecode) ? ClaudeCodeConfig.fromJSON(object.claudecode) : undefined,
      codex: isSet(object.codex) ? CodexConfig.fromJSON(object.codex) : undefined,
    };
  },

  toJSON(message: AIConfig): unknown {
    const obj: any = {};
    if (message.defaultProvider !== Provider.PROVIDER_UNSPECIFIED) {
      obj.defaultProvider = providerToJSON(message.defaultProvider);
    }
    if (message.maxTokens !== 0) {
      obj.maxTokens = Math.round(message.maxTokens);
    }
    if (message.temperature !== 0) {
      obj.temperature = message.temperature;
    }
    if (message.requestTimeout !== undefined) {
      obj.requestTimeout = Duration.toJSON(message.requestTimeout);
    }
    if (message.rateLimitPerMin !== 0) {
      obj.rateLimitPerMin = Math.round(message.rateLimitPerMin);
    }
    if (message.openai !== undefined) {
      obj.openai = OpenAIConfig.toJSON(message.openai);
    }
    if (message.anthropic !== undefined) {
      obj.anthropic = AnthropicConfig.toJSON(message.anthropic);
    }
    if (message.ollama !== undefined) {
      obj.ollama = OllamaConfig.toJSON(message.ollama);
    }
    if (message.huggingface !== undefined) {
      obj.huggingface = HuggingFaceConfig.toJSON(message.huggingface);
    }
    if (message.claudecode !== undefined) {
      obj.claudecode = ClaudeCodeConfig.toJSON(message.claudecode);
    }
    if (message.codex !== undefined) {
      obj.codex = CodexConfig.toJSON(message.codex);
    }
    return obj;
  },

  create(base?: DeepPartial<AIConfig>): AIConfig {
    return AIConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AIConfig>): AIConfig {
    const message = createBaseAIConfig();
    message.defaultProvider = object.defaultProvider ?? Provider.PROVIDER_UNSPECIFIED;
    message.maxTokens = object.maxTokens ?? 0;
    message.temperature = object.temperature ?? 0;
    message.requestTimeout = (object.requestTimeout !== undefined && object.requestTimeout !== null)
      ? Duration.fromPartial(object.requestTimeout)
      : undefined;
    message.rateLimitPerMin = object.rateLimitPerMin ?? 0;
    message.openai = (object.openai !== undefined && object.openai !== null)
      ? OpenAIConfig.fromPartial(object.openai)
      : undefined;
    message.anthropic = (object.anthropic !== undefined && object.anthropic !== null)
      ? AnthropicConfig.fromPartial(object.anthropic)
      : undefined;
    message.ollama = (object.ollama !== undefined && object.ollama !== null)
      ? OllamaConfig.fromPartial(object.ollama)
      : undefined;
    message.huggingface = (object.huggingface !== undefined && object.huggingface !== null)
      ? HuggingFaceConfig.fromPartial(object.huggingface)
      : undefined;
    message.claudecode = (object.claudecode !== undefined && object.claudecode !== null)
      ? ClaudeCodeConfig.fromPartial(object.claudecode)
      : undefined;
    message.codex = (object.codex !== undefined && object.codex !== null)
      ? CodexConfig.fromPartial(object.codex)
      : undefined;
    return message;
  },
};

function createBaseOpenAIConfig(): OpenAIConfig {
  return { apiKey: "", baseUrl: "", models: [], orgId: "", configured: false };
}

export const OpenAIConfig: MessageFns<OpenAIConfig> = {
  encode(message: OpenAIConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.apiKey !== "") {
      writer.uint32(10).string(message.apiKey);
    }
    if (message.baseUrl !== "") {
      writer.uint32(18).string(message.baseUrl);
    }
    for (const v of message.models) {
      writer.uint32(26).string(v!);
    }
    if (message.orgId !== "") {
      writer.uint32(34).string(message.orgId);
    }
    if (message.configured !== false) {
      writer.uint32(40).bool(message.configured);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OpenAIConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOpenAIConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.apiKey = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.baseUrl = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.models.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.orgId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.configured = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OpenAIConfig {
    return {
      apiKey: isSet(object.apiKey) ? globalThis.String(object.apiKey) : "",
      baseUrl: isSet(object.baseUrl) ? globalThis.String(object.baseUrl) : "",
      models: globalThis.Array.isArray(object?.models) ? object.models.map((e: any) => globalThis.String(e)) : [],
      orgId: isSet(object.orgId) ? globalThis.String(object.orgId) : "",
      configured: isSet(object.configured) ? globalThis.Boolean(object.configured) : false,
    };
  },

  toJSON(message: OpenAIConfig): unknown {
    const obj: any = {};
    if (message.apiKey !== "") {
      obj.apiKey = message.apiKey;
    }
    if (message.baseUrl !== "") {
      obj.baseUrl = message.baseUrl;
    }
    if (message.models?.length) {
      obj.models = message.models;
    }
    if (message.orgId !== "") {
      obj.orgId = message.orgId;
    }
    if (message.configured !== false) {
      obj.configured = message.configured;
    }
    return obj;
  },

  create(base?: DeepPartial<OpenAIConfig>): OpenAIConfig {
    return OpenAIConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OpenAIConfig>): OpenAIConfig {
    const message = createBaseOpenAIConfig();
    message.apiKey = object.apiKey ?? "";
    message.baseUrl = object.baseUrl ?? "";
    message.models = object.models?.map((e) => e) || [];
    message.orgId = object.orgId ?? "";
    message.configured = object.configured ?? false;
    return message;
  },
};

function createBaseAnthropicConfig(): AnthropicConfig {
  return { apiKey: "", baseUrl: "", version: "", models: [], configured: false };
}

export const AnthropicConfig: MessageFns<AnthropicConfig> = {
  encode(message: AnthropicConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.apiKey !== "") {
      writer.uint32(10).string(message.apiKey);
    }
    if (message.baseUrl !== "") {
      writer.uint32(18).string(message.baseUrl);
    }
    if (message.version !== "") {
      writer.uint32(26).string(message.version);
    }
    for (const v of message.models) {
      writer.uint32(34).string(v!);
    }
    if (message.configured !== false) {
      writer.uint32(40).bool(message.configured);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnthropicConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnthropicConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.apiKey = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.baseUrl = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.models.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.configured = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnthropicConfig {
    return {
      apiKey: isSet(object.apiKey) ? globalThis.String(object.apiKey) : "",
      baseUrl: isSet(object.baseUrl) ? globalThis.String(object.baseUrl) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      models: globalThis.Array.isArray(object?.models) ? object.models.map((e: any) => globalThis.String(e)) : [],
      configured: isSet(object.configured) ? globalThis.Boolean(object.configured) : false,
    };
  },

  toJSON(message: AnthropicConfig): unknown {
    const obj: any = {};
    if (message.apiKey !== "") {
      obj.apiKey = message.apiKey;
    }
    if (message.baseUrl !== "") {
      obj.baseUrl = message.baseUrl;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.models?.length) {
      obj.models = message.models;
    }
    if (message.configured !== false) {
      obj.configured = message.configured;
    }
    return obj;
  },

  create(base?: DeepPartial<AnthropicConfig>): AnthropicConfig {
    return AnthropicConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AnthropicConfig>): AnthropicConfig {
    const message = createBaseAnthropicConfig();
    message.apiKey = object.apiKey ?? "";
    message.baseUrl = object.baseUrl ?? "";
    message.version = object.version ?? "";
    message.models = object.models?.map((e) => e) || [];
    message.configured = object.configured ?? false;
    return message;
  },
};

function createBaseOllamaConfig(): OllamaConfig {
  return {
    endpoint: "",
    models: [],
    pullTimeout: undefined,
    generateTimeout: undefined,
    autoPullModels: false,
    configured: false,
  };
}

export const OllamaConfig: MessageFns<OllamaConfig> = {
  encode(message: OllamaConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.endpoint !== "") {
      writer.uint32(10).string(message.endpoint);
    }
    for (const v of message.models) {
      writer.uint32(18).string(v!);
    }
    if (message.pullTimeout !== undefined) {
      Duration.encode(message.pullTimeout, writer.uint32(26).fork()).join();
    }
    if (message.generateTimeout !== undefined) {
      Duration.encode(message.generateTimeout, writer.uint32(34).fork()).join();
    }
    if (message.autoPullModels !== false) {
      writer.uint32(40).bool(message.autoPullModels);
    }
    if (message.configured !== false) {
      writer.uint32(48).bool(message.configured);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OllamaConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOllamaConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.endpoint = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.models.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pullTimeout = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.generateTimeout = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.autoPullModels = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.configured = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OllamaConfig {
    return {
      endpoint: isSet(object.endpoint) ? globalThis.String(object.endpoint) : "",
      models: globalThis.Array.isArray(object?.models) ? object.models.map((e: any) => globalThis.String(e)) : [],
      pullTimeout: isSet(object.pullTimeout) ? Duration.fromJSON(object.pullTimeout) : undefined,
      generateTimeout: isSet(object.generateTimeout) ? Duration.fromJSON(object.generateTimeout) : undefined,
      autoPullModels: isSet(object.autoPullModels) ? globalThis.Boolean(object.autoPullModels) : false,
      configured: isSet(object.configured) ? globalThis.Boolean(object.configured) : false,
    };
  },

  toJSON(message: OllamaConfig): unknown {
    const obj: any = {};
    if (message.endpoint !== "") {
      obj.endpoint = message.endpoint;
    }
    if (message.models?.length) {
      obj.models = message.models;
    }
    if (message.pullTimeout !== undefined) {
      obj.pullTimeout = Duration.toJSON(message.pullTimeout);
    }
    if (message.generateTimeout !== undefined) {
      obj.generateTimeout = Duration.toJSON(message.generateTimeout);
    }
    if (message.autoPullModels !== false) {
      obj.autoPullModels = message.autoPullModels;
    }
    if (message.configured !== false) {
      obj.configured = message.configured;
    }
    return obj;
  },

  create(base?: DeepPartial<OllamaConfig>): OllamaConfig {
    return OllamaConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OllamaConfig>): OllamaConfig {
    const message = createBaseOllamaConfig();
    message.endpoint = object.endpoint ?? "";
    message.models = object.models?.map((e) => e) || [];
    message.pullTimeout = (object.pullTimeout !== undefined && object.pullTimeout !== null)
      ? Duration.fromPartial(object.pullTimeout)
      : undefined;
    message.generateTimeout = (object.generateTimeout !== undefined && object.generateTimeout !== null)
      ? Duration.fromPartial(object.generateTimeout)
      : undefined;
    message.autoPullModels = object.autoPullModels ?? false;
    message.configured = object.configured ?? false;
    return message;
  },
};

function createBaseHuggingFaceConfig(): HuggingFaceConfig {
  return {
    endpoint: "",
    models: [],
    pullTimeout: undefined,
    generateTimeout: undefined,
    autoPullModels: false,
    recommendedModel: "",
    configured: false,
  };
}

export const HuggingFaceConfig: MessageFns<HuggingFaceConfig> = {
  encode(message: HuggingFaceConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.endpoint !== "") {
      writer.uint32(10).string(message.endpoint);
    }
    for (const v of message.models) {
      writer.uint32(18).string(v!);
    }
    if (message.pullTimeout !== undefined) {
      Duration.encode(message.pullTimeout, writer.uint32(26).fork()).join();
    }
    if (message.generateTimeout !== undefined) {
      Duration.encode(message.generateTimeout, writer.uint32(34).fork()).join();
    }
    if (message.autoPullModels !== false) {
      writer.uint32(40).bool(message.autoPullModels);
    }
    if (message.recommendedModel !== "") {
      writer.uint32(50).string(message.recommendedModel);
    }
    if (message.configured !== false) {
      writer.uint32(56).bool(message.configured);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HuggingFaceConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHuggingFaceConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.endpoint = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.models.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pullTimeout = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.generateTimeout = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.autoPullModels = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.recommendedModel = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.configured = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HuggingFaceConfig {
    return {
      endpoint: isSet(object.endpoint) ? globalThis.String(object.endpoint) : "",
      models: globalThis.Array.isArray(object?.models) ? object.models.map((e: any) => globalThis.String(e)) : [],
      pullTimeout: isSet(object.pullTimeout) ? Duration.fromJSON(object.pullTimeout) : undefined,
      generateTimeout: isSet(object.generateTimeout) ? Duration.fromJSON(object.generateTimeout) : undefined,
      autoPullModels: isSet(object.autoPullModels) ? globalThis.Boolean(object.autoPullModels) : false,
      recommendedModel: isSet(object.recommendedModel) ? globalThis.String(object.recommendedModel) : "",
      configured: isSet(object.configured) ? globalThis.Boolean(object.configured) : false,
    };
  },

  toJSON(message: HuggingFaceConfig): unknown {
    const obj: any = {};
    if (message.endpoint !== "") {
      obj.endpoint = message.endpoint;
    }
    if (message.models?.length) {
      obj.models = message.models;
    }
    if (message.pullTimeout !== undefined) {
      obj.pullTimeout = Duration.toJSON(message.pullTimeout);
    }
    if (message.generateTimeout !== undefined) {
      obj.generateTimeout = Duration.toJSON(message.generateTimeout);
    }
    if (message.autoPullModels !== false) {
      obj.autoPullModels = message.autoPullModels;
    }
    if (message.recommendedModel !== "") {
      obj.recommendedModel = message.recommendedModel;
    }
    if (message.configured !== false) {
      obj.configured = message.configured;
    }
    return obj;
  },

  create(base?: DeepPartial<HuggingFaceConfig>): HuggingFaceConfig {
    return HuggingFaceConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HuggingFaceConfig>): HuggingFaceConfig {
    const message = createBaseHuggingFaceConfig();
    message.endpoint = object.endpoint ?? "";
    message.models = object.models?.map((e) => e) || [];
    message.pullTimeout = (object.pullTimeout !== undefined && object.pullTimeout !== null)
      ? Duration.fromPartial(object.pullTimeout)
      : undefined;
    message.generateTimeout = (object.generateTimeout !== undefined && object.generateTimeout !== null)
      ? Duration.fromPartial(object.generateTimeout)
      : undefined;
    message.autoPullModels = object.autoPullModels ?? false;
    message.recommendedModel = object.recommendedModel ?? "";
    message.configured = object.configured ?? false;
    return message;
  },
};

function createBaseClaudeCodeConfig(): ClaudeCodeConfig {
  return { apiKey: "", baseUrl: "", models: [], maxTokens: 0, temperature: 0, configured: false };
}

export const ClaudeCodeConfig: MessageFns<ClaudeCodeConfig> = {
  encode(message: ClaudeCodeConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.apiKey !== "") {
      writer.uint32(10).string(message.apiKey);
    }
    if (message.baseUrl !== "") {
      writer.uint32(18).string(message.baseUrl);
    }
    for (const v of message.models) {
      writer.uint32(26).string(v!);
    }
    if (message.maxTokens !== 0) {
      writer.uint32(32).int32(message.maxTokens);
    }
    if (message.temperature !== 0) {
      writer.uint32(41).double(message.temperature);
    }
    if (message.configured !== false) {
      writer.uint32(48).bool(message.configured);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClaudeCodeConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClaudeCodeConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.apiKey = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.baseUrl = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.models.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.maxTokens = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }

          message.temperature = reader.double();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.configured = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClaudeCodeConfig {
    return {
      apiKey: isSet(object.apiKey) ? globalThis.String(object.apiKey) : "",
      baseUrl: isSet(object.baseUrl) ? globalThis.String(object.baseUrl) : "",
      models: globalThis.Array.isArray(object?.models) ? object.models.map((e: any) => globalThis.String(e)) : [],
      maxTokens: isSet(object.maxTokens) ? globalThis.Number(object.maxTokens) : 0,
      temperature: isSet(object.temperature) ? globalThis.Number(object.temperature) : 0,
      configured: isSet(object.configured) ? globalThis.Boolean(object.configured) : false,
    };
  },

  toJSON(message: ClaudeCodeConfig): unknown {
    const obj: any = {};
    if (message.apiKey !== "") {
      obj.apiKey = message.apiKey;
    }
    if (message.baseUrl !== "") {
      obj.baseUrl = message.baseUrl;
    }
    if (message.models?.length) {
      obj.models = message.models;
    }
    if (message.maxTokens !== 0) {
      obj.maxTokens = Math.round(message.maxTokens);
    }
    if (message.temperature !== 0) {
      obj.temperature = message.temperature;
    }
    if (message.configured !== false) {
      obj.configured = message.configured;
    }
    return obj;
  },

  create(base?: DeepPartial<ClaudeCodeConfig>): ClaudeCodeConfig {
    return ClaudeCodeConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ClaudeCodeConfig>): ClaudeCodeConfig {
    const message = createBaseClaudeCodeConfig();
    message.apiKey = object.apiKey ?? "";
    message.baseUrl = object.baseUrl ?? "";
    message.models = object.models?.map((e) => e) || [];
    message.maxTokens = object.maxTokens ?? 0;
    message.temperature = object.temperature ?? 0;
    message.configured = object.configured ?? false;
    return message;
  },
};

function createBaseCodexConfig(): CodexConfig {
  return { apiKey: "", organization: "", baseUrl: "", models: [], maxTokens: 0, temperature: 0, configured: false };
}

export const CodexConfig: MessageFns<CodexConfig> = {
  encode(message: CodexConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.apiKey !== "") {
      writer.uint32(10).string(message.apiKey);
    }
    if (message.organization !== "") {
      writer.uint32(18).string(message.organization);
    }
    if (message.baseUrl !== "") {
      writer.uint32(26).string(message.baseUrl);
    }
    for (const v of message.models) {
      writer.uint32(34).string(v!);
    }
    if (message.maxTokens !== 0) {
      writer.uint32(40).int32(message.maxTokens);
    }
    if (message.temperature !== 0) {
      writer.uint32(53).float(message.temperature);
    }
    if (message.configured !== false) {
      writer.uint32(56).bool(message.configured);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CodexConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCodexConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.apiKey = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organization = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.baseUrl = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.models.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.maxTokens = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 53) {
            break;
          }

          message.temperature = reader.float();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.configured = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CodexConfig {
    return {
      apiKey: isSet(object.apiKey) ? globalThis.String(object.apiKey) : "",
      organization: isSet(object.organization) ? globalThis.String(object.organization) : "",
      baseUrl: isSet(object.baseUrl) ? globalThis.String(object.baseUrl) : "",
      models: globalThis.Array.isArray(object?.models) ? object.models.map((e: any) => globalThis.String(e)) : [],
      maxTokens: isSet(object.maxTokens) ? globalThis.Number(object.maxTokens) : 0,
      temperature: isSet(object.temperature) ? globalThis.Number(object.temperature) : 0,
      configured: isSet(object.configured) ? globalThis.Boolean(object.configured) : false,
    };
  },

  toJSON(message: CodexConfig): unknown {
    const obj: any = {};
    if (message.apiKey !== "") {
      obj.apiKey = message.apiKey;
    }
    if (message.organization !== "") {
      obj.organization = message.organization;
    }
    if (message.baseUrl !== "") {
      obj.baseUrl = message.baseUrl;
    }
    if (message.models?.length) {
      obj.models = message.models;
    }
    if (message.maxTokens !== 0) {
      obj.maxTokens = Math.round(message.maxTokens);
    }
    if (message.temperature !== 0) {
      obj.temperature = message.temperature;
    }
    if (message.configured !== false) {
      obj.configured = message.configured;
    }
    return obj;
  },

  create(base?: DeepPartial<CodexConfig>): CodexConfig {
    return CodexConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CodexConfig>): CodexConfig {
    const message = createBaseCodexConfig();
    message.apiKey = object.apiKey ?? "";
    message.organization = object.organization ?? "";
    message.baseUrl = object.baseUrl ?? "";
    message.models = object.models?.map((e) => e) || [];
    message.maxTokens = object.maxTokens ?? 0;
    message.temperature = object.temperature ?? 0;
    message.configured = object.configured ?? false;
    return message;
  },
};

/** AI service definition */
export type AIServiceDefinition = typeof AIServiceDefinition;
export const AIServiceDefinition = {
  name: "AIService",
  fullName: "ai.AIService",
  methods: {
    /** Generate SQL from natural language */
    generateSQL: {
      name: "GenerateSQL",
      requestType: GenerateSQLRequest,
      requestStream: false,
      responseType: GenerateSQLResponse,
      responseStream: false,
      options: {},
    },
    /** Fix SQL based on error message */
    fixSQL: {
      name: "FixSQL",
      requestType: FixSQLRequest,
      requestStream: false,
      responseType: FixSQLResponse,
      responseStream: false,
      options: {},
    },
    /** Get available providers */
    getProviders: {
      name: "GetProviders",
      requestType: GetProvidersRequest,
      requestStream: false,
      responseType: GetProvidersResponse,
      responseStream: false,
      options: {},
    },
    /** Get provider health status */
    getProviderHealth: {
      name: "GetProviderHealth",
      requestType: GetProviderHealthRequest,
      requestStream: false,
      responseType: ProviderHealthResponse,
      responseStream: false,
      options: {},
    },
    /** Get available models for a provider */
    getProviderModels: {
      name: "GetProviderModels",
      requestType: GetProviderModelsRequest,
      requestStream: false,
      responseType: GetProviderModelsResponse,
      responseStream: false,
      options: {},
    },
    /** Test provider configuration */
    testProvider: {
      name: "TestProvider",
      requestType: TestProviderRequest,
      requestStream: false,
      responseType: TestProviderResponse,
      responseStream: false,
      options: {},
    },
    /** Get usage statistics */
    getUsageStats: {
      name: "GetUsageStats",
      requestType: GetUsageStatsRequest,
      requestStream: false,
      responseType: GetUsageStatsResponse,
      responseStream: false,
      options: {},
    },
    /** Get AI service configuration */
    getConfig: {
      name: "GetConfig",
      requestType: GetConfigRequest,
      requestStream: false,
      responseType: GetConfigResponse,
      responseStream: false,
      options: {},
    },
  },
} as const;

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
