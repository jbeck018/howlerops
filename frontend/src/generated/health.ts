// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.1
//   protoc               v5.29.3
// source: health.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "./google/protobuf/timestamp";

export const protobufPackage = "sqlstudio.health";

/** Health status */
export enum HealthStatus {
  HEALTH_STATUS_UNSPECIFIED = "HEALTH_STATUS_UNSPECIFIED",
  HEALTH_STATUS_SERVING = "HEALTH_STATUS_SERVING",
  HEALTH_STATUS_NOT_SERVING = "HEALTH_STATUS_NOT_SERVING",
  HEALTH_STATUS_DEGRADED = "HEALTH_STATUS_DEGRADED",
  HEALTH_STATUS_UNKNOWN = "HEALTH_STATUS_UNKNOWN",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function healthStatusFromJSON(object: any): HealthStatus {
  switch (object) {
    case 0:
    case "HEALTH_STATUS_UNSPECIFIED":
      return HealthStatus.HEALTH_STATUS_UNSPECIFIED;
    case 1:
    case "HEALTH_STATUS_SERVING":
      return HealthStatus.HEALTH_STATUS_SERVING;
    case 2:
    case "HEALTH_STATUS_NOT_SERVING":
      return HealthStatus.HEALTH_STATUS_NOT_SERVING;
    case 3:
    case "HEALTH_STATUS_DEGRADED":
      return HealthStatus.HEALTH_STATUS_DEGRADED;
    case 4:
    case "HEALTH_STATUS_UNKNOWN":
      return HealthStatus.HEALTH_STATUS_UNKNOWN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return HealthStatus.UNRECOGNIZED;
  }
}

export function healthStatusToJSON(object: HealthStatus): string {
  switch (object) {
    case HealthStatus.HEALTH_STATUS_UNSPECIFIED:
      return "HEALTH_STATUS_UNSPECIFIED";
    case HealthStatus.HEALTH_STATUS_SERVING:
      return "HEALTH_STATUS_SERVING";
    case HealthStatus.HEALTH_STATUS_NOT_SERVING:
      return "HEALTH_STATUS_NOT_SERVING";
    case HealthStatus.HEALTH_STATUS_DEGRADED:
      return "HEALTH_STATUS_DEGRADED";
    case HealthStatus.HEALTH_STATUS_UNKNOWN:
      return "HEALTH_STATUS_UNKNOWN";
    case HealthStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function healthStatusToNumber(object: HealthStatus): number {
  switch (object) {
    case HealthStatus.HEALTH_STATUS_UNSPECIFIED:
      return 0;
    case HealthStatus.HEALTH_STATUS_SERVING:
      return 1;
    case HealthStatus.HEALTH_STATUS_NOT_SERVING:
      return 2;
    case HealthStatus.HEALTH_STATUS_DEGRADED:
      return 3;
    case HealthStatus.HEALTH_STATUS_UNKNOWN:
      return 4;
    case HealthStatus.UNRECOGNIZED:
    default:
      return -1;
  }
}

/** Health check request */
export interface HealthCheckRequest {
  /** Empty means overall health */
  service: string;
}

/** Health check response */
export interface HealthCheckResponse {
  status: HealthStatus;
  message: string;
  timestamp: Date | undefined;
  details: { [key: string]: string };
}

export interface HealthCheckResponse_DetailsEntry {
  key: string;
  value: string;
}

/** Get system metrics request */
export interface GetSystemMetricsRequest {
  fromTime: Date | undefined;
  toTime: Date | undefined;
  intervalSeconds: number;
}

/** System metrics */
export interface SystemMetrics {
  timestamp: Date | undefined;
  cpuUsagePercent: number;
  memoryUsedBytes: Long;
  memoryTotalBytes: Long;
  diskUsedBytes: Long;
  diskTotalBytes: Long;
  networkInBytes: Long;
  networkOutBytes: Long;
  goroutines: number;
  heapAllocBytes: Long;
  heapSysBytes: Long;
  loadAverage1m: number;
  loadAverage5m: number;
  loadAverage15m: number;
}

/** Get system metrics response */
export interface GetSystemMetricsResponse {
  success: boolean;
  message: string;
  metrics: SystemMetrics[];
}

/** Get database metrics request */
export interface GetDatabaseMetricsRequest {
  connectionId: string;
  fromTime: Date | undefined;
  toTime: Date | undefined;
  intervalSeconds: number;
}

/** Database metrics */
export interface DatabaseMetrics {
  connectionId: string;
  timestamp: Date | undefined;
  activeConnections: number;
  idleConnections: number;
  maxConnections: number;
  queriesExecuted: Long;
  queriesFailed: Long;
  avgQueryDurationMs: number;
  bytesSent: Long;
  bytesReceived: Long;
  cacheHitRatio: number;
  bufferCacheSizeBytes: Long;
  databaseSizeBytes: Long;
}

/** Get database metrics response */
export interface GetDatabaseMetricsResponse {
  success: boolean;
  message: string;
  metrics: DatabaseMetrics[];
}

function createBaseHealthCheckRequest(): HealthCheckRequest {
  return { service: "" };
}

export const HealthCheckRequest: MessageFns<HealthCheckRequest> = {
  encode(message: HealthCheckRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.service !== "") {
      writer.uint32(10).string(message.service);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HealthCheckRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheckRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.service = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealthCheckRequest {
    return { service: isSet(object.service) ? globalThis.String(object.service) : "" };
  },

  toJSON(message: HealthCheckRequest): unknown {
    const obj: any = {};
    if (message.service !== "") {
      obj.service = message.service;
    }
    return obj;
  },

  create(base?: DeepPartial<HealthCheckRequest>): HealthCheckRequest {
    return HealthCheckRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HealthCheckRequest>): HealthCheckRequest {
    const message = createBaseHealthCheckRequest();
    message.service = object.service ?? "";
    return message;
  },
};

function createBaseHealthCheckResponse(): HealthCheckResponse {
  return { status: HealthStatus.HEALTH_STATUS_UNSPECIFIED, message: "", timestamp: undefined, details: {} };
}

export const HealthCheckResponse: MessageFns<HealthCheckResponse> = {
  encode(message: HealthCheckResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== HealthStatus.HEALTH_STATUS_UNSPECIFIED) {
      writer.uint32(8).int32(healthStatusToNumber(message.status));
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(26).fork()).join();
    }
    Object.entries(message.details).forEach(([key, value]) => {
      HealthCheckResponse_DetailsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HealthCheckResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheckResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = healthStatusFromJSON(reader.int32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = HealthCheckResponse_DetailsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.details[entry4.key] = entry4.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealthCheckResponse {
    return {
      status: isSet(object.status) ? healthStatusFromJSON(object.status) : HealthStatus.HEALTH_STATUS_UNSPECIFIED,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      details: isObject(object.details)
        ? Object.entries(object.details).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: HealthCheckResponse): unknown {
    const obj: any = {};
    if (message.status !== HealthStatus.HEALTH_STATUS_UNSPECIFIED) {
      obj.status = healthStatusToJSON(message.status);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.details) {
      const entries = Object.entries(message.details);
      if (entries.length > 0) {
        obj.details = {};
        entries.forEach(([k, v]) => {
          obj.details[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<HealthCheckResponse>): HealthCheckResponse {
    return HealthCheckResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HealthCheckResponse>): HealthCheckResponse {
    const message = createBaseHealthCheckResponse();
    message.status = object.status ?? HealthStatus.HEALTH_STATUS_UNSPECIFIED;
    message.message = object.message ?? "";
    message.timestamp = object.timestamp ?? undefined;
    message.details = Object.entries(object.details ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseHealthCheckResponse_DetailsEntry(): HealthCheckResponse_DetailsEntry {
  return { key: "", value: "" };
}

export const HealthCheckResponse_DetailsEntry: MessageFns<HealthCheckResponse_DetailsEntry> = {
  encode(message: HealthCheckResponse_DetailsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HealthCheckResponse_DetailsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheckResponse_DetailsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealthCheckResponse_DetailsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: HealthCheckResponse_DetailsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<HealthCheckResponse_DetailsEntry>): HealthCheckResponse_DetailsEntry {
    return HealthCheckResponse_DetailsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HealthCheckResponse_DetailsEntry>): HealthCheckResponse_DetailsEntry {
    const message = createBaseHealthCheckResponse_DetailsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseGetSystemMetricsRequest(): GetSystemMetricsRequest {
  return { fromTime: undefined, toTime: undefined, intervalSeconds: 0 };
}

export const GetSystemMetricsRequest: MessageFns<GetSystemMetricsRequest> = {
  encode(message: GetSystemMetricsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fromTime !== undefined) {
      Timestamp.encode(toTimestamp(message.fromTime), writer.uint32(10).fork()).join();
    }
    if (message.toTime !== undefined) {
      Timestamp.encode(toTimestamp(message.toTime), writer.uint32(18).fork()).join();
    }
    if (message.intervalSeconds !== 0) {
      writer.uint32(24).int32(message.intervalSeconds);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSystemMetricsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSystemMetricsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fromTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.toTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.intervalSeconds = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSystemMetricsRequest {
    return {
      fromTime: isSet(object.fromTime) ? fromJsonTimestamp(object.fromTime) : undefined,
      toTime: isSet(object.toTime) ? fromJsonTimestamp(object.toTime) : undefined,
      intervalSeconds: isSet(object.intervalSeconds) ? globalThis.Number(object.intervalSeconds) : 0,
    };
  },

  toJSON(message: GetSystemMetricsRequest): unknown {
    const obj: any = {};
    if (message.fromTime !== undefined) {
      obj.fromTime = message.fromTime.toISOString();
    }
    if (message.toTime !== undefined) {
      obj.toTime = message.toTime.toISOString();
    }
    if (message.intervalSeconds !== 0) {
      obj.intervalSeconds = Math.round(message.intervalSeconds);
    }
    return obj;
  },

  create(base?: DeepPartial<GetSystemMetricsRequest>): GetSystemMetricsRequest {
    return GetSystemMetricsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetSystemMetricsRequest>): GetSystemMetricsRequest {
    const message = createBaseGetSystemMetricsRequest();
    message.fromTime = object.fromTime ?? undefined;
    message.toTime = object.toTime ?? undefined;
    message.intervalSeconds = object.intervalSeconds ?? 0;
    return message;
  },
};

function createBaseSystemMetrics(): SystemMetrics {
  return {
    timestamp: undefined,
    cpuUsagePercent: 0,
    memoryUsedBytes: Long.ZERO,
    memoryTotalBytes: Long.ZERO,
    diskUsedBytes: Long.ZERO,
    diskTotalBytes: Long.ZERO,
    networkInBytes: Long.ZERO,
    networkOutBytes: Long.ZERO,
    goroutines: 0,
    heapAllocBytes: Long.ZERO,
    heapSysBytes: Long.ZERO,
    loadAverage1m: 0,
    loadAverage5m: 0,
    loadAverage15m: 0,
  };
}

export const SystemMetrics: MessageFns<SystemMetrics> = {
  encode(message: SystemMetrics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(10).fork()).join();
    }
    if (message.cpuUsagePercent !== 0) {
      writer.uint32(17).double(message.cpuUsagePercent);
    }
    if (!message.memoryUsedBytes.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.memoryUsedBytes.toString());
    }
    if (!message.memoryTotalBytes.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.memoryTotalBytes.toString());
    }
    if (!message.diskUsedBytes.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.diskUsedBytes.toString());
    }
    if (!message.diskTotalBytes.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.diskTotalBytes.toString());
    }
    if (!message.networkInBytes.equals(Long.ZERO)) {
      writer.uint32(56).int64(message.networkInBytes.toString());
    }
    if (!message.networkOutBytes.equals(Long.ZERO)) {
      writer.uint32(64).int64(message.networkOutBytes.toString());
    }
    if (message.goroutines !== 0) {
      writer.uint32(72).int32(message.goroutines);
    }
    if (!message.heapAllocBytes.equals(Long.ZERO)) {
      writer.uint32(80).int64(message.heapAllocBytes.toString());
    }
    if (!message.heapSysBytes.equals(Long.ZERO)) {
      writer.uint32(88).int64(message.heapSysBytes.toString());
    }
    if (message.loadAverage1m !== 0) {
      writer.uint32(97).double(message.loadAverage1m);
    }
    if (message.loadAverage5m !== 0) {
      writer.uint32(105).double(message.loadAverage5m);
    }
    if (message.loadAverage15m !== 0) {
      writer.uint32(113).double(message.loadAverage15m);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SystemMetrics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSystemMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.cpuUsagePercent = reader.double();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.memoryUsedBytes = Long.fromString(reader.int64().toString());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.memoryTotalBytes = Long.fromString(reader.int64().toString());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.diskUsedBytes = Long.fromString(reader.int64().toString());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.diskTotalBytes = Long.fromString(reader.int64().toString());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.networkInBytes = Long.fromString(reader.int64().toString());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.networkOutBytes = Long.fromString(reader.int64().toString());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.goroutines = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.heapAllocBytes = Long.fromString(reader.int64().toString());
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.heapSysBytes = Long.fromString(reader.int64().toString());
          continue;
        }
        case 12: {
          if (tag !== 97) {
            break;
          }

          message.loadAverage1m = reader.double();
          continue;
        }
        case 13: {
          if (tag !== 105) {
            break;
          }

          message.loadAverage5m = reader.double();
          continue;
        }
        case 14: {
          if (tag !== 113) {
            break;
          }

          message.loadAverage15m = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SystemMetrics {
    return {
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      cpuUsagePercent: isSet(object.cpuUsagePercent) ? globalThis.Number(object.cpuUsagePercent) : 0,
      memoryUsedBytes: isSet(object.memoryUsedBytes) ? Long.fromValue(object.memoryUsedBytes) : Long.ZERO,
      memoryTotalBytes: isSet(object.memoryTotalBytes) ? Long.fromValue(object.memoryTotalBytes) : Long.ZERO,
      diskUsedBytes: isSet(object.diskUsedBytes) ? Long.fromValue(object.diskUsedBytes) : Long.ZERO,
      diskTotalBytes: isSet(object.diskTotalBytes) ? Long.fromValue(object.diskTotalBytes) : Long.ZERO,
      networkInBytes: isSet(object.networkInBytes) ? Long.fromValue(object.networkInBytes) : Long.ZERO,
      networkOutBytes: isSet(object.networkOutBytes) ? Long.fromValue(object.networkOutBytes) : Long.ZERO,
      goroutines: isSet(object.goroutines) ? globalThis.Number(object.goroutines) : 0,
      heapAllocBytes: isSet(object.heapAllocBytes) ? Long.fromValue(object.heapAllocBytes) : Long.ZERO,
      heapSysBytes: isSet(object.heapSysBytes) ? Long.fromValue(object.heapSysBytes) : Long.ZERO,
      loadAverage1m: isSet(object.loadAverage1m) ? globalThis.Number(object.loadAverage1m) : 0,
      loadAverage5m: isSet(object.loadAverage5m) ? globalThis.Number(object.loadAverage5m) : 0,
      loadAverage15m: isSet(object.loadAverage15m) ? globalThis.Number(object.loadAverage15m) : 0,
    };
  },

  toJSON(message: SystemMetrics): unknown {
    const obj: any = {};
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.cpuUsagePercent !== 0) {
      obj.cpuUsagePercent = message.cpuUsagePercent;
    }
    if (!message.memoryUsedBytes.equals(Long.ZERO)) {
      obj.memoryUsedBytes = (message.memoryUsedBytes || Long.ZERO).toString();
    }
    if (!message.memoryTotalBytes.equals(Long.ZERO)) {
      obj.memoryTotalBytes = (message.memoryTotalBytes || Long.ZERO).toString();
    }
    if (!message.diskUsedBytes.equals(Long.ZERO)) {
      obj.diskUsedBytes = (message.diskUsedBytes || Long.ZERO).toString();
    }
    if (!message.diskTotalBytes.equals(Long.ZERO)) {
      obj.diskTotalBytes = (message.diskTotalBytes || Long.ZERO).toString();
    }
    if (!message.networkInBytes.equals(Long.ZERO)) {
      obj.networkInBytes = (message.networkInBytes || Long.ZERO).toString();
    }
    if (!message.networkOutBytes.equals(Long.ZERO)) {
      obj.networkOutBytes = (message.networkOutBytes || Long.ZERO).toString();
    }
    if (message.goroutines !== 0) {
      obj.goroutines = Math.round(message.goroutines);
    }
    if (!message.heapAllocBytes.equals(Long.ZERO)) {
      obj.heapAllocBytes = (message.heapAllocBytes || Long.ZERO).toString();
    }
    if (!message.heapSysBytes.equals(Long.ZERO)) {
      obj.heapSysBytes = (message.heapSysBytes || Long.ZERO).toString();
    }
    if (message.loadAverage1m !== 0) {
      obj.loadAverage1m = message.loadAverage1m;
    }
    if (message.loadAverage5m !== 0) {
      obj.loadAverage5m = message.loadAverage5m;
    }
    if (message.loadAverage15m !== 0) {
      obj.loadAverage15m = message.loadAverage15m;
    }
    return obj;
  },

  create(base?: DeepPartial<SystemMetrics>): SystemMetrics {
    return SystemMetrics.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SystemMetrics>): SystemMetrics {
    const message = createBaseSystemMetrics();
    message.timestamp = object.timestamp ?? undefined;
    message.cpuUsagePercent = object.cpuUsagePercent ?? 0;
    message.memoryUsedBytes = (object.memoryUsedBytes !== undefined && object.memoryUsedBytes !== null)
      ? Long.fromValue(object.memoryUsedBytes)
      : Long.ZERO;
    message.memoryTotalBytes = (object.memoryTotalBytes !== undefined && object.memoryTotalBytes !== null)
      ? Long.fromValue(object.memoryTotalBytes)
      : Long.ZERO;
    message.diskUsedBytes = (object.diskUsedBytes !== undefined && object.diskUsedBytes !== null)
      ? Long.fromValue(object.diskUsedBytes)
      : Long.ZERO;
    message.diskTotalBytes = (object.diskTotalBytes !== undefined && object.diskTotalBytes !== null)
      ? Long.fromValue(object.diskTotalBytes)
      : Long.ZERO;
    message.networkInBytes = (object.networkInBytes !== undefined && object.networkInBytes !== null)
      ? Long.fromValue(object.networkInBytes)
      : Long.ZERO;
    message.networkOutBytes = (object.networkOutBytes !== undefined && object.networkOutBytes !== null)
      ? Long.fromValue(object.networkOutBytes)
      : Long.ZERO;
    message.goroutines = object.goroutines ?? 0;
    message.heapAllocBytes = (object.heapAllocBytes !== undefined && object.heapAllocBytes !== null)
      ? Long.fromValue(object.heapAllocBytes)
      : Long.ZERO;
    message.heapSysBytes = (object.heapSysBytes !== undefined && object.heapSysBytes !== null)
      ? Long.fromValue(object.heapSysBytes)
      : Long.ZERO;
    message.loadAverage1m = object.loadAverage1m ?? 0;
    message.loadAverage5m = object.loadAverage5m ?? 0;
    message.loadAverage15m = object.loadAverage15m ?? 0;
    return message;
  },
};

function createBaseGetSystemMetricsResponse(): GetSystemMetricsResponse {
  return { success: false, message: "", metrics: [] };
}

export const GetSystemMetricsResponse: MessageFns<GetSystemMetricsResponse> = {
  encode(message: GetSystemMetricsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    for (const v of message.metrics) {
      SystemMetrics.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSystemMetricsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSystemMetricsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.metrics.push(SystemMetrics.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSystemMetricsResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      metrics: globalThis.Array.isArray(object?.metrics)
        ? object.metrics.map((e: any) => SystemMetrics.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetSystemMetricsResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.metrics?.length) {
      obj.metrics = message.metrics.map((e) => SystemMetrics.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GetSystemMetricsResponse>): GetSystemMetricsResponse {
    return GetSystemMetricsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetSystemMetricsResponse>): GetSystemMetricsResponse {
    const message = createBaseGetSystemMetricsResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.metrics = object.metrics?.map((e) => SystemMetrics.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetDatabaseMetricsRequest(): GetDatabaseMetricsRequest {
  return { connectionId: "", fromTime: undefined, toTime: undefined, intervalSeconds: 0 };
}

export const GetDatabaseMetricsRequest: MessageFns<GetDatabaseMetricsRequest> = {
  encode(message: GetDatabaseMetricsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.connectionId !== "") {
      writer.uint32(10).string(message.connectionId);
    }
    if (message.fromTime !== undefined) {
      Timestamp.encode(toTimestamp(message.fromTime), writer.uint32(18).fork()).join();
    }
    if (message.toTime !== undefined) {
      Timestamp.encode(toTimestamp(message.toTime), writer.uint32(26).fork()).join();
    }
    if (message.intervalSeconds !== 0) {
      writer.uint32(32).int32(message.intervalSeconds);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDatabaseMetricsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDatabaseMetricsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.connectionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fromTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.toTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.intervalSeconds = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDatabaseMetricsRequest {
    return {
      connectionId: isSet(object.connectionId) ? globalThis.String(object.connectionId) : "",
      fromTime: isSet(object.fromTime) ? fromJsonTimestamp(object.fromTime) : undefined,
      toTime: isSet(object.toTime) ? fromJsonTimestamp(object.toTime) : undefined,
      intervalSeconds: isSet(object.intervalSeconds) ? globalThis.Number(object.intervalSeconds) : 0,
    };
  },

  toJSON(message: GetDatabaseMetricsRequest): unknown {
    const obj: any = {};
    if (message.connectionId !== "") {
      obj.connectionId = message.connectionId;
    }
    if (message.fromTime !== undefined) {
      obj.fromTime = message.fromTime.toISOString();
    }
    if (message.toTime !== undefined) {
      obj.toTime = message.toTime.toISOString();
    }
    if (message.intervalSeconds !== 0) {
      obj.intervalSeconds = Math.round(message.intervalSeconds);
    }
    return obj;
  },

  create(base?: DeepPartial<GetDatabaseMetricsRequest>): GetDatabaseMetricsRequest {
    return GetDatabaseMetricsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetDatabaseMetricsRequest>): GetDatabaseMetricsRequest {
    const message = createBaseGetDatabaseMetricsRequest();
    message.connectionId = object.connectionId ?? "";
    message.fromTime = object.fromTime ?? undefined;
    message.toTime = object.toTime ?? undefined;
    message.intervalSeconds = object.intervalSeconds ?? 0;
    return message;
  },
};

function createBaseDatabaseMetrics(): DatabaseMetrics {
  return {
    connectionId: "",
    timestamp: undefined,
    activeConnections: 0,
    idleConnections: 0,
    maxConnections: 0,
    queriesExecuted: Long.ZERO,
    queriesFailed: Long.ZERO,
    avgQueryDurationMs: 0,
    bytesSent: Long.ZERO,
    bytesReceived: Long.ZERO,
    cacheHitRatio: 0,
    bufferCacheSizeBytes: Long.ZERO,
    databaseSizeBytes: Long.ZERO,
  };
}

export const DatabaseMetrics: MessageFns<DatabaseMetrics> = {
  encode(message: DatabaseMetrics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.connectionId !== "") {
      writer.uint32(10).string(message.connectionId);
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(18).fork()).join();
    }
    if (message.activeConnections !== 0) {
      writer.uint32(24).int32(message.activeConnections);
    }
    if (message.idleConnections !== 0) {
      writer.uint32(32).int32(message.idleConnections);
    }
    if (message.maxConnections !== 0) {
      writer.uint32(40).int32(message.maxConnections);
    }
    if (!message.queriesExecuted.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.queriesExecuted.toString());
    }
    if (!message.queriesFailed.equals(Long.ZERO)) {
      writer.uint32(56).int64(message.queriesFailed.toString());
    }
    if (message.avgQueryDurationMs !== 0) {
      writer.uint32(65).double(message.avgQueryDurationMs);
    }
    if (!message.bytesSent.equals(Long.ZERO)) {
      writer.uint32(72).int64(message.bytesSent.toString());
    }
    if (!message.bytesReceived.equals(Long.ZERO)) {
      writer.uint32(80).int64(message.bytesReceived.toString());
    }
    if (message.cacheHitRatio !== 0) {
      writer.uint32(89).double(message.cacheHitRatio);
    }
    if (!message.bufferCacheSizeBytes.equals(Long.ZERO)) {
      writer.uint32(96).int64(message.bufferCacheSizeBytes.toString());
    }
    if (!message.databaseSizeBytes.equals(Long.ZERO)) {
      writer.uint32(104).int64(message.databaseSizeBytes.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DatabaseMetrics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDatabaseMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.connectionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.activeConnections = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.idleConnections = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.maxConnections = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.queriesExecuted = Long.fromString(reader.int64().toString());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.queriesFailed = Long.fromString(reader.int64().toString());
          continue;
        }
        case 8: {
          if (tag !== 65) {
            break;
          }

          message.avgQueryDurationMs = reader.double();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.bytesSent = Long.fromString(reader.int64().toString());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.bytesReceived = Long.fromString(reader.int64().toString());
          continue;
        }
        case 11: {
          if (tag !== 89) {
            break;
          }

          message.cacheHitRatio = reader.double();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.bufferCacheSizeBytes = Long.fromString(reader.int64().toString());
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.databaseSizeBytes = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DatabaseMetrics {
    return {
      connectionId: isSet(object.connectionId) ? globalThis.String(object.connectionId) : "",
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      activeConnections: isSet(object.activeConnections) ? globalThis.Number(object.activeConnections) : 0,
      idleConnections: isSet(object.idleConnections) ? globalThis.Number(object.idleConnections) : 0,
      maxConnections: isSet(object.maxConnections) ? globalThis.Number(object.maxConnections) : 0,
      queriesExecuted: isSet(object.queriesExecuted) ? Long.fromValue(object.queriesExecuted) : Long.ZERO,
      queriesFailed: isSet(object.queriesFailed) ? Long.fromValue(object.queriesFailed) : Long.ZERO,
      avgQueryDurationMs: isSet(object.avgQueryDurationMs) ? globalThis.Number(object.avgQueryDurationMs) : 0,
      bytesSent: isSet(object.bytesSent) ? Long.fromValue(object.bytesSent) : Long.ZERO,
      bytesReceived: isSet(object.bytesReceived) ? Long.fromValue(object.bytesReceived) : Long.ZERO,
      cacheHitRatio: isSet(object.cacheHitRatio) ? globalThis.Number(object.cacheHitRatio) : 0,
      bufferCacheSizeBytes: isSet(object.bufferCacheSizeBytes)
        ? Long.fromValue(object.bufferCacheSizeBytes)
        : Long.ZERO,
      databaseSizeBytes: isSet(object.databaseSizeBytes) ? Long.fromValue(object.databaseSizeBytes) : Long.ZERO,
    };
  },

  toJSON(message: DatabaseMetrics): unknown {
    const obj: any = {};
    if (message.connectionId !== "") {
      obj.connectionId = message.connectionId;
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.activeConnections !== 0) {
      obj.activeConnections = Math.round(message.activeConnections);
    }
    if (message.idleConnections !== 0) {
      obj.idleConnections = Math.round(message.idleConnections);
    }
    if (message.maxConnections !== 0) {
      obj.maxConnections = Math.round(message.maxConnections);
    }
    if (!message.queriesExecuted.equals(Long.ZERO)) {
      obj.queriesExecuted = (message.queriesExecuted || Long.ZERO).toString();
    }
    if (!message.queriesFailed.equals(Long.ZERO)) {
      obj.queriesFailed = (message.queriesFailed || Long.ZERO).toString();
    }
    if (message.avgQueryDurationMs !== 0) {
      obj.avgQueryDurationMs = message.avgQueryDurationMs;
    }
    if (!message.bytesSent.equals(Long.ZERO)) {
      obj.bytesSent = (message.bytesSent || Long.ZERO).toString();
    }
    if (!message.bytesReceived.equals(Long.ZERO)) {
      obj.bytesReceived = (message.bytesReceived || Long.ZERO).toString();
    }
    if (message.cacheHitRatio !== 0) {
      obj.cacheHitRatio = message.cacheHitRatio;
    }
    if (!message.bufferCacheSizeBytes.equals(Long.ZERO)) {
      obj.bufferCacheSizeBytes = (message.bufferCacheSizeBytes || Long.ZERO).toString();
    }
    if (!message.databaseSizeBytes.equals(Long.ZERO)) {
      obj.databaseSizeBytes = (message.databaseSizeBytes || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<DatabaseMetrics>): DatabaseMetrics {
    return DatabaseMetrics.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DatabaseMetrics>): DatabaseMetrics {
    const message = createBaseDatabaseMetrics();
    message.connectionId = object.connectionId ?? "";
    message.timestamp = object.timestamp ?? undefined;
    message.activeConnections = object.activeConnections ?? 0;
    message.idleConnections = object.idleConnections ?? 0;
    message.maxConnections = object.maxConnections ?? 0;
    message.queriesExecuted = (object.queriesExecuted !== undefined && object.queriesExecuted !== null)
      ? Long.fromValue(object.queriesExecuted)
      : Long.ZERO;
    message.queriesFailed = (object.queriesFailed !== undefined && object.queriesFailed !== null)
      ? Long.fromValue(object.queriesFailed)
      : Long.ZERO;
    message.avgQueryDurationMs = object.avgQueryDurationMs ?? 0;
    message.bytesSent = (object.bytesSent !== undefined && object.bytesSent !== null)
      ? Long.fromValue(object.bytesSent)
      : Long.ZERO;
    message.bytesReceived = (object.bytesReceived !== undefined && object.bytesReceived !== null)
      ? Long.fromValue(object.bytesReceived)
      : Long.ZERO;
    message.cacheHitRatio = object.cacheHitRatio ?? 0;
    message.bufferCacheSizeBytes = (object.bufferCacheSizeBytes !== undefined && object.bufferCacheSizeBytes !== null)
      ? Long.fromValue(object.bufferCacheSizeBytes)
      : Long.ZERO;
    message.databaseSizeBytes = (object.databaseSizeBytes !== undefined && object.databaseSizeBytes !== null)
      ? Long.fromValue(object.databaseSizeBytes)
      : Long.ZERO;
    return message;
  },
};

function createBaseGetDatabaseMetricsResponse(): GetDatabaseMetricsResponse {
  return { success: false, message: "", metrics: [] };
}

export const GetDatabaseMetricsResponse: MessageFns<GetDatabaseMetricsResponse> = {
  encode(message: GetDatabaseMetricsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    for (const v of message.metrics) {
      DatabaseMetrics.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDatabaseMetricsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDatabaseMetricsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.metrics.push(DatabaseMetrics.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDatabaseMetricsResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      metrics: globalThis.Array.isArray(object?.metrics)
        ? object.metrics.map((e: any) => DatabaseMetrics.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetDatabaseMetricsResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.metrics?.length) {
      obj.metrics = message.metrics.map((e) => DatabaseMetrics.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GetDatabaseMetricsResponse>): GetDatabaseMetricsResponse {
    return GetDatabaseMetricsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetDatabaseMetricsResponse>): GetDatabaseMetricsResponse {
    const message = createBaseGetDatabaseMetricsResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.metrics = object.metrics?.map((e) => DatabaseMetrics.fromPartial(e)) || [];
    return message;
  },
};

/** Health service for monitoring and diagnostics */
export type HealthServiceDefinition = typeof HealthServiceDefinition;
export const HealthServiceDefinition = {
  name: "HealthService",
  fullName: "sqlstudio.health.HealthService",
  methods: {
    check: {
      name: "Check",
      requestType: HealthCheckRequest,
      requestStream: false,
      responseType: HealthCheckResponse,
      responseStream: false,
      options: {},
    },
    watch: {
      name: "Watch",
      requestType: HealthCheckRequest,
      requestStream: false,
      responseType: HealthCheckResponse,
      responseStream: true,
      options: {},
    },
    getSystemMetrics: {
      name: "GetSystemMetrics",
      requestType: GetSystemMetricsRequest,
      requestStream: false,
      responseType: GetSystemMetricsResponse,
      responseStream: false,
      options: {},
    },
    getDatabaseMetrics: {
      name: "GetDatabaseMetrics",
      requestType: GetDatabaseMetricsRequest,
      requestStream: false,
      responseType: GetDatabaseMetricsResponse,
      responseStream: false,
      options: {},
    },
  },
} as const;

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
