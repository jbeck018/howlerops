// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.1
//   protoc               v5.29.3
// source: table.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Any } from "./google/protobuf/any";
import { Timestamp } from "./google/protobuf/timestamp";

export const protobufPackage = "sqlstudio.table";

/** Sort direction */
export enum SortDirection {
  SORT_DIRECTION_UNSPECIFIED = "SORT_DIRECTION_UNSPECIFIED",
  SORT_DIRECTION_ASC = "SORT_DIRECTION_ASC",
  SORT_DIRECTION_DESC = "SORT_DIRECTION_DESC",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function sortDirectionFromJSON(object: any): SortDirection {
  switch (object) {
    case 0:
    case "SORT_DIRECTION_UNSPECIFIED":
      return SortDirection.SORT_DIRECTION_UNSPECIFIED;
    case 1:
    case "SORT_DIRECTION_ASC":
      return SortDirection.SORT_DIRECTION_ASC;
    case 2:
    case "SORT_DIRECTION_DESC":
      return SortDirection.SORT_DIRECTION_DESC;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SortDirection.UNRECOGNIZED;
  }
}

export function sortDirectionToJSON(object: SortDirection): string {
  switch (object) {
    case SortDirection.SORT_DIRECTION_UNSPECIFIED:
      return "SORT_DIRECTION_UNSPECIFIED";
    case SortDirection.SORT_DIRECTION_ASC:
      return "SORT_DIRECTION_ASC";
    case SortDirection.SORT_DIRECTION_DESC:
      return "SORT_DIRECTION_DESC";
    case SortDirection.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function sortDirectionToNumber(object: SortDirection): number {
  switch (object) {
    case SortDirection.SORT_DIRECTION_UNSPECIFIED:
      return 0;
    case SortDirection.SORT_DIRECTION_ASC:
      return 1;
    case SortDirection.SORT_DIRECTION_DESC:
      return 2;
    case SortDirection.UNRECOGNIZED:
    default:
      return -1;
  }
}

/** Filter operator */
export enum FilterOperator {
  FILTER_OPERATOR_UNSPECIFIED = "FILTER_OPERATOR_UNSPECIFIED",
  FILTER_OPERATOR_EQUALS = "FILTER_OPERATOR_EQUALS",
  FILTER_OPERATOR_NOT_EQUALS = "FILTER_OPERATOR_NOT_EQUALS",
  FILTER_OPERATOR_GREATER_THAN = "FILTER_OPERATOR_GREATER_THAN",
  FILTER_OPERATOR_GREATER_THAN_OR_EQUAL = "FILTER_OPERATOR_GREATER_THAN_OR_EQUAL",
  FILTER_OPERATOR_LESS_THAN = "FILTER_OPERATOR_LESS_THAN",
  FILTER_OPERATOR_LESS_THAN_OR_EQUAL = "FILTER_OPERATOR_LESS_THAN_OR_EQUAL",
  FILTER_OPERATOR_LIKE = "FILTER_OPERATOR_LIKE",
  FILTER_OPERATOR_NOT_LIKE = "FILTER_OPERATOR_NOT_LIKE",
  FILTER_OPERATOR_IN = "FILTER_OPERATOR_IN",
  FILTER_OPERATOR_NOT_IN = "FILTER_OPERATOR_NOT_IN",
  FILTER_OPERATOR_IS_NULL = "FILTER_OPERATOR_IS_NULL",
  FILTER_OPERATOR_IS_NOT_NULL = "FILTER_OPERATOR_IS_NOT_NULL",
  FILTER_OPERATOR_BETWEEN = "FILTER_OPERATOR_BETWEEN",
  FILTER_OPERATOR_NOT_BETWEEN = "FILTER_OPERATOR_NOT_BETWEEN",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function filterOperatorFromJSON(object: any): FilterOperator {
  switch (object) {
    case 0:
    case "FILTER_OPERATOR_UNSPECIFIED":
      return FilterOperator.FILTER_OPERATOR_UNSPECIFIED;
    case 1:
    case "FILTER_OPERATOR_EQUALS":
      return FilterOperator.FILTER_OPERATOR_EQUALS;
    case 2:
    case "FILTER_OPERATOR_NOT_EQUALS":
      return FilterOperator.FILTER_OPERATOR_NOT_EQUALS;
    case 3:
    case "FILTER_OPERATOR_GREATER_THAN":
      return FilterOperator.FILTER_OPERATOR_GREATER_THAN;
    case 4:
    case "FILTER_OPERATOR_GREATER_THAN_OR_EQUAL":
      return FilterOperator.FILTER_OPERATOR_GREATER_THAN_OR_EQUAL;
    case 5:
    case "FILTER_OPERATOR_LESS_THAN":
      return FilterOperator.FILTER_OPERATOR_LESS_THAN;
    case 6:
    case "FILTER_OPERATOR_LESS_THAN_OR_EQUAL":
      return FilterOperator.FILTER_OPERATOR_LESS_THAN_OR_EQUAL;
    case 7:
    case "FILTER_OPERATOR_LIKE":
      return FilterOperator.FILTER_OPERATOR_LIKE;
    case 8:
    case "FILTER_OPERATOR_NOT_LIKE":
      return FilterOperator.FILTER_OPERATOR_NOT_LIKE;
    case 9:
    case "FILTER_OPERATOR_IN":
      return FilterOperator.FILTER_OPERATOR_IN;
    case 10:
    case "FILTER_OPERATOR_NOT_IN":
      return FilterOperator.FILTER_OPERATOR_NOT_IN;
    case 11:
    case "FILTER_OPERATOR_IS_NULL":
      return FilterOperator.FILTER_OPERATOR_IS_NULL;
    case 12:
    case "FILTER_OPERATOR_IS_NOT_NULL":
      return FilterOperator.FILTER_OPERATOR_IS_NOT_NULL;
    case 13:
    case "FILTER_OPERATOR_BETWEEN":
      return FilterOperator.FILTER_OPERATOR_BETWEEN;
    case 14:
    case "FILTER_OPERATOR_NOT_BETWEEN":
      return FilterOperator.FILTER_OPERATOR_NOT_BETWEEN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FilterOperator.UNRECOGNIZED;
  }
}

export function filterOperatorToJSON(object: FilterOperator): string {
  switch (object) {
    case FilterOperator.FILTER_OPERATOR_UNSPECIFIED:
      return "FILTER_OPERATOR_UNSPECIFIED";
    case FilterOperator.FILTER_OPERATOR_EQUALS:
      return "FILTER_OPERATOR_EQUALS";
    case FilterOperator.FILTER_OPERATOR_NOT_EQUALS:
      return "FILTER_OPERATOR_NOT_EQUALS";
    case FilterOperator.FILTER_OPERATOR_GREATER_THAN:
      return "FILTER_OPERATOR_GREATER_THAN";
    case FilterOperator.FILTER_OPERATOR_GREATER_THAN_OR_EQUAL:
      return "FILTER_OPERATOR_GREATER_THAN_OR_EQUAL";
    case FilterOperator.FILTER_OPERATOR_LESS_THAN:
      return "FILTER_OPERATOR_LESS_THAN";
    case FilterOperator.FILTER_OPERATOR_LESS_THAN_OR_EQUAL:
      return "FILTER_OPERATOR_LESS_THAN_OR_EQUAL";
    case FilterOperator.FILTER_OPERATOR_LIKE:
      return "FILTER_OPERATOR_LIKE";
    case FilterOperator.FILTER_OPERATOR_NOT_LIKE:
      return "FILTER_OPERATOR_NOT_LIKE";
    case FilterOperator.FILTER_OPERATOR_IN:
      return "FILTER_OPERATOR_IN";
    case FilterOperator.FILTER_OPERATOR_NOT_IN:
      return "FILTER_OPERATOR_NOT_IN";
    case FilterOperator.FILTER_OPERATOR_IS_NULL:
      return "FILTER_OPERATOR_IS_NULL";
    case FilterOperator.FILTER_OPERATOR_IS_NOT_NULL:
      return "FILTER_OPERATOR_IS_NOT_NULL";
    case FilterOperator.FILTER_OPERATOR_BETWEEN:
      return "FILTER_OPERATOR_BETWEEN";
    case FilterOperator.FILTER_OPERATOR_NOT_BETWEEN:
      return "FILTER_OPERATOR_NOT_BETWEEN";
    case FilterOperator.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function filterOperatorToNumber(object: FilterOperator): number {
  switch (object) {
    case FilterOperator.FILTER_OPERATOR_UNSPECIFIED:
      return 0;
    case FilterOperator.FILTER_OPERATOR_EQUALS:
      return 1;
    case FilterOperator.FILTER_OPERATOR_NOT_EQUALS:
      return 2;
    case FilterOperator.FILTER_OPERATOR_GREATER_THAN:
      return 3;
    case FilterOperator.FILTER_OPERATOR_GREATER_THAN_OR_EQUAL:
      return 4;
    case FilterOperator.FILTER_OPERATOR_LESS_THAN:
      return 5;
    case FilterOperator.FILTER_OPERATOR_LESS_THAN_OR_EQUAL:
      return 6;
    case FilterOperator.FILTER_OPERATOR_LIKE:
      return 7;
    case FilterOperator.FILTER_OPERATOR_NOT_LIKE:
      return 8;
    case FilterOperator.FILTER_OPERATOR_IN:
      return 9;
    case FilterOperator.FILTER_OPERATOR_NOT_IN:
      return 10;
    case FilterOperator.FILTER_OPERATOR_IS_NULL:
      return 11;
    case FilterOperator.FILTER_OPERATOR_IS_NOT_NULL:
      return 12;
    case FilterOperator.FILTER_OPERATOR_BETWEEN:
      return 13;
    case FilterOperator.FILTER_OPERATOR_NOT_BETWEEN:
      return 14;
    case FilterOperator.UNRECOGNIZED:
    default:
      return -1;
  }
}

/** Alter table operation types */
export enum AlterOperation {
  ALTER_OPERATION_UNSPECIFIED = "ALTER_OPERATION_UNSPECIFIED",
  ALTER_OPERATION_ADD_COLUMN = "ALTER_OPERATION_ADD_COLUMN",
  ALTER_OPERATION_DROP_COLUMN = "ALTER_OPERATION_DROP_COLUMN",
  ALTER_OPERATION_MODIFY_COLUMN = "ALTER_OPERATION_MODIFY_COLUMN",
  ALTER_OPERATION_RENAME_COLUMN = "ALTER_OPERATION_RENAME_COLUMN",
  ALTER_OPERATION_ADD_INDEX = "ALTER_OPERATION_ADD_INDEX",
  ALTER_OPERATION_DROP_INDEX = "ALTER_OPERATION_DROP_INDEX",
  ALTER_OPERATION_ADD_FOREIGN_KEY = "ALTER_OPERATION_ADD_FOREIGN_KEY",
  ALTER_OPERATION_DROP_FOREIGN_KEY = "ALTER_OPERATION_DROP_FOREIGN_KEY",
  ALTER_OPERATION_RENAME_TABLE = "ALTER_OPERATION_RENAME_TABLE",
  ALTER_OPERATION_SET_COMMENT = "ALTER_OPERATION_SET_COMMENT",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function alterOperationFromJSON(object: any): AlterOperation {
  switch (object) {
    case 0:
    case "ALTER_OPERATION_UNSPECIFIED":
      return AlterOperation.ALTER_OPERATION_UNSPECIFIED;
    case 1:
    case "ALTER_OPERATION_ADD_COLUMN":
      return AlterOperation.ALTER_OPERATION_ADD_COLUMN;
    case 2:
    case "ALTER_OPERATION_DROP_COLUMN":
      return AlterOperation.ALTER_OPERATION_DROP_COLUMN;
    case 3:
    case "ALTER_OPERATION_MODIFY_COLUMN":
      return AlterOperation.ALTER_OPERATION_MODIFY_COLUMN;
    case 4:
    case "ALTER_OPERATION_RENAME_COLUMN":
      return AlterOperation.ALTER_OPERATION_RENAME_COLUMN;
    case 5:
    case "ALTER_OPERATION_ADD_INDEX":
      return AlterOperation.ALTER_OPERATION_ADD_INDEX;
    case 6:
    case "ALTER_OPERATION_DROP_INDEX":
      return AlterOperation.ALTER_OPERATION_DROP_INDEX;
    case 7:
    case "ALTER_OPERATION_ADD_FOREIGN_KEY":
      return AlterOperation.ALTER_OPERATION_ADD_FOREIGN_KEY;
    case 8:
    case "ALTER_OPERATION_DROP_FOREIGN_KEY":
      return AlterOperation.ALTER_OPERATION_DROP_FOREIGN_KEY;
    case 9:
    case "ALTER_OPERATION_RENAME_TABLE":
      return AlterOperation.ALTER_OPERATION_RENAME_TABLE;
    case 10:
    case "ALTER_OPERATION_SET_COMMENT":
      return AlterOperation.ALTER_OPERATION_SET_COMMENT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AlterOperation.UNRECOGNIZED;
  }
}

export function alterOperationToJSON(object: AlterOperation): string {
  switch (object) {
    case AlterOperation.ALTER_OPERATION_UNSPECIFIED:
      return "ALTER_OPERATION_UNSPECIFIED";
    case AlterOperation.ALTER_OPERATION_ADD_COLUMN:
      return "ALTER_OPERATION_ADD_COLUMN";
    case AlterOperation.ALTER_OPERATION_DROP_COLUMN:
      return "ALTER_OPERATION_DROP_COLUMN";
    case AlterOperation.ALTER_OPERATION_MODIFY_COLUMN:
      return "ALTER_OPERATION_MODIFY_COLUMN";
    case AlterOperation.ALTER_OPERATION_RENAME_COLUMN:
      return "ALTER_OPERATION_RENAME_COLUMN";
    case AlterOperation.ALTER_OPERATION_ADD_INDEX:
      return "ALTER_OPERATION_ADD_INDEX";
    case AlterOperation.ALTER_OPERATION_DROP_INDEX:
      return "ALTER_OPERATION_DROP_INDEX";
    case AlterOperation.ALTER_OPERATION_ADD_FOREIGN_KEY:
      return "ALTER_OPERATION_ADD_FOREIGN_KEY";
    case AlterOperation.ALTER_OPERATION_DROP_FOREIGN_KEY:
      return "ALTER_OPERATION_DROP_FOREIGN_KEY";
    case AlterOperation.ALTER_OPERATION_RENAME_TABLE:
      return "ALTER_OPERATION_RENAME_TABLE";
    case AlterOperation.ALTER_OPERATION_SET_COMMENT:
      return "ALTER_OPERATION_SET_COMMENT";
    case AlterOperation.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function alterOperationToNumber(object: AlterOperation): number {
  switch (object) {
    case AlterOperation.ALTER_OPERATION_UNSPECIFIED:
      return 0;
    case AlterOperation.ALTER_OPERATION_ADD_COLUMN:
      return 1;
    case AlterOperation.ALTER_OPERATION_DROP_COLUMN:
      return 2;
    case AlterOperation.ALTER_OPERATION_MODIFY_COLUMN:
      return 3;
    case AlterOperation.ALTER_OPERATION_RENAME_COLUMN:
      return 4;
    case AlterOperation.ALTER_OPERATION_ADD_INDEX:
      return 5;
    case AlterOperation.ALTER_OPERATION_DROP_INDEX:
      return 6;
    case AlterOperation.ALTER_OPERATION_ADD_FOREIGN_KEY:
      return 7;
    case AlterOperation.ALTER_OPERATION_DROP_FOREIGN_KEY:
      return 8;
    case AlterOperation.ALTER_OPERATION_RENAME_TABLE:
      return 9;
    case AlterOperation.ALTER_OPERATION_SET_COMMENT:
      return 10;
    case AlterOperation.UNRECOGNIZED:
    default:
      return -1;
  }
}

/** Import format */
export enum ImportFormat {
  IMPORT_FORMAT_UNSPECIFIED = "IMPORT_FORMAT_UNSPECIFIED",
  IMPORT_FORMAT_CSV = "IMPORT_FORMAT_CSV",
  IMPORT_FORMAT_JSON = "IMPORT_FORMAT_JSON",
  IMPORT_FORMAT_NDJSON = "IMPORT_FORMAT_NDJSON",
  IMPORT_FORMAT_XML = "IMPORT_FORMAT_XML",
  IMPORT_FORMAT_EXCEL = "IMPORT_FORMAT_EXCEL",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function importFormatFromJSON(object: any): ImportFormat {
  switch (object) {
    case 0:
    case "IMPORT_FORMAT_UNSPECIFIED":
      return ImportFormat.IMPORT_FORMAT_UNSPECIFIED;
    case 1:
    case "IMPORT_FORMAT_CSV":
      return ImportFormat.IMPORT_FORMAT_CSV;
    case 2:
    case "IMPORT_FORMAT_JSON":
      return ImportFormat.IMPORT_FORMAT_JSON;
    case 3:
    case "IMPORT_FORMAT_NDJSON":
      return ImportFormat.IMPORT_FORMAT_NDJSON;
    case 4:
    case "IMPORT_FORMAT_XML":
      return ImportFormat.IMPORT_FORMAT_XML;
    case 5:
    case "IMPORT_FORMAT_EXCEL":
      return ImportFormat.IMPORT_FORMAT_EXCEL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ImportFormat.UNRECOGNIZED;
  }
}

export function importFormatToJSON(object: ImportFormat): string {
  switch (object) {
    case ImportFormat.IMPORT_FORMAT_UNSPECIFIED:
      return "IMPORT_FORMAT_UNSPECIFIED";
    case ImportFormat.IMPORT_FORMAT_CSV:
      return "IMPORT_FORMAT_CSV";
    case ImportFormat.IMPORT_FORMAT_JSON:
      return "IMPORT_FORMAT_JSON";
    case ImportFormat.IMPORT_FORMAT_NDJSON:
      return "IMPORT_FORMAT_NDJSON";
    case ImportFormat.IMPORT_FORMAT_XML:
      return "IMPORT_FORMAT_XML";
    case ImportFormat.IMPORT_FORMAT_EXCEL:
      return "IMPORT_FORMAT_EXCEL";
    case ImportFormat.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function importFormatToNumber(object: ImportFormat): number {
  switch (object) {
    case ImportFormat.IMPORT_FORMAT_UNSPECIFIED:
      return 0;
    case ImportFormat.IMPORT_FORMAT_CSV:
      return 1;
    case ImportFormat.IMPORT_FORMAT_JSON:
      return 2;
    case ImportFormat.IMPORT_FORMAT_NDJSON:
      return 3;
    case ImportFormat.IMPORT_FORMAT_XML:
      return 4;
    case ImportFormat.IMPORT_FORMAT_EXCEL:
      return 5;
    case ImportFormat.UNRECOGNIZED:
    default:
      return -1;
  }
}

/** Export format */
export enum ExportFormat {
  EXPORT_FORMAT_UNSPECIFIED = "EXPORT_FORMAT_UNSPECIFIED",
  EXPORT_FORMAT_CSV = "EXPORT_FORMAT_CSV",
  EXPORT_FORMAT_JSON = "EXPORT_FORMAT_JSON",
  EXPORT_FORMAT_NDJSON = "EXPORT_FORMAT_NDJSON",
  EXPORT_FORMAT_XML = "EXPORT_FORMAT_XML",
  EXPORT_FORMAT_SQL = "EXPORT_FORMAT_SQL",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function exportFormatFromJSON(object: any): ExportFormat {
  switch (object) {
    case 0:
    case "EXPORT_FORMAT_UNSPECIFIED":
      return ExportFormat.EXPORT_FORMAT_UNSPECIFIED;
    case 1:
    case "EXPORT_FORMAT_CSV":
      return ExportFormat.EXPORT_FORMAT_CSV;
    case 2:
    case "EXPORT_FORMAT_JSON":
      return ExportFormat.EXPORT_FORMAT_JSON;
    case 3:
    case "EXPORT_FORMAT_NDJSON":
      return ExportFormat.EXPORT_FORMAT_NDJSON;
    case 4:
    case "EXPORT_FORMAT_XML":
      return ExportFormat.EXPORT_FORMAT_XML;
    case 5:
    case "EXPORT_FORMAT_SQL":
      return ExportFormat.EXPORT_FORMAT_SQL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ExportFormat.UNRECOGNIZED;
  }
}

export function exportFormatToJSON(object: ExportFormat): string {
  switch (object) {
    case ExportFormat.EXPORT_FORMAT_UNSPECIFIED:
      return "EXPORT_FORMAT_UNSPECIFIED";
    case ExportFormat.EXPORT_FORMAT_CSV:
      return "EXPORT_FORMAT_CSV";
    case ExportFormat.EXPORT_FORMAT_JSON:
      return "EXPORT_FORMAT_JSON";
    case ExportFormat.EXPORT_FORMAT_NDJSON:
      return "EXPORT_FORMAT_NDJSON";
    case ExportFormat.EXPORT_FORMAT_XML:
      return "EXPORT_FORMAT_XML";
    case ExportFormat.EXPORT_FORMAT_SQL:
      return "EXPORT_FORMAT_SQL";
    case ExportFormat.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function exportFormatToNumber(object: ExportFormat): number {
  switch (object) {
    case ExportFormat.EXPORT_FORMAT_UNSPECIFIED:
      return 0;
    case ExportFormat.EXPORT_FORMAT_CSV:
      return 1;
    case ExportFormat.EXPORT_FORMAT_JSON:
      return 2;
    case ExportFormat.EXPORT_FORMAT_NDJSON:
      return 3;
    case ExportFormat.EXPORT_FORMAT_XML:
      return 4;
    case ExportFormat.EXPORT_FORMAT_SQL:
      return 5;
    case ExportFormat.UNRECOGNIZED:
    default:
      return -1;
  }
}

/** Sort specification */
export interface SortSpec {
  column: string;
  direction: SortDirection;
}

/** Filter specification */
export interface FilterSpec {
  column: string;
  operator: FilterOperator;
  values: Any[];
}

/** Get table data request */
export interface GetTableDataRequest {
  connectionId: string;
  schemaName: string;
  tableName: string;
  /** Empty means all columns */
  columns: string[];
  filters: FilterSpec[];
  sorts: SortSpec[];
  limit: number;
  offset: number;
  includeTotalCount: boolean;
}

/** Table row */
export interface TableRow {
  values: { [key: string]: Any };
  /** For optimistic locking */
  version: Long;
  updatedAt: Date | undefined;
}

export interface TableRow_ValuesEntry {
  key: string;
  value: Any | undefined;
}

/** Get table data response */
export interface GetTableDataResponse {
  success: boolean;
  message: string;
  rows: TableRow[];
  totalCount: Long;
  hasMore: boolean;
  cursor: string;
}

/** Get table data stream request */
export interface GetTableDataStreamRequest {
  connectionId: string;
  schemaName: string;
  tableName: string;
  columns: string[];
  filters: FilterSpec[];
  sorts: SortSpec[];
  batchSize: number;
}

/** Table data stream response */
export interface TableDataStreamResponse {
  row?: TableRow | undefined;
  error?: string | undefined;
  stats?: TableStreamStats | undefined;
}

/** Table stream statistics */
export interface TableStreamStats {
  rowsProcessed: Long;
  totalRows: Long;
  startedAt: Date | undefined;
  completedAt: Date | undefined;
  completed: boolean;
}

/** Update table row request */
export interface UpdateTableRowRequest {
  connectionId: string;
  schemaName: string;
  tableName: string;
  primaryKey: { [key: string]: Any };
  values: { [key: string]: Any };
  /** For optimistic locking */
  version: Long;
  returnUpdatedRow: boolean;
}

export interface UpdateTableRowRequest_PrimaryKeyEntry {
  key: string;
  value: Any | undefined;
}

export interface UpdateTableRowRequest_ValuesEntry {
  key: string;
  value: Any | undefined;
}

/** Update table row response */
export interface UpdateTableRowResponse {
  success: boolean;
  message: string;
  rowsAffected: Long;
  updatedRow: TableRow | undefined;
  newVersion: Long;
}

/** Insert table row request */
export interface InsertTableRowRequest {
  connectionId: string;
  schemaName: string;
  tableName: string;
  values: { [key: string]: Any };
  returnInsertedRow: boolean;
}

export interface InsertTableRowRequest_ValuesEntry {
  key: string;
  value: Any | undefined;
}

/** Insert table row response */
export interface InsertTableRowResponse {
  success: boolean;
  message: string;
  insertedRow:
    | TableRow
    | undefined;
  /** Auto-generated columns */
  generatedValues: { [key: string]: Any };
}

export interface InsertTableRowResponse_GeneratedValuesEntry {
  key: string;
  value: Any | undefined;
}

/** Delete table row request */
export interface DeleteTableRowRequest {
  connectionId: string;
  schemaName: string;
  tableName: string;
  primaryKey: { [key: string]: Any };
  /** For optimistic locking */
  version: Long;
}

export interface DeleteTableRowRequest_PrimaryKeyEntry {
  key: string;
  value: Any | undefined;
}

/** Delete table row response */
export interface DeleteTableRowResponse {
  success: boolean;
  message: string;
  rowsAffected: Long;
}

/** Column definition for table creation */
export interface ColumnDefinition {
  name: string;
  dataType: string;
  nullable: boolean;
  defaultValue: string;
  primaryKey: boolean;
  unique: boolean;
  autoIncrement: boolean;
  comment: string;
  checkConstraint: string;
  attributes: { [key: string]: string };
}

export interface ColumnDefinition_AttributesEntry {
  key: string;
  value: string;
}

/** Index definition */
export interface IndexDefinition {
  name: string;
  columns: string[];
  unique: boolean;
  /** BTREE, HASH, etc. */
  type: string;
  /** Database-specific */
  method: string;
  /** Partial index */
  whereClause: string;
}

/** Foreign key definition */
export interface ForeignKeyDefinition {
  name: string;
  columns: string[];
  referencedTable: string;
  referencedSchema: string;
  referencedColumns: string[];
  /** CASCADE, SET NULL, etc. */
  onDelete: string;
  onUpdate: string;
}

/** Create table request */
export interface CreateTableRequest {
  connectionId: string;
  schemaName: string;
  tableName: string;
  columns: ColumnDefinition[];
  indexes: IndexDefinition[];
  foreignKeys: ForeignKeyDefinition[];
  comment: string;
  /** Database-specific options */
  options: { [key: string]: string };
  ifNotExists: boolean;
}

export interface CreateTableRequest_OptionsEntry {
  key: string;
  value: string;
}

/** Create table response */
export interface CreateTableResponse {
  success: boolean;
  message: string;
  /** Generated SQL */
  sql: string;
}

/** Alter table operation */
export interface AlterTableOperation {
  operation: AlterOperation;
  addColumn?: ColumnDefinition | undefined;
  dropColumn?: string | undefined;
  modifyColumn?: ColumnDefinition | undefined;
  renameColumn?: RenameColumnDetails | undefined;
  addIndex?: IndexDefinition | undefined;
  dropIndex?: string | undefined;
  addForeignKey?: ForeignKeyDefinition | undefined;
  dropForeignKey?: string | undefined;
  renameTable?: string | undefined;
  setComment?: string | undefined;
}

/** Rename column details */
export interface RenameColumnDetails {
  oldName: string;
  newName: string;
}

/** Alter table request */
export interface AlterTableRequest {
  connectionId: string;
  schemaName: string;
  tableName: string;
  operations: AlterTableOperation[];
}

/** Alter table response */
export interface AlterTableResponse {
  success: boolean;
  message: string;
  sqlStatements: string[];
}

/** Drop table request */
export interface DropTableRequest {
  connectionId: string;
  schemaName: string;
  tableName: string;
  ifExists: boolean;
  cascade: boolean;
}

/** Drop table response */
export interface DropTableResponse {
  success: boolean;
  message: string;
  sql: string;
}

/** Get table structure request */
export interface GetTableStructureRequest {
  connectionId: string;
  schemaName: string;
  tableName: string;
}

/** Get table structure response */
export interface GetTableStructureResponse {
  success: boolean;
  message: string;
  columns: ColumnDefinition[];
  indexes: IndexDefinition[];
  foreignKeys: ForeignKeyDefinition[];
  triggers: string[];
  comment: string;
  options: { [key: string]: string };
}

export interface GetTableStructureResponse_OptionsEntry {
  key: string;
  value: string;
}

/** Data validation rule */
export interface ValidationRule {
  name: string;
  column: string;
  /** NOT_NULL, UNIQUE, RANGE, PATTERN, etc. */
  ruleType: string;
  parameters: { [key: string]: Any };
  errorMessage: string;
}

export interface ValidationRule_ParametersEntry {
  key: string;
  value: Any | undefined;
}

/** Validate table data request */
export interface ValidateTableDataRequest {
  connectionId: string;
  schemaName: string;
  tableName: string;
  rules: ValidationRule[];
  /** 0 = validate all data */
  sampleSize: number;
}

/** Validation error */
export interface ValidationError {
  ruleName: string;
  column: string;
  value: Any | undefined;
  errorMessage: string;
  rowNumber: Long;
}

/** Validate table data response */
export interface ValidateTableDataResponse {
  success: boolean;
  message: string;
  valid: boolean;
  errors: ValidationError[];
  rowsValidated: Long;
  errorsCount: Long;
}

/** Import options */
export interface ImportOptions {
  format: ImportFormat;
  /** For CSV */
  delimiter: string;
  /** For CSV */
  quoteChar: string;
  /** For CSV */
  escapeChar: string;
  /** For CSV */
  hasHeader: boolean;
  encoding: string;
  skipErrors: boolean;
  batchSize: number;
  /** Source -> Target column mapping */
  columnMapping: { [key: string]: string };
}

export interface ImportOptions_ColumnMappingEntry {
  key: string;
  value: string;
}

/** Bulk import request */
export interface BulkImportRequest {
  connectionId: string;
  schemaName: string;
  tableName: string;
  /** File data or first chunk */
  data: Uint8Array;
  options:
    | ImportOptions
    | undefined;
  /** Auto-create table from data */
  createTable: boolean;
  truncateFirst: boolean;
}

/** Import statistics */
export interface ImportStats {
  rowsProcessed: Long;
  rowsImported: Long;
  rowsSkipped: Long;
  rowsFailed: Long;
  startedAt: Date | undefined;
  completedAt: Date | undefined;
  completed: boolean;
}

/** Bulk import response */
export interface BulkImportResponse {
  progress?: ImportStats | undefined;
  error?: string | undefined;
  completion?: ImportStats | undefined;
}

/** Export options */
export interface ExportOptions {
  format: ExportFormat;
  /** For CSV */
  delimiter: string;
  /** For CSV */
  quoteChar: string;
  /** For CSV */
  includeHeader: boolean;
  encoding: string;
  batchSize: number;
  compress: boolean;
}

/** Export table request */
export interface ExportTableRequest {
  connectionId: string;
  schemaName: string;
  tableName: string;
  /** Empty means all columns */
  columns: string[];
  filters: FilterSpec[];
  sorts: SortSpec[];
  options: ExportOptions | undefined;
}

/** Export statistics */
export interface ExportStats {
  rowsProcessed: Long;
  bytesWritten: Long;
  startedAt: Date | undefined;
  completedAt: Date | undefined;
  completed: boolean;
}

/** Export table response */
export interface ExportTableResponse {
  data?: Uint8Array | undefined;
  progress?: ExportStats | undefined;
  error?: string | undefined;
  completion?: ExportStats | undefined;
}

function createBaseSortSpec(): SortSpec {
  return { column: "", direction: SortDirection.SORT_DIRECTION_UNSPECIFIED };
}

export const SortSpec: MessageFns<SortSpec> = {
  encode(message: SortSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.column !== "") {
      writer.uint32(10).string(message.column);
    }
    if (message.direction !== SortDirection.SORT_DIRECTION_UNSPECIFIED) {
      writer.uint32(16).int32(sortDirectionToNumber(message.direction));
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SortSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSortSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.column = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.direction = sortDirectionFromJSON(reader.int32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SortSpec {
    return {
      column: isSet(object.column) ? globalThis.String(object.column) : "",
      direction: isSet(object.direction)
        ? sortDirectionFromJSON(object.direction)
        : SortDirection.SORT_DIRECTION_UNSPECIFIED,
    };
  },

  toJSON(message: SortSpec): unknown {
    const obj: any = {};
    if (message.column !== "") {
      obj.column = message.column;
    }
    if (message.direction !== SortDirection.SORT_DIRECTION_UNSPECIFIED) {
      obj.direction = sortDirectionToJSON(message.direction);
    }
    return obj;
  },

  create(base?: DeepPartial<SortSpec>): SortSpec {
    return SortSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SortSpec>): SortSpec {
    const message = createBaseSortSpec();
    message.column = object.column ?? "";
    message.direction = object.direction ?? SortDirection.SORT_DIRECTION_UNSPECIFIED;
    return message;
  },
};

function createBaseFilterSpec(): FilterSpec {
  return { column: "", operator: FilterOperator.FILTER_OPERATOR_UNSPECIFIED, values: [] };
}

export const FilterSpec: MessageFns<FilterSpec> = {
  encode(message: FilterSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.column !== "") {
      writer.uint32(10).string(message.column);
    }
    if (message.operator !== FilterOperator.FILTER_OPERATOR_UNSPECIFIED) {
      writer.uint32(16).int32(filterOperatorToNumber(message.operator));
    }
    for (const v of message.values) {
      Any.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FilterSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFilterSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.column = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.operator = filterOperatorFromJSON(reader.int32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.values.push(Any.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FilterSpec {
    return {
      column: isSet(object.column) ? globalThis.String(object.column) : "",
      operator: isSet(object.operator)
        ? filterOperatorFromJSON(object.operator)
        : FilterOperator.FILTER_OPERATOR_UNSPECIFIED,
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => Any.fromJSON(e)) : [],
    };
  },

  toJSON(message: FilterSpec): unknown {
    const obj: any = {};
    if (message.column !== "") {
      obj.column = message.column;
    }
    if (message.operator !== FilterOperator.FILTER_OPERATOR_UNSPECIFIED) {
      obj.operator = filterOperatorToJSON(message.operator);
    }
    if (message.values?.length) {
      obj.values = message.values.map((e) => Any.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<FilterSpec>): FilterSpec {
    return FilterSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FilterSpec>): FilterSpec {
    const message = createBaseFilterSpec();
    message.column = object.column ?? "";
    message.operator = object.operator ?? FilterOperator.FILTER_OPERATOR_UNSPECIFIED;
    message.values = object.values?.map((e) => Any.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetTableDataRequest(): GetTableDataRequest {
  return {
    connectionId: "",
    schemaName: "",
    tableName: "",
    columns: [],
    filters: [],
    sorts: [],
    limit: 0,
    offset: 0,
    includeTotalCount: false,
  };
}

export const GetTableDataRequest: MessageFns<GetTableDataRequest> = {
  encode(message: GetTableDataRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.connectionId !== "") {
      writer.uint32(10).string(message.connectionId);
    }
    if (message.schemaName !== "") {
      writer.uint32(18).string(message.schemaName);
    }
    if (message.tableName !== "") {
      writer.uint32(26).string(message.tableName);
    }
    for (const v of message.columns) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.filters) {
      FilterSpec.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.sorts) {
      SortSpec.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.limit !== 0) {
      writer.uint32(56).int32(message.limit);
    }
    if (message.offset !== 0) {
      writer.uint32(64).int32(message.offset);
    }
    if (message.includeTotalCount !== false) {
      writer.uint32(72).bool(message.includeTotalCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTableDataRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTableDataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.connectionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.schemaName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tableName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.columns.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.filters.push(FilterSpec.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.sorts.push(SortSpec.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.offset = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.includeTotalCount = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTableDataRequest {
    return {
      connectionId: isSet(object.connectionId) ? globalThis.String(object.connectionId) : "",
      schemaName: isSet(object.schemaName) ? globalThis.String(object.schemaName) : "",
      tableName: isSet(object.tableName) ? globalThis.String(object.tableName) : "",
      columns: globalThis.Array.isArray(object?.columns) ? object.columns.map((e: any) => globalThis.String(e)) : [],
      filters: globalThis.Array.isArray(object?.filters) ? object.filters.map((e: any) => FilterSpec.fromJSON(e)) : [],
      sorts: globalThis.Array.isArray(object?.sorts) ? object.sorts.map((e: any) => SortSpec.fromJSON(e)) : [],
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
      includeTotalCount: isSet(object.includeTotalCount) ? globalThis.Boolean(object.includeTotalCount) : false,
    };
  },

  toJSON(message: GetTableDataRequest): unknown {
    const obj: any = {};
    if (message.connectionId !== "") {
      obj.connectionId = message.connectionId;
    }
    if (message.schemaName !== "") {
      obj.schemaName = message.schemaName;
    }
    if (message.tableName !== "") {
      obj.tableName = message.tableName;
    }
    if (message.columns?.length) {
      obj.columns = message.columns;
    }
    if (message.filters?.length) {
      obj.filters = message.filters.map((e) => FilterSpec.toJSON(e));
    }
    if (message.sorts?.length) {
      obj.sorts = message.sorts.map((e) => SortSpec.toJSON(e));
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    if (message.includeTotalCount !== false) {
      obj.includeTotalCount = message.includeTotalCount;
    }
    return obj;
  },

  create(base?: DeepPartial<GetTableDataRequest>): GetTableDataRequest {
    return GetTableDataRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetTableDataRequest>): GetTableDataRequest {
    const message = createBaseGetTableDataRequest();
    message.connectionId = object.connectionId ?? "";
    message.schemaName = object.schemaName ?? "";
    message.tableName = object.tableName ?? "";
    message.columns = object.columns?.map((e) => e) || [];
    message.filters = object.filters?.map((e) => FilterSpec.fromPartial(e)) || [];
    message.sorts = object.sorts?.map((e) => SortSpec.fromPartial(e)) || [];
    message.limit = object.limit ?? 0;
    message.offset = object.offset ?? 0;
    message.includeTotalCount = object.includeTotalCount ?? false;
    return message;
  },
};

function createBaseTableRow(): TableRow {
  return { values: {}, version: Long.ZERO, updatedAt: undefined };
}

export const TableRow: MessageFns<TableRow> = {
  encode(message: TableRow, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.values).forEach(([key, value]) => {
      TableRow_ValuesEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    if (!message.version.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.version.toString());
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TableRow {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTableRow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = TableRow_ValuesEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.values[entry1.key] = entry1.value;
          }
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.version = Long.fromString(reader.int64().toString());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TableRow {
    return {
      values: isObject(object.values)
        ? Object.entries(object.values).reduce<{ [key: string]: Any }>((acc, [key, value]) => {
          acc[key] = Any.fromJSON(value);
          return acc;
        }, {})
        : {},
      version: isSet(object.version) ? Long.fromValue(object.version) : Long.ZERO,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
    };
  },

  toJSON(message: TableRow): unknown {
    const obj: any = {};
    if (message.values) {
      const entries = Object.entries(message.values);
      if (entries.length > 0) {
        obj.values = {};
        entries.forEach(([k, v]) => {
          obj.values[k] = Any.toJSON(v);
        });
      }
    }
    if (!message.version.equals(Long.ZERO)) {
      obj.version = (message.version || Long.ZERO).toString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<TableRow>): TableRow {
    return TableRow.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TableRow>): TableRow {
    const message = createBaseTableRow();
    message.values = Object.entries(object.values ?? {}).reduce<{ [key: string]: Any }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Any.fromPartial(value);
      }
      return acc;
    }, {});
    message.version = (object.version !== undefined && object.version !== null)
      ? Long.fromValue(object.version)
      : Long.ZERO;
    message.updatedAt = object.updatedAt ?? undefined;
    return message;
  },
};

function createBaseTableRow_ValuesEntry(): TableRow_ValuesEntry {
  return { key: "", value: undefined };
}

export const TableRow_ValuesEntry: MessageFns<TableRow_ValuesEntry> = {
  encode(message: TableRow_ValuesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Any.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TableRow_ValuesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTableRow_ValuesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Any.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TableRow_ValuesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Any.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: TableRow_ValuesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Any.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<TableRow_ValuesEntry>): TableRow_ValuesEntry {
    return TableRow_ValuesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TableRow_ValuesEntry>): TableRow_ValuesEntry {
    const message = createBaseTableRow_ValuesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Any.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseGetTableDataResponse(): GetTableDataResponse {
  return { success: false, message: "", rows: [], totalCount: Long.ZERO, hasMore: false, cursor: "" };
}

export const GetTableDataResponse: MessageFns<GetTableDataResponse> = {
  encode(message: GetTableDataResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    for (const v of message.rows) {
      TableRow.encode(v!, writer.uint32(26).fork()).join();
    }
    if (!message.totalCount.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.totalCount.toString());
    }
    if (message.hasMore !== false) {
      writer.uint32(40).bool(message.hasMore);
    }
    if (message.cursor !== "") {
      writer.uint32(50).string(message.cursor);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTableDataResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTableDataResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.rows.push(TableRow.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalCount = Long.fromString(reader.int64().toString());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.hasMore = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.cursor = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTableDataResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      rows: globalThis.Array.isArray(object?.rows) ? object.rows.map((e: any) => TableRow.fromJSON(e)) : [],
      totalCount: isSet(object.totalCount) ? Long.fromValue(object.totalCount) : Long.ZERO,
      hasMore: isSet(object.hasMore) ? globalThis.Boolean(object.hasMore) : false,
      cursor: isSet(object.cursor) ? globalThis.String(object.cursor) : "",
    };
  },

  toJSON(message: GetTableDataResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.rows?.length) {
      obj.rows = message.rows.map((e) => TableRow.toJSON(e));
    }
    if (!message.totalCount.equals(Long.ZERO)) {
      obj.totalCount = (message.totalCount || Long.ZERO).toString();
    }
    if (message.hasMore !== false) {
      obj.hasMore = message.hasMore;
    }
    if (message.cursor !== "") {
      obj.cursor = message.cursor;
    }
    return obj;
  },

  create(base?: DeepPartial<GetTableDataResponse>): GetTableDataResponse {
    return GetTableDataResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetTableDataResponse>): GetTableDataResponse {
    const message = createBaseGetTableDataResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.rows = object.rows?.map((e) => TableRow.fromPartial(e)) || [];
    message.totalCount = (object.totalCount !== undefined && object.totalCount !== null)
      ? Long.fromValue(object.totalCount)
      : Long.ZERO;
    message.hasMore = object.hasMore ?? false;
    message.cursor = object.cursor ?? "";
    return message;
  },
};

function createBaseGetTableDataStreamRequest(): GetTableDataStreamRequest {
  return { connectionId: "", schemaName: "", tableName: "", columns: [], filters: [], sorts: [], batchSize: 0 };
}

export const GetTableDataStreamRequest: MessageFns<GetTableDataStreamRequest> = {
  encode(message: GetTableDataStreamRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.connectionId !== "") {
      writer.uint32(10).string(message.connectionId);
    }
    if (message.schemaName !== "") {
      writer.uint32(18).string(message.schemaName);
    }
    if (message.tableName !== "") {
      writer.uint32(26).string(message.tableName);
    }
    for (const v of message.columns) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.filters) {
      FilterSpec.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.sorts) {
      SortSpec.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.batchSize !== 0) {
      writer.uint32(56).int32(message.batchSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTableDataStreamRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTableDataStreamRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.connectionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.schemaName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tableName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.columns.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.filters.push(FilterSpec.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.sorts.push(SortSpec.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.batchSize = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTableDataStreamRequest {
    return {
      connectionId: isSet(object.connectionId) ? globalThis.String(object.connectionId) : "",
      schemaName: isSet(object.schemaName) ? globalThis.String(object.schemaName) : "",
      tableName: isSet(object.tableName) ? globalThis.String(object.tableName) : "",
      columns: globalThis.Array.isArray(object?.columns) ? object.columns.map((e: any) => globalThis.String(e)) : [],
      filters: globalThis.Array.isArray(object?.filters) ? object.filters.map((e: any) => FilterSpec.fromJSON(e)) : [],
      sorts: globalThis.Array.isArray(object?.sorts) ? object.sorts.map((e: any) => SortSpec.fromJSON(e)) : [],
      batchSize: isSet(object.batchSize) ? globalThis.Number(object.batchSize) : 0,
    };
  },

  toJSON(message: GetTableDataStreamRequest): unknown {
    const obj: any = {};
    if (message.connectionId !== "") {
      obj.connectionId = message.connectionId;
    }
    if (message.schemaName !== "") {
      obj.schemaName = message.schemaName;
    }
    if (message.tableName !== "") {
      obj.tableName = message.tableName;
    }
    if (message.columns?.length) {
      obj.columns = message.columns;
    }
    if (message.filters?.length) {
      obj.filters = message.filters.map((e) => FilterSpec.toJSON(e));
    }
    if (message.sorts?.length) {
      obj.sorts = message.sorts.map((e) => SortSpec.toJSON(e));
    }
    if (message.batchSize !== 0) {
      obj.batchSize = Math.round(message.batchSize);
    }
    return obj;
  },

  create(base?: DeepPartial<GetTableDataStreamRequest>): GetTableDataStreamRequest {
    return GetTableDataStreamRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetTableDataStreamRequest>): GetTableDataStreamRequest {
    const message = createBaseGetTableDataStreamRequest();
    message.connectionId = object.connectionId ?? "";
    message.schemaName = object.schemaName ?? "";
    message.tableName = object.tableName ?? "";
    message.columns = object.columns?.map((e) => e) || [];
    message.filters = object.filters?.map((e) => FilterSpec.fromPartial(e)) || [];
    message.sorts = object.sorts?.map((e) => SortSpec.fromPartial(e)) || [];
    message.batchSize = object.batchSize ?? 0;
    return message;
  },
};

function createBaseTableDataStreamResponse(): TableDataStreamResponse {
  return { row: undefined, error: undefined, stats: undefined };
}

export const TableDataStreamResponse: MessageFns<TableDataStreamResponse> = {
  encode(message: TableDataStreamResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.row !== undefined) {
      TableRow.encode(message.row, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      writer.uint32(18).string(message.error);
    }
    if (message.stats !== undefined) {
      TableStreamStats.encode(message.stats, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TableDataStreamResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTableDataStreamResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.row = TableRow.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.stats = TableStreamStats.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TableDataStreamResponse {
    return {
      row: isSet(object.row) ? TableRow.fromJSON(object.row) : undefined,
      error: isSet(object.error) ? globalThis.String(object.error) : undefined,
      stats: isSet(object.stats) ? TableStreamStats.fromJSON(object.stats) : undefined,
    };
  },

  toJSON(message: TableDataStreamResponse): unknown {
    const obj: any = {};
    if (message.row !== undefined) {
      obj.row = TableRow.toJSON(message.row);
    }
    if (message.error !== undefined) {
      obj.error = message.error;
    }
    if (message.stats !== undefined) {
      obj.stats = TableStreamStats.toJSON(message.stats);
    }
    return obj;
  },

  create(base?: DeepPartial<TableDataStreamResponse>): TableDataStreamResponse {
    return TableDataStreamResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TableDataStreamResponse>): TableDataStreamResponse {
    const message = createBaseTableDataStreamResponse();
    message.row = (object.row !== undefined && object.row !== null) ? TableRow.fromPartial(object.row) : undefined;
    message.error = object.error ?? undefined;
    message.stats = (object.stats !== undefined && object.stats !== null)
      ? TableStreamStats.fromPartial(object.stats)
      : undefined;
    return message;
  },
};

function createBaseTableStreamStats(): TableStreamStats {
  return {
    rowsProcessed: Long.ZERO,
    totalRows: Long.ZERO,
    startedAt: undefined,
    completedAt: undefined,
    completed: false,
  };
}

export const TableStreamStats: MessageFns<TableStreamStats> = {
  encode(message: TableStreamStats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.rowsProcessed.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.rowsProcessed.toString());
    }
    if (!message.totalRows.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.totalRows.toString());
    }
    if (message.startedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.startedAt), writer.uint32(26).fork()).join();
    }
    if (message.completedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.completedAt), writer.uint32(34).fork()).join();
    }
    if (message.completed !== false) {
      writer.uint32(40).bool(message.completed);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TableStreamStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTableStreamStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.rowsProcessed = Long.fromString(reader.int64().toString());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalRows = Long.fromString(reader.int64().toString());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.startedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.completedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.completed = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TableStreamStats {
    return {
      rowsProcessed: isSet(object.rowsProcessed) ? Long.fromValue(object.rowsProcessed) : Long.ZERO,
      totalRows: isSet(object.totalRows) ? Long.fromValue(object.totalRows) : Long.ZERO,
      startedAt: isSet(object.startedAt) ? fromJsonTimestamp(object.startedAt) : undefined,
      completedAt: isSet(object.completedAt) ? fromJsonTimestamp(object.completedAt) : undefined,
      completed: isSet(object.completed) ? globalThis.Boolean(object.completed) : false,
    };
  },

  toJSON(message: TableStreamStats): unknown {
    const obj: any = {};
    if (!message.rowsProcessed.equals(Long.ZERO)) {
      obj.rowsProcessed = (message.rowsProcessed || Long.ZERO).toString();
    }
    if (!message.totalRows.equals(Long.ZERO)) {
      obj.totalRows = (message.totalRows || Long.ZERO).toString();
    }
    if (message.startedAt !== undefined) {
      obj.startedAt = message.startedAt.toISOString();
    }
    if (message.completedAt !== undefined) {
      obj.completedAt = message.completedAt.toISOString();
    }
    if (message.completed !== false) {
      obj.completed = message.completed;
    }
    return obj;
  },

  create(base?: DeepPartial<TableStreamStats>): TableStreamStats {
    return TableStreamStats.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TableStreamStats>): TableStreamStats {
    const message = createBaseTableStreamStats();
    message.rowsProcessed = (object.rowsProcessed !== undefined && object.rowsProcessed !== null)
      ? Long.fromValue(object.rowsProcessed)
      : Long.ZERO;
    message.totalRows = (object.totalRows !== undefined && object.totalRows !== null)
      ? Long.fromValue(object.totalRows)
      : Long.ZERO;
    message.startedAt = object.startedAt ?? undefined;
    message.completedAt = object.completedAt ?? undefined;
    message.completed = object.completed ?? false;
    return message;
  },
};

function createBaseUpdateTableRowRequest(): UpdateTableRowRequest {
  return {
    connectionId: "",
    schemaName: "",
    tableName: "",
    primaryKey: {},
    values: {},
    version: Long.ZERO,
    returnUpdatedRow: false,
  };
}

export const UpdateTableRowRequest: MessageFns<UpdateTableRowRequest> = {
  encode(message: UpdateTableRowRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.connectionId !== "") {
      writer.uint32(10).string(message.connectionId);
    }
    if (message.schemaName !== "") {
      writer.uint32(18).string(message.schemaName);
    }
    if (message.tableName !== "") {
      writer.uint32(26).string(message.tableName);
    }
    Object.entries(message.primaryKey).forEach(([key, value]) => {
      UpdateTableRowRequest_PrimaryKeyEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    Object.entries(message.values).forEach(([key, value]) => {
      UpdateTableRowRequest_ValuesEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    if (!message.version.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.version.toString());
    }
    if (message.returnUpdatedRow !== false) {
      writer.uint32(56).bool(message.returnUpdatedRow);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateTableRowRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateTableRowRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.connectionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.schemaName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tableName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = UpdateTableRowRequest_PrimaryKeyEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.primaryKey[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          const entry5 = UpdateTableRowRequest_ValuesEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.values[entry5.key] = entry5.value;
          }
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.version = Long.fromString(reader.int64().toString());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.returnUpdatedRow = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateTableRowRequest {
    return {
      connectionId: isSet(object.connectionId) ? globalThis.String(object.connectionId) : "",
      schemaName: isSet(object.schemaName) ? globalThis.String(object.schemaName) : "",
      tableName: isSet(object.tableName) ? globalThis.String(object.tableName) : "",
      primaryKey: isObject(object.primaryKey)
        ? Object.entries(object.primaryKey).reduce<{ [key: string]: Any }>((acc, [key, value]) => {
          acc[key] = Any.fromJSON(value);
          return acc;
        }, {})
        : {},
      values: isObject(object.values)
        ? Object.entries(object.values).reduce<{ [key: string]: Any }>((acc, [key, value]) => {
          acc[key] = Any.fromJSON(value);
          return acc;
        }, {})
        : {},
      version: isSet(object.version) ? Long.fromValue(object.version) : Long.ZERO,
      returnUpdatedRow: isSet(object.returnUpdatedRow) ? globalThis.Boolean(object.returnUpdatedRow) : false,
    };
  },

  toJSON(message: UpdateTableRowRequest): unknown {
    const obj: any = {};
    if (message.connectionId !== "") {
      obj.connectionId = message.connectionId;
    }
    if (message.schemaName !== "") {
      obj.schemaName = message.schemaName;
    }
    if (message.tableName !== "") {
      obj.tableName = message.tableName;
    }
    if (message.primaryKey) {
      const entries = Object.entries(message.primaryKey);
      if (entries.length > 0) {
        obj.primaryKey = {};
        entries.forEach(([k, v]) => {
          obj.primaryKey[k] = Any.toJSON(v);
        });
      }
    }
    if (message.values) {
      const entries = Object.entries(message.values);
      if (entries.length > 0) {
        obj.values = {};
        entries.forEach(([k, v]) => {
          obj.values[k] = Any.toJSON(v);
        });
      }
    }
    if (!message.version.equals(Long.ZERO)) {
      obj.version = (message.version || Long.ZERO).toString();
    }
    if (message.returnUpdatedRow !== false) {
      obj.returnUpdatedRow = message.returnUpdatedRow;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateTableRowRequest>): UpdateTableRowRequest {
    return UpdateTableRowRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateTableRowRequest>): UpdateTableRowRequest {
    const message = createBaseUpdateTableRowRequest();
    message.connectionId = object.connectionId ?? "";
    message.schemaName = object.schemaName ?? "";
    message.tableName = object.tableName ?? "";
    message.primaryKey = Object.entries(object.primaryKey ?? {}).reduce<{ [key: string]: Any }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Any.fromPartial(value);
      }
      return acc;
    }, {});
    message.values = Object.entries(object.values ?? {}).reduce<{ [key: string]: Any }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Any.fromPartial(value);
      }
      return acc;
    }, {});
    message.version = (object.version !== undefined && object.version !== null)
      ? Long.fromValue(object.version)
      : Long.ZERO;
    message.returnUpdatedRow = object.returnUpdatedRow ?? false;
    return message;
  },
};

function createBaseUpdateTableRowRequest_PrimaryKeyEntry(): UpdateTableRowRequest_PrimaryKeyEntry {
  return { key: "", value: undefined };
}

export const UpdateTableRowRequest_PrimaryKeyEntry: MessageFns<UpdateTableRowRequest_PrimaryKeyEntry> = {
  encode(message: UpdateTableRowRequest_PrimaryKeyEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Any.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateTableRowRequest_PrimaryKeyEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateTableRowRequest_PrimaryKeyEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Any.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateTableRowRequest_PrimaryKeyEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Any.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: UpdateTableRowRequest_PrimaryKeyEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Any.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateTableRowRequest_PrimaryKeyEntry>): UpdateTableRowRequest_PrimaryKeyEntry {
    return UpdateTableRowRequest_PrimaryKeyEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateTableRowRequest_PrimaryKeyEntry>): UpdateTableRowRequest_PrimaryKeyEntry {
    const message = createBaseUpdateTableRowRequest_PrimaryKeyEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Any.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseUpdateTableRowRequest_ValuesEntry(): UpdateTableRowRequest_ValuesEntry {
  return { key: "", value: undefined };
}

export const UpdateTableRowRequest_ValuesEntry: MessageFns<UpdateTableRowRequest_ValuesEntry> = {
  encode(message: UpdateTableRowRequest_ValuesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Any.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateTableRowRequest_ValuesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateTableRowRequest_ValuesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Any.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateTableRowRequest_ValuesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Any.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: UpdateTableRowRequest_ValuesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Any.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateTableRowRequest_ValuesEntry>): UpdateTableRowRequest_ValuesEntry {
    return UpdateTableRowRequest_ValuesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateTableRowRequest_ValuesEntry>): UpdateTableRowRequest_ValuesEntry {
    const message = createBaseUpdateTableRowRequest_ValuesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Any.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseUpdateTableRowResponse(): UpdateTableRowResponse {
  return { success: false, message: "", rowsAffected: Long.ZERO, updatedRow: undefined, newVersion: Long.ZERO };
}

export const UpdateTableRowResponse: MessageFns<UpdateTableRowResponse> = {
  encode(message: UpdateTableRowResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (!message.rowsAffected.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.rowsAffected.toString());
    }
    if (message.updatedRow !== undefined) {
      TableRow.encode(message.updatedRow, writer.uint32(34).fork()).join();
    }
    if (!message.newVersion.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.newVersion.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateTableRowResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateTableRowResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.rowsAffected = Long.fromString(reader.int64().toString());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.updatedRow = TableRow.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.newVersion = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateTableRowResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      rowsAffected: isSet(object.rowsAffected) ? Long.fromValue(object.rowsAffected) : Long.ZERO,
      updatedRow: isSet(object.updatedRow) ? TableRow.fromJSON(object.updatedRow) : undefined,
      newVersion: isSet(object.newVersion) ? Long.fromValue(object.newVersion) : Long.ZERO,
    };
  },

  toJSON(message: UpdateTableRowResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (!message.rowsAffected.equals(Long.ZERO)) {
      obj.rowsAffected = (message.rowsAffected || Long.ZERO).toString();
    }
    if (message.updatedRow !== undefined) {
      obj.updatedRow = TableRow.toJSON(message.updatedRow);
    }
    if (!message.newVersion.equals(Long.ZERO)) {
      obj.newVersion = (message.newVersion || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateTableRowResponse>): UpdateTableRowResponse {
    return UpdateTableRowResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateTableRowResponse>): UpdateTableRowResponse {
    const message = createBaseUpdateTableRowResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.rowsAffected = (object.rowsAffected !== undefined && object.rowsAffected !== null)
      ? Long.fromValue(object.rowsAffected)
      : Long.ZERO;
    message.updatedRow = (object.updatedRow !== undefined && object.updatedRow !== null)
      ? TableRow.fromPartial(object.updatedRow)
      : undefined;
    message.newVersion = (object.newVersion !== undefined && object.newVersion !== null)
      ? Long.fromValue(object.newVersion)
      : Long.ZERO;
    return message;
  },
};

function createBaseInsertTableRowRequest(): InsertTableRowRequest {
  return { connectionId: "", schemaName: "", tableName: "", values: {}, returnInsertedRow: false };
}

export const InsertTableRowRequest: MessageFns<InsertTableRowRequest> = {
  encode(message: InsertTableRowRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.connectionId !== "") {
      writer.uint32(10).string(message.connectionId);
    }
    if (message.schemaName !== "") {
      writer.uint32(18).string(message.schemaName);
    }
    if (message.tableName !== "") {
      writer.uint32(26).string(message.tableName);
    }
    Object.entries(message.values).forEach(([key, value]) => {
      InsertTableRowRequest_ValuesEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.returnInsertedRow !== false) {
      writer.uint32(40).bool(message.returnInsertedRow);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InsertTableRowRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInsertTableRowRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.connectionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.schemaName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tableName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = InsertTableRowRequest_ValuesEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.values[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.returnInsertedRow = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InsertTableRowRequest {
    return {
      connectionId: isSet(object.connectionId) ? globalThis.String(object.connectionId) : "",
      schemaName: isSet(object.schemaName) ? globalThis.String(object.schemaName) : "",
      tableName: isSet(object.tableName) ? globalThis.String(object.tableName) : "",
      values: isObject(object.values)
        ? Object.entries(object.values).reduce<{ [key: string]: Any }>((acc, [key, value]) => {
          acc[key] = Any.fromJSON(value);
          return acc;
        }, {})
        : {},
      returnInsertedRow: isSet(object.returnInsertedRow) ? globalThis.Boolean(object.returnInsertedRow) : false,
    };
  },

  toJSON(message: InsertTableRowRequest): unknown {
    const obj: any = {};
    if (message.connectionId !== "") {
      obj.connectionId = message.connectionId;
    }
    if (message.schemaName !== "") {
      obj.schemaName = message.schemaName;
    }
    if (message.tableName !== "") {
      obj.tableName = message.tableName;
    }
    if (message.values) {
      const entries = Object.entries(message.values);
      if (entries.length > 0) {
        obj.values = {};
        entries.forEach(([k, v]) => {
          obj.values[k] = Any.toJSON(v);
        });
      }
    }
    if (message.returnInsertedRow !== false) {
      obj.returnInsertedRow = message.returnInsertedRow;
    }
    return obj;
  },

  create(base?: DeepPartial<InsertTableRowRequest>): InsertTableRowRequest {
    return InsertTableRowRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InsertTableRowRequest>): InsertTableRowRequest {
    const message = createBaseInsertTableRowRequest();
    message.connectionId = object.connectionId ?? "";
    message.schemaName = object.schemaName ?? "";
    message.tableName = object.tableName ?? "";
    message.values = Object.entries(object.values ?? {}).reduce<{ [key: string]: Any }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Any.fromPartial(value);
      }
      return acc;
    }, {});
    message.returnInsertedRow = object.returnInsertedRow ?? false;
    return message;
  },
};

function createBaseInsertTableRowRequest_ValuesEntry(): InsertTableRowRequest_ValuesEntry {
  return { key: "", value: undefined };
}

export const InsertTableRowRequest_ValuesEntry: MessageFns<InsertTableRowRequest_ValuesEntry> = {
  encode(message: InsertTableRowRequest_ValuesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Any.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InsertTableRowRequest_ValuesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInsertTableRowRequest_ValuesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Any.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InsertTableRowRequest_ValuesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Any.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: InsertTableRowRequest_ValuesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Any.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<InsertTableRowRequest_ValuesEntry>): InsertTableRowRequest_ValuesEntry {
    return InsertTableRowRequest_ValuesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InsertTableRowRequest_ValuesEntry>): InsertTableRowRequest_ValuesEntry {
    const message = createBaseInsertTableRowRequest_ValuesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Any.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseInsertTableRowResponse(): InsertTableRowResponse {
  return { success: false, message: "", insertedRow: undefined, generatedValues: {} };
}

export const InsertTableRowResponse: MessageFns<InsertTableRowResponse> = {
  encode(message: InsertTableRowResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.insertedRow !== undefined) {
      TableRow.encode(message.insertedRow, writer.uint32(26).fork()).join();
    }
    Object.entries(message.generatedValues).forEach(([key, value]) => {
      InsertTableRowResponse_GeneratedValuesEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InsertTableRowResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInsertTableRowResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.insertedRow = TableRow.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = InsertTableRowResponse_GeneratedValuesEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.generatedValues[entry4.key] = entry4.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InsertTableRowResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      insertedRow: isSet(object.insertedRow) ? TableRow.fromJSON(object.insertedRow) : undefined,
      generatedValues: isObject(object.generatedValues)
        ? Object.entries(object.generatedValues).reduce<{ [key: string]: Any }>((acc, [key, value]) => {
          acc[key] = Any.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: InsertTableRowResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.insertedRow !== undefined) {
      obj.insertedRow = TableRow.toJSON(message.insertedRow);
    }
    if (message.generatedValues) {
      const entries = Object.entries(message.generatedValues);
      if (entries.length > 0) {
        obj.generatedValues = {};
        entries.forEach(([k, v]) => {
          obj.generatedValues[k] = Any.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<InsertTableRowResponse>): InsertTableRowResponse {
    return InsertTableRowResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InsertTableRowResponse>): InsertTableRowResponse {
    const message = createBaseInsertTableRowResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.insertedRow = (object.insertedRow !== undefined && object.insertedRow !== null)
      ? TableRow.fromPartial(object.insertedRow)
      : undefined;
    message.generatedValues = Object.entries(object.generatedValues ?? {}).reduce<{ [key: string]: Any }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = Any.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseInsertTableRowResponse_GeneratedValuesEntry(): InsertTableRowResponse_GeneratedValuesEntry {
  return { key: "", value: undefined };
}

export const InsertTableRowResponse_GeneratedValuesEntry: MessageFns<InsertTableRowResponse_GeneratedValuesEntry> = {
  encode(
    message: InsertTableRowResponse_GeneratedValuesEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Any.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InsertTableRowResponse_GeneratedValuesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInsertTableRowResponse_GeneratedValuesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Any.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InsertTableRowResponse_GeneratedValuesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Any.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: InsertTableRowResponse_GeneratedValuesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Any.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<InsertTableRowResponse_GeneratedValuesEntry>): InsertTableRowResponse_GeneratedValuesEntry {
    return InsertTableRowResponse_GeneratedValuesEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<InsertTableRowResponse_GeneratedValuesEntry>,
  ): InsertTableRowResponse_GeneratedValuesEntry {
    const message = createBaseInsertTableRowResponse_GeneratedValuesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Any.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseDeleteTableRowRequest(): DeleteTableRowRequest {
  return { connectionId: "", schemaName: "", tableName: "", primaryKey: {}, version: Long.ZERO };
}

export const DeleteTableRowRequest: MessageFns<DeleteTableRowRequest> = {
  encode(message: DeleteTableRowRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.connectionId !== "") {
      writer.uint32(10).string(message.connectionId);
    }
    if (message.schemaName !== "") {
      writer.uint32(18).string(message.schemaName);
    }
    if (message.tableName !== "") {
      writer.uint32(26).string(message.tableName);
    }
    Object.entries(message.primaryKey).forEach(([key, value]) => {
      DeleteTableRowRequest_PrimaryKeyEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (!message.version.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.version.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteTableRowRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteTableRowRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.connectionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.schemaName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tableName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = DeleteTableRowRequest_PrimaryKeyEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.primaryKey[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.version = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteTableRowRequest {
    return {
      connectionId: isSet(object.connectionId) ? globalThis.String(object.connectionId) : "",
      schemaName: isSet(object.schemaName) ? globalThis.String(object.schemaName) : "",
      tableName: isSet(object.tableName) ? globalThis.String(object.tableName) : "",
      primaryKey: isObject(object.primaryKey)
        ? Object.entries(object.primaryKey).reduce<{ [key: string]: Any }>((acc, [key, value]) => {
          acc[key] = Any.fromJSON(value);
          return acc;
        }, {})
        : {},
      version: isSet(object.version) ? Long.fromValue(object.version) : Long.ZERO,
    };
  },

  toJSON(message: DeleteTableRowRequest): unknown {
    const obj: any = {};
    if (message.connectionId !== "") {
      obj.connectionId = message.connectionId;
    }
    if (message.schemaName !== "") {
      obj.schemaName = message.schemaName;
    }
    if (message.tableName !== "") {
      obj.tableName = message.tableName;
    }
    if (message.primaryKey) {
      const entries = Object.entries(message.primaryKey);
      if (entries.length > 0) {
        obj.primaryKey = {};
        entries.forEach(([k, v]) => {
          obj.primaryKey[k] = Any.toJSON(v);
        });
      }
    }
    if (!message.version.equals(Long.ZERO)) {
      obj.version = (message.version || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteTableRowRequest>): DeleteTableRowRequest {
    return DeleteTableRowRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteTableRowRequest>): DeleteTableRowRequest {
    const message = createBaseDeleteTableRowRequest();
    message.connectionId = object.connectionId ?? "";
    message.schemaName = object.schemaName ?? "";
    message.tableName = object.tableName ?? "";
    message.primaryKey = Object.entries(object.primaryKey ?? {}).reduce<{ [key: string]: Any }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Any.fromPartial(value);
      }
      return acc;
    }, {});
    message.version = (object.version !== undefined && object.version !== null)
      ? Long.fromValue(object.version)
      : Long.ZERO;
    return message;
  },
};

function createBaseDeleteTableRowRequest_PrimaryKeyEntry(): DeleteTableRowRequest_PrimaryKeyEntry {
  return { key: "", value: undefined };
}

export const DeleteTableRowRequest_PrimaryKeyEntry: MessageFns<DeleteTableRowRequest_PrimaryKeyEntry> = {
  encode(message: DeleteTableRowRequest_PrimaryKeyEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Any.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteTableRowRequest_PrimaryKeyEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteTableRowRequest_PrimaryKeyEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Any.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteTableRowRequest_PrimaryKeyEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Any.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: DeleteTableRowRequest_PrimaryKeyEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Any.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteTableRowRequest_PrimaryKeyEntry>): DeleteTableRowRequest_PrimaryKeyEntry {
    return DeleteTableRowRequest_PrimaryKeyEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteTableRowRequest_PrimaryKeyEntry>): DeleteTableRowRequest_PrimaryKeyEntry {
    const message = createBaseDeleteTableRowRequest_PrimaryKeyEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Any.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseDeleteTableRowResponse(): DeleteTableRowResponse {
  return { success: false, message: "", rowsAffected: Long.ZERO };
}

export const DeleteTableRowResponse: MessageFns<DeleteTableRowResponse> = {
  encode(message: DeleteTableRowResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (!message.rowsAffected.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.rowsAffected.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteTableRowResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteTableRowResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.rowsAffected = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteTableRowResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      rowsAffected: isSet(object.rowsAffected) ? Long.fromValue(object.rowsAffected) : Long.ZERO,
    };
  },

  toJSON(message: DeleteTableRowResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (!message.rowsAffected.equals(Long.ZERO)) {
      obj.rowsAffected = (message.rowsAffected || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteTableRowResponse>): DeleteTableRowResponse {
    return DeleteTableRowResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteTableRowResponse>): DeleteTableRowResponse {
    const message = createBaseDeleteTableRowResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.rowsAffected = (object.rowsAffected !== undefined && object.rowsAffected !== null)
      ? Long.fromValue(object.rowsAffected)
      : Long.ZERO;
    return message;
  },
};

function createBaseColumnDefinition(): ColumnDefinition {
  return {
    name: "",
    dataType: "",
    nullable: false,
    defaultValue: "",
    primaryKey: false,
    unique: false,
    autoIncrement: false,
    comment: "",
    checkConstraint: "",
    attributes: {},
  };
}

export const ColumnDefinition: MessageFns<ColumnDefinition> = {
  encode(message: ColumnDefinition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.dataType !== "") {
      writer.uint32(18).string(message.dataType);
    }
    if (message.nullable !== false) {
      writer.uint32(24).bool(message.nullable);
    }
    if (message.defaultValue !== "") {
      writer.uint32(34).string(message.defaultValue);
    }
    if (message.primaryKey !== false) {
      writer.uint32(40).bool(message.primaryKey);
    }
    if (message.unique !== false) {
      writer.uint32(48).bool(message.unique);
    }
    if (message.autoIncrement !== false) {
      writer.uint32(56).bool(message.autoIncrement);
    }
    if (message.comment !== "") {
      writer.uint32(66).string(message.comment);
    }
    if (message.checkConstraint !== "") {
      writer.uint32(74).string(message.checkConstraint);
    }
    Object.entries(message.attributes).forEach(([key, value]) => {
      ColumnDefinition_AttributesEntry.encode({ key: key as any, value }, writer.uint32(82).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ColumnDefinition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseColumnDefinition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.dataType = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.nullable = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.defaultValue = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.primaryKey = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.unique = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.autoIncrement = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.comment = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.checkConstraint = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          const entry10 = ColumnDefinition_AttributesEntry.decode(reader, reader.uint32());
          if (entry10.value !== undefined) {
            message.attributes[entry10.key] = entry10.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ColumnDefinition {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      dataType: isSet(object.dataType) ? globalThis.String(object.dataType) : "",
      nullable: isSet(object.nullable) ? globalThis.Boolean(object.nullable) : false,
      defaultValue: isSet(object.defaultValue) ? globalThis.String(object.defaultValue) : "",
      primaryKey: isSet(object.primaryKey) ? globalThis.Boolean(object.primaryKey) : false,
      unique: isSet(object.unique) ? globalThis.Boolean(object.unique) : false,
      autoIncrement: isSet(object.autoIncrement) ? globalThis.Boolean(object.autoIncrement) : false,
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      checkConstraint: isSet(object.checkConstraint) ? globalThis.String(object.checkConstraint) : "",
      attributes: isObject(object.attributes)
        ? Object.entries(object.attributes).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: ColumnDefinition): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.dataType !== "") {
      obj.dataType = message.dataType;
    }
    if (message.nullable !== false) {
      obj.nullable = message.nullable;
    }
    if (message.defaultValue !== "") {
      obj.defaultValue = message.defaultValue;
    }
    if (message.primaryKey !== false) {
      obj.primaryKey = message.primaryKey;
    }
    if (message.unique !== false) {
      obj.unique = message.unique;
    }
    if (message.autoIncrement !== false) {
      obj.autoIncrement = message.autoIncrement;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.checkConstraint !== "") {
      obj.checkConstraint = message.checkConstraint;
    }
    if (message.attributes) {
      const entries = Object.entries(message.attributes);
      if (entries.length > 0) {
        obj.attributes = {};
        entries.forEach(([k, v]) => {
          obj.attributes[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<ColumnDefinition>): ColumnDefinition {
    return ColumnDefinition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ColumnDefinition>): ColumnDefinition {
    const message = createBaseColumnDefinition();
    message.name = object.name ?? "";
    message.dataType = object.dataType ?? "";
    message.nullable = object.nullable ?? false;
    message.defaultValue = object.defaultValue ?? "";
    message.primaryKey = object.primaryKey ?? false;
    message.unique = object.unique ?? false;
    message.autoIncrement = object.autoIncrement ?? false;
    message.comment = object.comment ?? "";
    message.checkConstraint = object.checkConstraint ?? "";
    message.attributes = Object.entries(object.attributes ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseColumnDefinition_AttributesEntry(): ColumnDefinition_AttributesEntry {
  return { key: "", value: "" };
}

export const ColumnDefinition_AttributesEntry: MessageFns<ColumnDefinition_AttributesEntry> = {
  encode(message: ColumnDefinition_AttributesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ColumnDefinition_AttributesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseColumnDefinition_AttributesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ColumnDefinition_AttributesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ColumnDefinition_AttributesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<ColumnDefinition_AttributesEntry>): ColumnDefinition_AttributesEntry {
    return ColumnDefinition_AttributesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ColumnDefinition_AttributesEntry>): ColumnDefinition_AttributesEntry {
    const message = createBaseColumnDefinition_AttributesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseIndexDefinition(): IndexDefinition {
  return { name: "", columns: [], unique: false, type: "", method: "", whereClause: "" };
}

export const IndexDefinition: MessageFns<IndexDefinition> = {
  encode(message: IndexDefinition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.columns) {
      writer.uint32(18).string(v!);
    }
    if (message.unique !== false) {
      writer.uint32(24).bool(message.unique);
    }
    if (message.type !== "") {
      writer.uint32(34).string(message.type);
    }
    if (message.method !== "") {
      writer.uint32(42).string(message.method);
    }
    if (message.whereClause !== "") {
      writer.uint32(50).string(message.whereClause);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IndexDefinition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIndexDefinition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.columns.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.unique = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.method = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.whereClause = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IndexDefinition {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      columns: globalThis.Array.isArray(object?.columns) ? object.columns.map((e: any) => globalThis.String(e)) : [],
      unique: isSet(object.unique) ? globalThis.Boolean(object.unique) : false,
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      method: isSet(object.method) ? globalThis.String(object.method) : "",
      whereClause: isSet(object.whereClause) ? globalThis.String(object.whereClause) : "",
    };
  },

  toJSON(message: IndexDefinition): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.columns?.length) {
      obj.columns = message.columns;
    }
    if (message.unique !== false) {
      obj.unique = message.unique;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.method !== "") {
      obj.method = message.method;
    }
    if (message.whereClause !== "") {
      obj.whereClause = message.whereClause;
    }
    return obj;
  },

  create(base?: DeepPartial<IndexDefinition>): IndexDefinition {
    return IndexDefinition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IndexDefinition>): IndexDefinition {
    const message = createBaseIndexDefinition();
    message.name = object.name ?? "";
    message.columns = object.columns?.map((e) => e) || [];
    message.unique = object.unique ?? false;
    message.type = object.type ?? "";
    message.method = object.method ?? "";
    message.whereClause = object.whereClause ?? "";
    return message;
  },
};

function createBaseForeignKeyDefinition(): ForeignKeyDefinition {
  return {
    name: "",
    columns: [],
    referencedTable: "",
    referencedSchema: "",
    referencedColumns: [],
    onDelete: "",
    onUpdate: "",
  };
}

export const ForeignKeyDefinition: MessageFns<ForeignKeyDefinition> = {
  encode(message: ForeignKeyDefinition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.columns) {
      writer.uint32(18).string(v!);
    }
    if (message.referencedTable !== "") {
      writer.uint32(26).string(message.referencedTable);
    }
    if (message.referencedSchema !== "") {
      writer.uint32(34).string(message.referencedSchema);
    }
    for (const v of message.referencedColumns) {
      writer.uint32(42).string(v!);
    }
    if (message.onDelete !== "") {
      writer.uint32(50).string(message.onDelete);
    }
    if (message.onUpdate !== "") {
      writer.uint32(58).string(message.onUpdate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ForeignKeyDefinition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseForeignKeyDefinition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.columns.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.referencedTable = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.referencedSchema = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.referencedColumns.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.onDelete = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.onUpdate = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ForeignKeyDefinition {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      columns: globalThis.Array.isArray(object?.columns) ? object.columns.map((e: any) => globalThis.String(e)) : [],
      referencedTable: isSet(object.referencedTable) ? globalThis.String(object.referencedTable) : "",
      referencedSchema: isSet(object.referencedSchema) ? globalThis.String(object.referencedSchema) : "",
      referencedColumns: globalThis.Array.isArray(object?.referencedColumns)
        ? object.referencedColumns.map((e: any) => globalThis.String(e))
        : [],
      onDelete: isSet(object.onDelete) ? globalThis.String(object.onDelete) : "",
      onUpdate: isSet(object.onUpdate) ? globalThis.String(object.onUpdate) : "",
    };
  },

  toJSON(message: ForeignKeyDefinition): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.columns?.length) {
      obj.columns = message.columns;
    }
    if (message.referencedTable !== "") {
      obj.referencedTable = message.referencedTable;
    }
    if (message.referencedSchema !== "") {
      obj.referencedSchema = message.referencedSchema;
    }
    if (message.referencedColumns?.length) {
      obj.referencedColumns = message.referencedColumns;
    }
    if (message.onDelete !== "") {
      obj.onDelete = message.onDelete;
    }
    if (message.onUpdate !== "") {
      obj.onUpdate = message.onUpdate;
    }
    return obj;
  },

  create(base?: DeepPartial<ForeignKeyDefinition>): ForeignKeyDefinition {
    return ForeignKeyDefinition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ForeignKeyDefinition>): ForeignKeyDefinition {
    const message = createBaseForeignKeyDefinition();
    message.name = object.name ?? "";
    message.columns = object.columns?.map((e) => e) || [];
    message.referencedTable = object.referencedTable ?? "";
    message.referencedSchema = object.referencedSchema ?? "";
    message.referencedColumns = object.referencedColumns?.map((e) => e) || [];
    message.onDelete = object.onDelete ?? "";
    message.onUpdate = object.onUpdate ?? "";
    return message;
  },
};

function createBaseCreateTableRequest(): CreateTableRequest {
  return {
    connectionId: "",
    schemaName: "",
    tableName: "",
    columns: [],
    indexes: [],
    foreignKeys: [],
    comment: "",
    options: {},
    ifNotExists: false,
  };
}

export const CreateTableRequest: MessageFns<CreateTableRequest> = {
  encode(message: CreateTableRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.connectionId !== "") {
      writer.uint32(10).string(message.connectionId);
    }
    if (message.schemaName !== "") {
      writer.uint32(18).string(message.schemaName);
    }
    if (message.tableName !== "") {
      writer.uint32(26).string(message.tableName);
    }
    for (const v of message.columns) {
      ColumnDefinition.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.indexes) {
      IndexDefinition.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.foreignKeys) {
      ForeignKeyDefinition.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.comment !== "") {
      writer.uint32(58).string(message.comment);
    }
    Object.entries(message.options).forEach(([key, value]) => {
      CreateTableRequest_OptionsEntry.encode({ key: key as any, value }, writer.uint32(66).fork()).join();
    });
    if (message.ifNotExists !== false) {
      writer.uint32(72).bool(message.ifNotExists);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateTableRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateTableRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.connectionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.schemaName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tableName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.columns.push(ColumnDefinition.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.indexes.push(IndexDefinition.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.foreignKeys.push(ForeignKeyDefinition.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.comment = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          const entry8 = CreateTableRequest_OptionsEntry.decode(reader, reader.uint32());
          if (entry8.value !== undefined) {
            message.options[entry8.key] = entry8.value;
          }
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.ifNotExists = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateTableRequest {
    return {
      connectionId: isSet(object.connectionId) ? globalThis.String(object.connectionId) : "",
      schemaName: isSet(object.schemaName) ? globalThis.String(object.schemaName) : "",
      tableName: isSet(object.tableName) ? globalThis.String(object.tableName) : "",
      columns: globalThis.Array.isArray(object?.columns)
        ? object.columns.map((e: any) => ColumnDefinition.fromJSON(e))
        : [],
      indexes: globalThis.Array.isArray(object?.indexes)
        ? object.indexes.map((e: any) => IndexDefinition.fromJSON(e))
        : [],
      foreignKeys: globalThis.Array.isArray(object?.foreignKeys)
        ? object.foreignKeys.map((e: any) => ForeignKeyDefinition.fromJSON(e))
        : [],
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      options: isObject(object.options)
        ? Object.entries(object.options).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      ifNotExists: isSet(object.ifNotExists) ? globalThis.Boolean(object.ifNotExists) : false,
    };
  },

  toJSON(message: CreateTableRequest): unknown {
    const obj: any = {};
    if (message.connectionId !== "") {
      obj.connectionId = message.connectionId;
    }
    if (message.schemaName !== "") {
      obj.schemaName = message.schemaName;
    }
    if (message.tableName !== "") {
      obj.tableName = message.tableName;
    }
    if (message.columns?.length) {
      obj.columns = message.columns.map((e) => ColumnDefinition.toJSON(e));
    }
    if (message.indexes?.length) {
      obj.indexes = message.indexes.map((e) => IndexDefinition.toJSON(e));
    }
    if (message.foreignKeys?.length) {
      obj.foreignKeys = message.foreignKeys.map((e) => ForeignKeyDefinition.toJSON(e));
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.options) {
      const entries = Object.entries(message.options);
      if (entries.length > 0) {
        obj.options = {};
        entries.forEach(([k, v]) => {
          obj.options[k] = v;
        });
      }
    }
    if (message.ifNotExists !== false) {
      obj.ifNotExists = message.ifNotExists;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateTableRequest>): CreateTableRequest {
    return CreateTableRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateTableRequest>): CreateTableRequest {
    const message = createBaseCreateTableRequest();
    message.connectionId = object.connectionId ?? "";
    message.schemaName = object.schemaName ?? "";
    message.tableName = object.tableName ?? "";
    message.columns = object.columns?.map((e) => ColumnDefinition.fromPartial(e)) || [];
    message.indexes = object.indexes?.map((e) => IndexDefinition.fromPartial(e)) || [];
    message.foreignKeys = object.foreignKeys?.map((e) => ForeignKeyDefinition.fromPartial(e)) || [];
    message.comment = object.comment ?? "";
    message.options = Object.entries(object.options ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.ifNotExists = object.ifNotExists ?? false;
    return message;
  },
};

function createBaseCreateTableRequest_OptionsEntry(): CreateTableRequest_OptionsEntry {
  return { key: "", value: "" };
}

export const CreateTableRequest_OptionsEntry: MessageFns<CreateTableRequest_OptionsEntry> = {
  encode(message: CreateTableRequest_OptionsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateTableRequest_OptionsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateTableRequest_OptionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateTableRequest_OptionsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CreateTableRequest_OptionsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateTableRequest_OptionsEntry>): CreateTableRequest_OptionsEntry {
    return CreateTableRequest_OptionsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateTableRequest_OptionsEntry>): CreateTableRequest_OptionsEntry {
    const message = createBaseCreateTableRequest_OptionsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCreateTableResponse(): CreateTableResponse {
  return { success: false, message: "", sql: "" };
}

export const CreateTableResponse: MessageFns<CreateTableResponse> = {
  encode(message: CreateTableResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.sql !== "") {
      writer.uint32(26).string(message.sql);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateTableResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateTableResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sql = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateTableResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      sql: isSet(object.sql) ? globalThis.String(object.sql) : "",
    };
  },

  toJSON(message: CreateTableResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.sql !== "") {
      obj.sql = message.sql;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateTableResponse>): CreateTableResponse {
    return CreateTableResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateTableResponse>): CreateTableResponse {
    const message = createBaseCreateTableResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.sql = object.sql ?? "";
    return message;
  },
};

function createBaseAlterTableOperation(): AlterTableOperation {
  return {
    operation: AlterOperation.ALTER_OPERATION_UNSPECIFIED,
    addColumn: undefined,
    dropColumn: undefined,
    modifyColumn: undefined,
    renameColumn: undefined,
    addIndex: undefined,
    dropIndex: undefined,
    addForeignKey: undefined,
    dropForeignKey: undefined,
    renameTable: undefined,
    setComment: undefined,
  };
}

export const AlterTableOperation: MessageFns<AlterTableOperation> = {
  encode(message: AlterTableOperation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.operation !== AlterOperation.ALTER_OPERATION_UNSPECIFIED) {
      writer.uint32(8).int32(alterOperationToNumber(message.operation));
    }
    if (message.addColumn !== undefined) {
      ColumnDefinition.encode(message.addColumn, writer.uint32(18).fork()).join();
    }
    if (message.dropColumn !== undefined) {
      writer.uint32(26).string(message.dropColumn);
    }
    if (message.modifyColumn !== undefined) {
      ColumnDefinition.encode(message.modifyColumn, writer.uint32(34).fork()).join();
    }
    if (message.renameColumn !== undefined) {
      RenameColumnDetails.encode(message.renameColumn, writer.uint32(42).fork()).join();
    }
    if (message.addIndex !== undefined) {
      IndexDefinition.encode(message.addIndex, writer.uint32(50).fork()).join();
    }
    if (message.dropIndex !== undefined) {
      writer.uint32(58).string(message.dropIndex);
    }
    if (message.addForeignKey !== undefined) {
      ForeignKeyDefinition.encode(message.addForeignKey, writer.uint32(66).fork()).join();
    }
    if (message.dropForeignKey !== undefined) {
      writer.uint32(74).string(message.dropForeignKey);
    }
    if (message.renameTable !== undefined) {
      writer.uint32(82).string(message.renameTable);
    }
    if (message.setComment !== undefined) {
      writer.uint32(90).string(message.setComment);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AlterTableOperation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlterTableOperation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.operation = alterOperationFromJSON(reader.int32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.addColumn = ColumnDefinition.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.dropColumn = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.modifyColumn = ColumnDefinition.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.renameColumn = RenameColumnDetails.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.addIndex = IndexDefinition.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.dropIndex = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.addForeignKey = ForeignKeyDefinition.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.dropForeignKey = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.renameTable = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.setComment = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlterTableOperation {
    return {
      operation: isSet(object.operation)
        ? alterOperationFromJSON(object.operation)
        : AlterOperation.ALTER_OPERATION_UNSPECIFIED,
      addColumn: isSet(object.addColumn) ? ColumnDefinition.fromJSON(object.addColumn) : undefined,
      dropColumn: isSet(object.dropColumn) ? globalThis.String(object.dropColumn) : undefined,
      modifyColumn: isSet(object.modifyColumn) ? ColumnDefinition.fromJSON(object.modifyColumn) : undefined,
      renameColumn: isSet(object.renameColumn) ? RenameColumnDetails.fromJSON(object.renameColumn) : undefined,
      addIndex: isSet(object.addIndex) ? IndexDefinition.fromJSON(object.addIndex) : undefined,
      dropIndex: isSet(object.dropIndex) ? globalThis.String(object.dropIndex) : undefined,
      addForeignKey: isSet(object.addForeignKey) ? ForeignKeyDefinition.fromJSON(object.addForeignKey) : undefined,
      dropForeignKey: isSet(object.dropForeignKey) ? globalThis.String(object.dropForeignKey) : undefined,
      renameTable: isSet(object.renameTable) ? globalThis.String(object.renameTable) : undefined,
      setComment: isSet(object.setComment) ? globalThis.String(object.setComment) : undefined,
    };
  },

  toJSON(message: AlterTableOperation): unknown {
    const obj: any = {};
    if (message.operation !== AlterOperation.ALTER_OPERATION_UNSPECIFIED) {
      obj.operation = alterOperationToJSON(message.operation);
    }
    if (message.addColumn !== undefined) {
      obj.addColumn = ColumnDefinition.toJSON(message.addColumn);
    }
    if (message.dropColumn !== undefined) {
      obj.dropColumn = message.dropColumn;
    }
    if (message.modifyColumn !== undefined) {
      obj.modifyColumn = ColumnDefinition.toJSON(message.modifyColumn);
    }
    if (message.renameColumn !== undefined) {
      obj.renameColumn = RenameColumnDetails.toJSON(message.renameColumn);
    }
    if (message.addIndex !== undefined) {
      obj.addIndex = IndexDefinition.toJSON(message.addIndex);
    }
    if (message.dropIndex !== undefined) {
      obj.dropIndex = message.dropIndex;
    }
    if (message.addForeignKey !== undefined) {
      obj.addForeignKey = ForeignKeyDefinition.toJSON(message.addForeignKey);
    }
    if (message.dropForeignKey !== undefined) {
      obj.dropForeignKey = message.dropForeignKey;
    }
    if (message.renameTable !== undefined) {
      obj.renameTable = message.renameTable;
    }
    if (message.setComment !== undefined) {
      obj.setComment = message.setComment;
    }
    return obj;
  },

  create(base?: DeepPartial<AlterTableOperation>): AlterTableOperation {
    return AlterTableOperation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AlterTableOperation>): AlterTableOperation {
    const message = createBaseAlterTableOperation();
    message.operation = object.operation ?? AlterOperation.ALTER_OPERATION_UNSPECIFIED;
    message.addColumn = (object.addColumn !== undefined && object.addColumn !== null)
      ? ColumnDefinition.fromPartial(object.addColumn)
      : undefined;
    message.dropColumn = object.dropColumn ?? undefined;
    message.modifyColumn = (object.modifyColumn !== undefined && object.modifyColumn !== null)
      ? ColumnDefinition.fromPartial(object.modifyColumn)
      : undefined;
    message.renameColumn = (object.renameColumn !== undefined && object.renameColumn !== null)
      ? RenameColumnDetails.fromPartial(object.renameColumn)
      : undefined;
    message.addIndex = (object.addIndex !== undefined && object.addIndex !== null)
      ? IndexDefinition.fromPartial(object.addIndex)
      : undefined;
    message.dropIndex = object.dropIndex ?? undefined;
    message.addForeignKey = (object.addForeignKey !== undefined && object.addForeignKey !== null)
      ? ForeignKeyDefinition.fromPartial(object.addForeignKey)
      : undefined;
    message.dropForeignKey = object.dropForeignKey ?? undefined;
    message.renameTable = object.renameTable ?? undefined;
    message.setComment = object.setComment ?? undefined;
    return message;
  },
};

function createBaseRenameColumnDetails(): RenameColumnDetails {
  return { oldName: "", newName: "" };
}

export const RenameColumnDetails: MessageFns<RenameColumnDetails> = {
  encode(message: RenameColumnDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.oldName !== "") {
      writer.uint32(10).string(message.oldName);
    }
    if (message.newName !== "") {
      writer.uint32(18).string(message.newName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RenameColumnDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRenameColumnDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.oldName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.newName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RenameColumnDetails {
    return {
      oldName: isSet(object.oldName) ? globalThis.String(object.oldName) : "",
      newName: isSet(object.newName) ? globalThis.String(object.newName) : "",
    };
  },

  toJSON(message: RenameColumnDetails): unknown {
    const obj: any = {};
    if (message.oldName !== "") {
      obj.oldName = message.oldName;
    }
    if (message.newName !== "") {
      obj.newName = message.newName;
    }
    return obj;
  },

  create(base?: DeepPartial<RenameColumnDetails>): RenameColumnDetails {
    return RenameColumnDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RenameColumnDetails>): RenameColumnDetails {
    const message = createBaseRenameColumnDetails();
    message.oldName = object.oldName ?? "";
    message.newName = object.newName ?? "";
    return message;
  },
};

function createBaseAlterTableRequest(): AlterTableRequest {
  return { connectionId: "", schemaName: "", tableName: "", operations: [] };
}

export const AlterTableRequest: MessageFns<AlterTableRequest> = {
  encode(message: AlterTableRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.connectionId !== "") {
      writer.uint32(10).string(message.connectionId);
    }
    if (message.schemaName !== "") {
      writer.uint32(18).string(message.schemaName);
    }
    if (message.tableName !== "") {
      writer.uint32(26).string(message.tableName);
    }
    for (const v of message.operations) {
      AlterTableOperation.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AlterTableRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlterTableRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.connectionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.schemaName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tableName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.operations.push(AlterTableOperation.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlterTableRequest {
    return {
      connectionId: isSet(object.connectionId) ? globalThis.String(object.connectionId) : "",
      schemaName: isSet(object.schemaName) ? globalThis.String(object.schemaName) : "",
      tableName: isSet(object.tableName) ? globalThis.String(object.tableName) : "",
      operations: globalThis.Array.isArray(object?.operations)
        ? object.operations.map((e: any) => AlterTableOperation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AlterTableRequest): unknown {
    const obj: any = {};
    if (message.connectionId !== "") {
      obj.connectionId = message.connectionId;
    }
    if (message.schemaName !== "") {
      obj.schemaName = message.schemaName;
    }
    if (message.tableName !== "") {
      obj.tableName = message.tableName;
    }
    if (message.operations?.length) {
      obj.operations = message.operations.map((e) => AlterTableOperation.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<AlterTableRequest>): AlterTableRequest {
    return AlterTableRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AlterTableRequest>): AlterTableRequest {
    const message = createBaseAlterTableRequest();
    message.connectionId = object.connectionId ?? "";
    message.schemaName = object.schemaName ?? "";
    message.tableName = object.tableName ?? "";
    message.operations = object.operations?.map((e) => AlterTableOperation.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAlterTableResponse(): AlterTableResponse {
  return { success: false, message: "", sqlStatements: [] };
}

export const AlterTableResponse: MessageFns<AlterTableResponse> = {
  encode(message: AlterTableResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    for (const v of message.sqlStatements) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AlterTableResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlterTableResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sqlStatements.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlterTableResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      sqlStatements: globalThis.Array.isArray(object?.sqlStatements)
        ? object.sqlStatements.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: AlterTableResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.sqlStatements?.length) {
      obj.sqlStatements = message.sqlStatements;
    }
    return obj;
  },

  create(base?: DeepPartial<AlterTableResponse>): AlterTableResponse {
    return AlterTableResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AlterTableResponse>): AlterTableResponse {
    const message = createBaseAlterTableResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.sqlStatements = object.sqlStatements?.map((e) => e) || [];
    return message;
  },
};

function createBaseDropTableRequest(): DropTableRequest {
  return { connectionId: "", schemaName: "", tableName: "", ifExists: false, cascade: false };
}

export const DropTableRequest: MessageFns<DropTableRequest> = {
  encode(message: DropTableRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.connectionId !== "") {
      writer.uint32(10).string(message.connectionId);
    }
    if (message.schemaName !== "") {
      writer.uint32(18).string(message.schemaName);
    }
    if (message.tableName !== "") {
      writer.uint32(26).string(message.tableName);
    }
    if (message.ifExists !== false) {
      writer.uint32(32).bool(message.ifExists);
    }
    if (message.cascade !== false) {
      writer.uint32(40).bool(message.cascade);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DropTableRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDropTableRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.connectionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.schemaName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tableName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.ifExists = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.cascade = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DropTableRequest {
    return {
      connectionId: isSet(object.connectionId) ? globalThis.String(object.connectionId) : "",
      schemaName: isSet(object.schemaName) ? globalThis.String(object.schemaName) : "",
      tableName: isSet(object.tableName) ? globalThis.String(object.tableName) : "",
      ifExists: isSet(object.ifExists) ? globalThis.Boolean(object.ifExists) : false,
      cascade: isSet(object.cascade) ? globalThis.Boolean(object.cascade) : false,
    };
  },

  toJSON(message: DropTableRequest): unknown {
    const obj: any = {};
    if (message.connectionId !== "") {
      obj.connectionId = message.connectionId;
    }
    if (message.schemaName !== "") {
      obj.schemaName = message.schemaName;
    }
    if (message.tableName !== "") {
      obj.tableName = message.tableName;
    }
    if (message.ifExists !== false) {
      obj.ifExists = message.ifExists;
    }
    if (message.cascade !== false) {
      obj.cascade = message.cascade;
    }
    return obj;
  },

  create(base?: DeepPartial<DropTableRequest>): DropTableRequest {
    return DropTableRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DropTableRequest>): DropTableRequest {
    const message = createBaseDropTableRequest();
    message.connectionId = object.connectionId ?? "";
    message.schemaName = object.schemaName ?? "";
    message.tableName = object.tableName ?? "";
    message.ifExists = object.ifExists ?? false;
    message.cascade = object.cascade ?? false;
    return message;
  },
};

function createBaseDropTableResponse(): DropTableResponse {
  return { success: false, message: "", sql: "" };
}

export const DropTableResponse: MessageFns<DropTableResponse> = {
  encode(message: DropTableResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.sql !== "") {
      writer.uint32(26).string(message.sql);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DropTableResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDropTableResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sql = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DropTableResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      sql: isSet(object.sql) ? globalThis.String(object.sql) : "",
    };
  },

  toJSON(message: DropTableResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.sql !== "") {
      obj.sql = message.sql;
    }
    return obj;
  },

  create(base?: DeepPartial<DropTableResponse>): DropTableResponse {
    return DropTableResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DropTableResponse>): DropTableResponse {
    const message = createBaseDropTableResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.sql = object.sql ?? "";
    return message;
  },
};

function createBaseGetTableStructureRequest(): GetTableStructureRequest {
  return { connectionId: "", schemaName: "", tableName: "" };
}

export const GetTableStructureRequest: MessageFns<GetTableStructureRequest> = {
  encode(message: GetTableStructureRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.connectionId !== "") {
      writer.uint32(10).string(message.connectionId);
    }
    if (message.schemaName !== "") {
      writer.uint32(18).string(message.schemaName);
    }
    if (message.tableName !== "") {
      writer.uint32(26).string(message.tableName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTableStructureRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTableStructureRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.connectionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.schemaName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tableName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTableStructureRequest {
    return {
      connectionId: isSet(object.connectionId) ? globalThis.String(object.connectionId) : "",
      schemaName: isSet(object.schemaName) ? globalThis.String(object.schemaName) : "",
      tableName: isSet(object.tableName) ? globalThis.String(object.tableName) : "",
    };
  },

  toJSON(message: GetTableStructureRequest): unknown {
    const obj: any = {};
    if (message.connectionId !== "") {
      obj.connectionId = message.connectionId;
    }
    if (message.schemaName !== "") {
      obj.schemaName = message.schemaName;
    }
    if (message.tableName !== "") {
      obj.tableName = message.tableName;
    }
    return obj;
  },

  create(base?: DeepPartial<GetTableStructureRequest>): GetTableStructureRequest {
    return GetTableStructureRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetTableStructureRequest>): GetTableStructureRequest {
    const message = createBaseGetTableStructureRequest();
    message.connectionId = object.connectionId ?? "";
    message.schemaName = object.schemaName ?? "";
    message.tableName = object.tableName ?? "";
    return message;
  },
};

function createBaseGetTableStructureResponse(): GetTableStructureResponse {
  return {
    success: false,
    message: "",
    columns: [],
    indexes: [],
    foreignKeys: [],
    triggers: [],
    comment: "",
    options: {},
  };
}

export const GetTableStructureResponse: MessageFns<GetTableStructureResponse> = {
  encode(message: GetTableStructureResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    for (const v of message.columns) {
      ColumnDefinition.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.indexes) {
      IndexDefinition.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.foreignKeys) {
      ForeignKeyDefinition.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.triggers) {
      writer.uint32(50).string(v!);
    }
    if (message.comment !== "") {
      writer.uint32(58).string(message.comment);
    }
    Object.entries(message.options).forEach(([key, value]) => {
      GetTableStructureResponse_OptionsEntry.encode({ key: key as any, value }, writer.uint32(66).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTableStructureResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTableStructureResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.columns.push(ColumnDefinition.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.indexes.push(IndexDefinition.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.foreignKeys.push(ForeignKeyDefinition.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.triggers.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.comment = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          const entry8 = GetTableStructureResponse_OptionsEntry.decode(reader, reader.uint32());
          if (entry8.value !== undefined) {
            message.options[entry8.key] = entry8.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTableStructureResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      columns: globalThis.Array.isArray(object?.columns)
        ? object.columns.map((e: any) => ColumnDefinition.fromJSON(e))
        : [],
      indexes: globalThis.Array.isArray(object?.indexes)
        ? object.indexes.map((e: any) => IndexDefinition.fromJSON(e))
        : [],
      foreignKeys: globalThis.Array.isArray(object?.foreignKeys)
        ? object.foreignKeys.map((e: any) => ForeignKeyDefinition.fromJSON(e))
        : [],
      triggers: globalThis.Array.isArray(object?.triggers) ? object.triggers.map((e: any) => globalThis.String(e)) : [],
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      options: isObject(object.options)
        ? Object.entries(object.options).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: GetTableStructureResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.columns?.length) {
      obj.columns = message.columns.map((e) => ColumnDefinition.toJSON(e));
    }
    if (message.indexes?.length) {
      obj.indexes = message.indexes.map((e) => IndexDefinition.toJSON(e));
    }
    if (message.foreignKeys?.length) {
      obj.foreignKeys = message.foreignKeys.map((e) => ForeignKeyDefinition.toJSON(e));
    }
    if (message.triggers?.length) {
      obj.triggers = message.triggers;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.options) {
      const entries = Object.entries(message.options);
      if (entries.length > 0) {
        obj.options = {};
        entries.forEach(([k, v]) => {
          obj.options[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<GetTableStructureResponse>): GetTableStructureResponse {
    return GetTableStructureResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetTableStructureResponse>): GetTableStructureResponse {
    const message = createBaseGetTableStructureResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.columns = object.columns?.map((e) => ColumnDefinition.fromPartial(e)) || [];
    message.indexes = object.indexes?.map((e) => IndexDefinition.fromPartial(e)) || [];
    message.foreignKeys = object.foreignKeys?.map((e) => ForeignKeyDefinition.fromPartial(e)) || [];
    message.triggers = object.triggers?.map((e) => e) || [];
    message.comment = object.comment ?? "";
    message.options = Object.entries(object.options ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseGetTableStructureResponse_OptionsEntry(): GetTableStructureResponse_OptionsEntry {
  return { key: "", value: "" };
}

export const GetTableStructureResponse_OptionsEntry: MessageFns<GetTableStructureResponse_OptionsEntry> = {
  encode(message: GetTableStructureResponse_OptionsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTableStructureResponse_OptionsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTableStructureResponse_OptionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTableStructureResponse_OptionsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: GetTableStructureResponse_OptionsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<GetTableStructureResponse_OptionsEntry>): GetTableStructureResponse_OptionsEntry {
    return GetTableStructureResponse_OptionsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetTableStructureResponse_OptionsEntry>): GetTableStructureResponse_OptionsEntry {
    const message = createBaseGetTableStructureResponse_OptionsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseValidationRule(): ValidationRule {
  return { name: "", column: "", ruleType: "", parameters: {}, errorMessage: "" };
}

export const ValidationRule: MessageFns<ValidationRule> = {
  encode(message: ValidationRule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.column !== "") {
      writer.uint32(18).string(message.column);
    }
    if (message.ruleType !== "") {
      writer.uint32(26).string(message.ruleType);
    }
    Object.entries(message.parameters).forEach(([key, value]) => {
      ValidationRule_ParametersEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.errorMessage !== "") {
      writer.uint32(42).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidationRule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidationRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.column = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.ruleType = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = ValidationRule_ParametersEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.parameters[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValidationRule {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      column: isSet(object.column) ? globalThis.String(object.column) : "",
      ruleType: isSet(object.ruleType) ? globalThis.String(object.ruleType) : "",
      parameters: isObject(object.parameters)
        ? Object.entries(object.parameters).reduce<{ [key: string]: Any }>((acc, [key, value]) => {
          acc[key] = Any.fromJSON(value);
          return acc;
        }, {})
        : {},
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
    };
  },

  toJSON(message: ValidationRule): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.column !== "") {
      obj.column = message.column;
    }
    if (message.ruleType !== "") {
      obj.ruleType = message.ruleType;
    }
    if (message.parameters) {
      const entries = Object.entries(message.parameters);
      if (entries.length > 0) {
        obj.parameters = {};
        entries.forEach(([k, v]) => {
          obj.parameters[k] = Any.toJSON(v);
        });
      }
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    return obj;
  },

  create(base?: DeepPartial<ValidationRule>): ValidationRule {
    return ValidationRule.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ValidationRule>): ValidationRule {
    const message = createBaseValidationRule();
    message.name = object.name ?? "";
    message.column = object.column ?? "";
    message.ruleType = object.ruleType ?? "";
    message.parameters = Object.entries(object.parameters ?? {}).reduce<{ [key: string]: Any }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Any.fromPartial(value);
      }
      return acc;
    }, {});
    message.errorMessage = object.errorMessage ?? "";
    return message;
  },
};

function createBaseValidationRule_ParametersEntry(): ValidationRule_ParametersEntry {
  return { key: "", value: undefined };
}

export const ValidationRule_ParametersEntry: MessageFns<ValidationRule_ParametersEntry> = {
  encode(message: ValidationRule_ParametersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Any.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidationRule_ParametersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidationRule_ParametersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Any.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValidationRule_ParametersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Any.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: ValidationRule_ParametersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Any.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<ValidationRule_ParametersEntry>): ValidationRule_ParametersEntry {
    return ValidationRule_ParametersEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ValidationRule_ParametersEntry>): ValidationRule_ParametersEntry {
    const message = createBaseValidationRule_ParametersEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Any.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseValidateTableDataRequest(): ValidateTableDataRequest {
  return { connectionId: "", schemaName: "", tableName: "", rules: [], sampleSize: 0 };
}

export const ValidateTableDataRequest: MessageFns<ValidateTableDataRequest> = {
  encode(message: ValidateTableDataRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.connectionId !== "") {
      writer.uint32(10).string(message.connectionId);
    }
    if (message.schemaName !== "") {
      writer.uint32(18).string(message.schemaName);
    }
    if (message.tableName !== "") {
      writer.uint32(26).string(message.tableName);
    }
    for (const v of message.rules) {
      ValidationRule.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.sampleSize !== 0) {
      writer.uint32(40).int32(message.sampleSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidateTableDataRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidateTableDataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.connectionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.schemaName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tableName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.rules.push(ValidationRule.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.sampleSize = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValidateTableDataRequest {
    return {
      connectionId: isSet(object.connectionId) ? globalThis.String(object.connectionId) : "",
      schemaName: isSet(object.schemaName) ? globalThis.String(object.schemaName) : "",
      tableName: isSet(object.tableName) ? globalThis.String(object.tableName) : "",
      rules: globalThis.Array.isArray(object?.rules) ? object.rules.map((e: any) => ValidationRule.fromJSON(e)) : [],
      sampleSize: isSet(object.sampleSize) ? globalThis.Number(object.sampleSize) : 0,
    };
  },

  toJSON(message: ValidateTableDataRequest): unknown {
    const obj: any = {};
    if (message.connectionId !== "") {
      obj.connectionId = message.connectionId;
    }
    if (message.schemaName !== "") {
      obj.schemaName = message.schemaName;
    }
    if (message.tableName !== "") {
      obj.tableName = message.tableName;
    }
    if (message.rules?.length) {
      obj.rules = message.rules.map((e) => ValidationRule.toJSON(e));
    }
    if (message.sampleSize !== 0) {
      obj.sampleSize = Math.round(message.sampleSize);
    }
    return obj;
  },

  create(base?: DeepPartial<ValidateTableDataRequest>): ValidateTableDataRequest {
    return ValidateTableDataRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ValidateTableDataRequest>): ValidateTableDataRequest {
    const message = createBaseValidateTableDataRequest();
    message.connectionId = object.connectionId ?? "";
    message.schemaName = object.schemaName ?? "";
    message.tableName = object.tableName ?? "";
    message.rules = object.rules?.map((e) => ValidationRule.fromPartial(e)) || [];
    message.sampleSize = object.sampleSize ?? 0;
    return message;
  },
};

function createBaseValidationError(): ValidationError {
  return { ruleName: "", column: "", value: undefined, errorMessage: "", rowNumber: Long.ZERO };
}

export const ValidationError: MessageFns<ValidationError> = {
  encode(message: ValidationError, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ruleName !== "") {
      writer.uint32(10).string(message.ruleName);
    }
    if (message.column !== "") {
      writer.uint32(18).string(message.column);
    }
    if (message.value !== undefined) {
      Any.encode(message.value, writer.uint32(26).fork()).join();
    }
    if (message.errorMessage !== "") {
      writer.uint32(34).string(message.errorMessage);
    }
    if (!message.rowNumber.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.rowNumber.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidationError {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidationError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ruleName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.column = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.value = Any.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.rowNumber = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValidationError {
    return {
      ruleName: isSet(object.ruleName) ? globalThis.String(object.ruleName) : "",
      column: isSet(object.column) ? globalThis.String(object.column) : "",
      value: isSet(object.value) ? Any.fromJSON(object.value) : undefined,
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
      rowNumber: isSet(object.rowNumber) ? Long.fromValue(object.rowNumber) : Long.ZERO,
    };
  },

  toJSON(message: ValidationError): unknown {
    const obj: any = {};
    if (message.ruleName !== "") {
      obj.ruleName = message.ruleName;
    }
    if (message.column !== "") {
      obj.column = message.column;
    }
    if (message.value !== undefined) {
      obj.value = Any.toJSON(message.value);
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    if (!message.rowNumber.equals(Long.ZERO)) {
      obj.rowNumber = (message.rowNumber || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<ValidationError>): ValidationError {
    return ValidationError.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ValidationError>): ValidationError {
    const message = createBaseValidationError();
    message.ruleName = object.ruleName ?? "";
    message.column = object.column ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Any.fromPartial(object.value) : undefined;
    message.errorMessage = object.errorMessage ?? "";
    message.rowNumber = (object.rowNumber !== undefined && object.rowNumber !== null)
      ? Long.fromValue(object.rowNumber)
      : Long.ZERO;
    return message;
  },
};

function createBaseValidateTableDataResponse(): ValidateTableDataResponse {
  return { success: false, message: "", valid: false, errors: [], rowsValidated: Long.ZERO, errorsCount: Long.ZERO };
}

export const ValidateTableDataResponse: MessageFns<ValidateTableDataResponse> = {
  encode(message: ValidateTableDataResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.valid !== false) {
      writer.uint32(24).bool(message.valid);
    }
    for (const v of message.errors) {
      ValidationError.encode(v!, writer.uint32(34).fork()).join();
    }
    if (!message.rowsValidated.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.rowsValidated.toString());
    }
    if (!message.errorsCount.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.errorsCount.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidateTableDataResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidateTableDataResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.valid = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.errors.push(ValidationError.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.rowsValidated = Long.fromString(reader.int64().toString());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.errorsCount = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValidateTableDataResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      valid: isSet(object.valid) ? globalThis.Boolean(object.valid) : false,
      errors: globalThis.Array.isArray(object?.errors)
        ? object.errors.map((e: any) => ValidationError.fromJSON(e))
        : [],
      rowsValidated: isSet(object.rowsValidated) ? Long.fromValue(object.rowsValidated) : Long.ZERO,
      errorsCount: isSet(object.errorsCount) ? Long.fromValue(object.errorsCount) : Long.ZERO,
    };
  },

  toJSON(message: ValidateTableDataResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.valid !== false) {
      obj.valid = message.valid;
    }
    if (message.errors?.length) {
      obj.errors = message.errors.map((e) => ValidationError.toJSON(e));
    }
    if (!message.rowsValidated.equals(Long.ZERO)) {
      obj.rowsValidated = (message.rowsValidated || Long.ZERO).toString();
    }
    if (!message.errorsCount.equals(Long.ZERO)) {
      obj.errorsCount = (message.errorsCount || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<ValidateTableDataResponse>): ValidateTableDataResponse {
    return ValidateTableDataResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ValidateTableDataResponse>): ValidateTableDataResponse {
    const message = createBaseValidateTableDataResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.valid = object.valid ?? false;
    message.errors = object.errors?.map((e) => ValidationError.fromPartial(e)) || [];
    message.rowsValidated = (object.rowsValidated !== undefined && object.rowsValidated !== null)
      ? Long.fromValue(object.rowsValidated)
      : Long.ZERO;
    message.errorsCount = (object.errorsCount !== undefined && object.errorsCount !== null)
      ? Long.fromValue(object.errorsCount)
      : Long.ZERO;
    return message;
  },
};

function createBaseImportOptions(): ImportOptions {
  return {
    format: ImportFormat.IMPORT_FORMAT_UNSPECIFIED,
    delimiter: "",
    quoteChar: "",
    escapeChar: "",
    hasHeader: false,
    encoding: "",
    skipErrors: false,
    batchSize: 0,
    columnMapping: {},
  };
}

export const ImportOptions: MessageFns<ImportOptions> = {
  encode(message: ImportOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.format !== ImportFormat.IMPORT_FORMAT_UNSPECIFIED) {
      writer.uint32(8).int32(importFormatToNumber(message.format));
    }
    if (message.delimiter !== "") {
      writer.uint32(18).string(message.delimiter);
    }
    if (message.quoteChar !== "") {
      writer.uint32(26).string(message.quoteChar);
    }
    if (message.escapeChar !== "") {
      writer.uint32(34).string(message.escapeChar);
    }
    if (message.hasHeader !== false) {
      writer.uint32(40).bool(message.hasHeader);
    }
    if (message.encoding !== "") {
      writer.uint32(50).string(message.encoding);
    }
    if (message.skipErrors !== false) {
      writer.uint32(56).bool(message.skipErrors);
    }
    if (message.batchSize !== 0) {
      writer.uint32(64).int32(message.batchSize);
    }
    Object.entries(message.columnMapping).forEach(([key, value]) => {
      ImportOptions_ColumnMappingEntry.encode({ key: key as any, value }, writer.uint32(74).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImportOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImportOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.format = importFormatFromJSON(reader.int32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.delimiter = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.quoteChar = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.escapeChar = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.hasHeader = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.encoding = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.skipErrors = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.batchSize = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          const entry9 = ImportOptions_ColumnMappingEntry.decode(reader, reader.uint32());
          if (entry9.value !== undefined) {
            message.columnMapping[entry9.key] = entry9.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImportOptions {
    return {
      format: isSet(object.format) ? importFormatFromJSON(object.format) : ImportFormat.IMPORT_FORMAT_UNSPECIFIED,
      delimiter: isSet(object.delimiter) ? globalThis.String(object.delimiter) : "",
      quoteChar: isSet(object.quoteChar) ? globalThis.String(object.quoteChar) : "",
      escapeChar: isSet(object.escapeChar) ? globalThis.String(object.escapeChar) : "",
      hasHeader: isSet(object.hasHeader) ? globalThis.Boolean(object.hasHeader) : false,
      encoding: isSet(object.encoding) ? globalThis.String(object.encoding) : "",
      skipErrors: isSet(object.skipErrors) ? globalThis.Boolean(object.skipErrors) : false,
      batchSize: isSet(object.batchSize) ? globalThis.Number(object.batchSize) : 0,
      columnMapping: isObject(object.columnMapping)
        ? Object.entries(object.columnMapping).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: ImportOptions): unknown {
    const obj: any = {};
    if (message.format !== ImportFormat.IMPORT_FORMAT_UNSPECIFIED) {
      obj.format = importFormatToJSON(message.format);
    }
    if (message.delimiter !== "") {
      obj.delimiter = message.delimiter;
    }
    if (message.quoteChar !== "") {
      obj.quoteChar = message.quoteChar;
    }
    if (message.escapeChar !== "") {
      obj.escapeChar = message.escapeChar;
    }
    if (message.hasHeader !== false) {
      obj.hasHeader = message.hasHeader;
    }
    if (message.encoding !== "") {
      obj.encoding = message.encoding;
    }
    if (message.skipErrors !== false) {
      obj.skipErrors = message.skipErrors;
    }
    if (message.batchSize !== 0) {
      obj.batchSize = Math.round(message.batchSize);
    }
    if (message.columnMapping) {
      const entries = Object.entries(message.columnMapping);
      if (entries.length > 0) {
        obj.columnMapping = {};
        entries.forEach(([k, v]) => {
          obj.columnMapping[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<ImportOptions>): ImportOptions {
    return ImportOptions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ImportOptions>): ImportOptions {
    const message = createBaseImportOptions();
    message.format = object.format ?? ImportFormat.IMPORT_FORMAT_UNSPECIFIED;
    message.delimiter = object.delimiter ?? "";
    message.quoteChar = object.quoteChar ?? "";
    message.escapeChar = object.escapeChar ?? "";
    message.hasHeader = object.hasHeader ?? false;
    message.encoding = object.encoding ?? "";
    message.skipErrors = object.skipErrors ?? false;
    message.batchSize = object.batchSize ?? 0;
    message.columnMapping = Object.entries(object.columnMapping ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseImportOptions_ColumnMappingEntry(): ImportOptions_ColumnMappingEntry {
  return { key: "", value: "" };
}

export const ImportOptions_ColumnMappingEntry: MessageFns<ImportOptions_ColumnMappingEntry> = {
  encode(message: ImportOptions_ColumnMappingEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImportOptions_ColumnMappingEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImportOptions_ColumnMappingEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImportOptions_ColumnMappingEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ImportOptions_ColumnMappingEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<ImportOptions_ColumnMappingEntry>): ImportOptions_ColumnMappingEntry {
    return ImportOptions_ColumnMappingEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ImportOptions_ColumnMappingEntry>): ImportOptions_ColumnMappingEntry {
    const message = createBaseImportOptions_ColumnMappingEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseBulkImportRequest(): BulkImportRequest {
  return {
    connectionId: "",
    schemaName: "",
    tableName: "",
    data: new Uint8Array(0),
    options: undefined,
    createTable: false,
    truncateFirst: false,
  };
}

export const BulkImportRequest: MessageFns<BulkImportRequest> = {
  encode(message: BulkImportRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.connectionId !== "") {
      writer.uint32(10).string(message.connectionId);
    }
    if (message.schemaName !== "") {
      writer.uint32(18).string(message.schemaName);
    }
    if (message.tableName !== "") {
      writer.uint32(26).string(message.tableName);
    }
    if (message.data.length !== 0) {
      writer.uint32(34).bytes(message.data);
    }
    if (message.options !== undefined) {
      ImportOptions.encode(message.options, writer.uint32(42).fork()).join();
    }
    if (message.createTable !== false) {
      writer.uint32(48).bool(message.createTable);
    }
    if (message.truncateFirst !== false) {
      writer.uint32(56).bool(message.truncateFirst);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BulkImportRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBulkImportRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.connectionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.schemaName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tableName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.data = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.options = ImportOptions.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.createTable = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.truncateFirst = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BulkImportRequest {
    return {
      connectionId: isSet(object.connectionId) ? globalThis.String(object.connectionId) : "",
      schemaName: isSet(object.schemaName) ? globalThis.String(object.schemaName) : "",
      tableName: isSet(object.tableName) ? globalThis.String(object.tableName) : "",
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
      options: isSet(object.options) ? ImportOptions.fromJSON(object.options) : undefined,
      createTable: isSet(object.createTable) ? globalThis.Boolean(object.createTable) : false,
      truncateFirst: isSet(object.truncateFirst) ? globalThis.Boolean(object.truncateFirst) : false,
    };
  },

  toJSON(message: BulkImportRequest): unknown {
    const obj: any = {};
    if (message.connectionId !== "") {
      obj.connectionId = message.connectionId;
    }
    if (message.schemaName !== "") {
      obj.schemaName = message.schemaName;
    }
    if (message.tableName !== "") {
      obj.tableName = message.tableName;
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.options !== undefined) {
      obj.options = ImportOptions.toJSON(message.options);
    }
    if (message.createTable !== false) {
      obj.createTable = message.createTable;
    }
    if (message.truncateFirst !== false) {
      obj.truncateFirst = message.truncateFirst;
    }
    return obj;
  },

  create(base?: DeepPartial<BulkImportRequest>): BulkImportRequest {
    return BulkImportRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BulkImportRequest>): BulkImportRequest {
    const message = createBaseBulkImportRequest();
    message.connectionId = object.connectionId ?? "";
    message.schemaName = object.schemaName ?? "";
    message.tableName = object.tableName ?? "";
    message.data = object.data ?? new Uint8Array(0);
    message.options = (object.options !== undefined && object.options !== null)
      ? ImportOptions.fromPartial(object.options)
      : undefined;
    message.createTable = object.createTable ?? false;
    message.truncateFirst = object.truncateFirst ?? false;
    return message;
  },
};

function createBaseImportStats(): ImportStats {
  return {
    rowsProcessed: Long.ZERO,
    rowsImported: Long.ZERO,
    rowsSkipped: Long.ZERO,
    rowsFailed: Long.ZERO,
    startedAt: undefined,
    completedAt: undefined,
    completed: false,
  };
}

export const ImportStats: MessageFns<ImportStats> = {
  encode(message: ImportStats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.rowsProcessed.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.rowsProcessed.toString());
    }
    if (!message.rowsImported.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.rowsImported.toString());
    }
    if (!message.rowsSkipped.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.rowsSkipped.toString());
    }
    if (!message.rowsFailed.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.rowsFailed.toString());
    }
    if (message.startedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.startedAt), writer.uint32(42).fork()).join();
    }
    if (message.completedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.completedAt), writer.uint32(50).fork()).join();
    }
    if (message.completed !== false) {
      writer.uint32(56).bool(message.completed);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImportStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImportStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.rowsProcessed = Long.fromString(reader.int64().toString());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.rowsImported = Long.fromString(reader.int64().toString());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.rowsSkipped = Long.fromString(reader.int64().toString());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.rowsFailed = Long.fromString(reader.int64().toString());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.startedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.completedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.completed = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImportStats {
    return {
      rowsProcessed: isSet(object.rowsProcessed) ? Long.fromValue(object.rowsProcessed) : Long.ZERO,
      rowsImported: isSet(object.rowsImported) ? Long.fromValue(object.rowsImported) : Long.ZERO,
      rowsSkipped: isSet(object.rowsSkipped) ? Long.fromValue(object.rowsSkipped) : Long.ZERO,
      rowsFailed: isSet(object.rowsFailed) ? Long.fromValue(object.rowsFailed) : Long.ZERO,
      startedAt: isSet(object.startedAt) ? fromJsonTimestamp(object.startedAt) : undefined,
      completedAt: isSet(object.completedAt) ? fromJsonTimestamp(object.completedAt) : undefined,
      completed: isSet(object.completed) ? globalThis.Boolean(object.completed) : false,
    };
  },

  toJSON(message: ImportStats): unknown {
    const obj: any = {};
    if (!message.rowsProcessed.equals(Long.ZERO)) {
      obj.rowsProcessed = (message.rowsProcessed || Long.ZERO).toString();
    }
    if (!message.rowsImported.equals(Long.ZERO)) {
      obj.rowsImported = (message.rowsImported || Long.ZERO).toString();
    }
    if (!message.rowsSkipped.equals(Long.ZERO)) {
      obj.rowsSkipped = (message.rowsSkipped || Long.ZERO).toString();
    }
    if (!message.rowsFailed.equals(Long.ZERO)) {
      obj.rowsFailed = (message.rowsFailed || Long.ZERO).toString();
    }
    if (message.startedAt !== undefined) {
      obj.startedAt = message.startedAt.toISOString();
    }
    if (message.completedAt !== undefined) {
      obj.completedAt = message.completedAt.toISOString();
    }
    if (message.completed !== false) {
      obj.completed = message.completed;
    }
    return obj;
  },

  create(base?: DeepPartial<ImportStats>): ImportStats {
    return ImportStats.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ImportStats>): ImportStats {
    const message = createBaseImportStats();
    message.rowsProcessed = (object.rowsProcessed !== undefined && object.rowsProcessed !== null)
      ? Long.fromValue(object.rowsProcessed)
      : Long.ZERO;
    message.rowsImported = (object.rowsImported !== undefined && object.rowsImported !== null)
      ? Long.fromValue(object.rowsImported)
      : Long.ZERO;
    message.rowsSkipped = (object.rowsSkipped !== undefined && object.rowsSkipped !== null)
      ? Long.fromValue(object.rowsSkipped)
      : Long.ZERO;
    message.rowsFailed = (object.rowsFailed !== undefined && object.rowsFailed !== null)
      ? Long.fromValue(object.rowsFailed)
      : Long.ZERO;
    message.startedAt = object.startedAt ?? undefined;
    message.completedAt = object.completedAt ?? undefined;
    message.completed = object.completed ?? false;
    return message;
  },
};

function createBaseBulkImportResponse(): BulkImportResponse {
  return { progress: undefined, error: undefined, completion: undefined };
}

export const BulkImportResponse: MessageFns<BulkImportResponse> = {
  encode(message: BulkImportResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.progress !== undefined) {
      ImportStats.encode(message.progress, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      writer.uint32(18).string(message.error);
    }
    if (message.completion !== undefined) {
      ImportStats.encode(message.completion, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BulkImportResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBulkImportResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.progress = ImportStats.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.completion = ImportStats.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BulkImportResponse {
    return {
      progress: isSet(object.progress) ? ImportStats.fromJSON(object.progress) : undefined,
      error: isSet(object.error) ? globalThis.String(object.error) : undefined,
      completion: isSet(object.completion) ? ImportStats.fromJSON(object.completion) : undefined,
    };
  },

  toJSON(message: BulkImportResponse): unknown {
    const obj: any = {};
    if (message.progress !== undefined) {
      obj.progress = ImportStats.toJSON(message.progress);
    }
    if (message.error !== undefined) {
      obj.error = message.error;
    }
    if (message.completion !== undefined) {
      obj.completion = ImportStats.toJSON(message.completion);
    }
    return obj;
  },

  create(base?: DeepPartial<BulkImportResponse>): BulkImportResponse {
    return BulkImportResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BulkImportResponse>): BulkImportResponse {
    const message = createBaseBulkImportResponse();
    message.progress = (object.progress !== undefined && object.progress !== null)
      ? ImportStats.fromPartial(object.progress)
      : undefined;
    message.error = object.error ?? undefined;
    message.completion = (object.completion !== undefined && object.completion !== null)
      ? ImportStats.fromPartial(object.completion)
      : undefined;
    return message;
  },
};

function createBaseExportOptions(): ExportOptions {
  return {
    format: ExportFormat.EXPORT_FORMAT_UNSPECIFIED,
    delimiter: "",
    quoteChar: "",
    includeHeader: false,
    encoding: "",
    batchSize: 0,
    compress: false,
  };
}

export const ExportOptions: MessageFns<ExportOptions> = {
  encode(message: ExportOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.format !== ExportFormat.EXPORT_FORMAT_UNSPECIFIED) {
      writer.uint32(8).int32(exportFormatToNumber(message.format));
    }
    if (message.delimiter !== "") {
      writer.uint32(18).string(message.delimiter);
    }
    if (message.quoteChar !== "") {
      writer.uint32(26).string(message.quoteChar);
    }
    if (message.includeHeader !== false) {
      writer.uint32(32).bool(message.includeHeader);
    }
    if (message.encoding !== "") {
      writer.uint32(42).string(message.encoding);
    }
    if (message.batchSize !== 0) {
      writer.uint32(48).int32(message.batchSize);
    }
    if (message.compress !== false) {
      writer.uint32(56).bool(message.compress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExportOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.format = exportFormatFromJSON(reader.int32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.delimiter = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.quoteChar = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.includeHeader = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.encoding = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.batchSize = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.compress = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExportOptions {
    return {
      format: isSet(object.format) ? exportFormatFromJSON(object.format) : ExportFormat.EXPORT_FORMAT_UNSPECIFIED,
      delimiter: isSet(object.delimiter) ? globalThis.String(object.delimiter) : "",
      quoteChar: isSet(object.quoteChar) ? globalThis.String(object.quoteChar) : "",
      includeHeader: isSet(object.includeHeader) ? globalThis.Boolean(object.includeHeader) : false,
      encoding: isSet(object.encoding) ? globalThis.String(object.encoding) : "",
      batchSize: isSet(object.batchSize) ? globalThis.Number(object.batchSize) : 0,
      compress: isSet(object.compress) ? globalThis.Boolean(object.compress) : false,
    };
  },

  toJSON(message: ExportOptions): unknown {
    const obj: any = {};
    if (message.format !== ExportFormat.EXPORT_FORMAT_UNSPECIFIED) {
      obj.format = exportFormatToJSON(message.format);
    }
    if (message.delimiter !== "") {
      obj.delimiter = message.delimiter;
    }
    if (message.quoteChar !== "") {
      obj.quoteChar = message.quoteChar;
    }
    if (message.includeHeader !== false) {
      obj.includeHeader = message.includeHeader;
    }
    if (message.encoding !== "") {
      obj.encoding = message.encoding;
    }
    if (message.batchSize !== 0) {
      obj.batchSize = Math.round(message.batchSize);
    }
    if (message.compress !== false) {
      obj.compress = message.compress;
    }
    return obj;
  },

  create(base?: DeepPartial<ExportOptions>): ExportOptions {
    return ExportOptions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExportOptions>): ExportOptions {
    const message = createBaseExportOptions();
    message.format = object.format ?? ExportFormat.EXPORT_FORMAT_UNSPECIFIED;
    message.delimiter = object.delimiter ?? "";
    message.quoteChar = object.quoteChar ?? "";
    message.includeHeader = object.includeHeader ?? false;
    message.encoding = object.encoding ?? "";
    message.batchSize = object.batchSize ?? 0;
    message.compress = object.compress ?? false;
    return message;
  },
};

function createBaseExportTableRequest(): ExportTableRequest {
  return { connectionId: "", schemaName: "", tableName: "", columns: [], filters: [], sorts: [], options: undefined };
}

export const ExportTableRequest: MessageFns<ExportTableRequest> = {
  encode(message: ExportTableRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.connectionId !== "") {
      writer.uint32(10).string(message.connectionId);
    }
    if (message.schemaName !== "") {
      writer.uint32(18).string(message.schemaName);
    }
    if (message.tableName !== "") {
      writer.uint32(26).string(message.tableName);
    }
    for (const v of message.columns) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.filters) {
      FilterSpec.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.sorts) {
      SortSpec.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.options !== undefined) {
      ExportOptions.encode(message.options, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExportTableRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportTableRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.connectionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.schemaName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tableName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.columns.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.filters.push(FilterSpec.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.sorts.push(SortSpec.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.options = ExportOptions.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExportTableRequest {
    return {
      connectionId: isSet(object.connectionId) ? globalThis.String(object.connectionId) : "",
      schemaName: isSet(object.schemaName) ? globalThis.String(object.schemaName) : "",
      tableName: isSet(object.tableName) ? globalThis.String(object.tableName) : "",
      columns: globalThis.Array.isArray(object?.columns) ? object.columns.map((e: any) => globalThis.String(e)) : [],
      filters: globalThis.Array.isArray(object?.filters) ? object.filters.map((e: any) => FilterSpec.fromJSON(e)) : [],
      sorts: globalThis.Array.isArray(object?.sorts) ? object.sorts.map((e: any) => SortSpec.fromJSON(e)) : [],
      options: isSet(object.options) ? ExportOptions.fromJSON(object.options) : undefined,
    };
  },

  toJSON(message: ExportTableRequest): unknown {
    const obj: any = {};
    if (message.connectionId !== "") {
      obj.connectionId = message.connectionId;
    }
    if (message.schemaName !== "") {
      obj.schemaName = message.schemaName;
    }
    if (message.tableName !== "") {
      obj.tableName = message.tableName;
    }
    if (message.columns?.length) {
      obj.columns = message.columns;
    }
    if (message.filters?.length) {
      obj.filters = message.filters.map((e) => FilterSpec.toJSON(e));
    }
    if (message.sorts?.length) {
      obj.sorts = message.sorts.map((e) => SortSpec.toJSON(e));
    }
    if (message.options !== undefined) {
      obj.options = ExportOptions.toJSON(message.options);
    }
    return obj;
  },

  create(base?: DeepPartial<ExportTableRequest>): ExportTableRequest {
    return ExportTableRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExportTableRequest>): ExportTableRequest {
    const message = createBaseExportTableRequest();
    message.connectionId = object.connectionId ?? "";
    message.schemaName = object.schemaName ?? "";
    message.tableName = object.tableName ?? "";
    message.columns = object.columns?.map((e) => e) || [];
    message.filters = object.filters?.map((e) => FilterSpec.fromPartial(e)) || [];
    message.sorts = object.sorts?.map((e) => SortSpec.fromPartial(e)) || [];
    message.options = (object.options !== undefined && object.options !== null)
      ? ExportOptions.fromPartial(object.options)
      : undefined;
    return message;
  },
};

function createBaseExportStats(): ExportStats {
  return {
    rowsProcessed: Long.ZERO,
    bytesWritten: Long.ZERO,
    startedAt: undefined,
    completedAt: undefined,
    completed: false,
  };
}

export const ExportStats: MessageFns<ExportStats> = {
  encode(message: ExportStats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.rowsProcessed.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.rowsProcessed.toString());
    }
    if (!message.bytesWritten.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.bytesWritten.toString());
    }
    if (message.startedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.startedAt), writer.uint32(26).fork()).join();
    }
    if (message.completedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.completedAt), writer.uint32(34).fork()).join();
    }
    if (message.completed !== false) {
      writer.uint32(40).bool(message.completed);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExportStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.rowsProcessed = Long.fromString(reader.int64().toString());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.bytesWritten = Long.fromString(reader.int64().toString());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.startedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.completedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.completed = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExportStats {
    return {
      rowsProcessed: isSet(object.rowsProcessed) ? Long.fromValue(object.rowsProcessed) : Long.ZERO,
      bytesWritten: isSet(object.bytesWritten) ? Long.fromValue(object.bytesWritten) : Long.ZERO,
      startedAt: isSet(object.startedAt) ? fromJsonTimestamp(object.startedAt) : undefined,
      completedAt: isSet(object.completedAt) ? fromJsonTimestamp(object.completedAt) : undefined,
      completed: isSet(object.completed) ? globalThis.Boolean(object.completed) : false,
    };
  },

  toJSON(message: ExportStats): unknown {
    const obj: any = {};
    if (!message.rowsProcessed.equals(Long.ZERO)) {
      obj.rowsProcessed = (message.rowsProcessed || Long.ZERO).toString();
    }
    if (!message.bytesWritten.equals(Long.ZERO)) {
      obj.bytesWritten = (message.bytesWritten || Long.ZERO).toString();
    }
    if (message.startedAt !== undefined) {
      obj.startedAt = message.startedAt.toISOString();
    }
    if (message.completedAt !== undefined) {
      obj.completedAt = message.completedAt.toISOString();
    }
    if (message.completed !== false) {
      obj.completed = message.completed;
    }
    return obj;
  },

  create(base?: DeepPartial<ExportStats>): ExportStats {
    return ExportStats.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExportStats>): ExportStats {
    const message = createBaseExportStats();
    message.rowsProcessed = (object.rowsProcessed !== undefined && object.rowsProcessed !== null)
      ? Long.fromValue(object.rowsProcessed)
      : Long.ZERO;
    message.bytesWritten = (object.bytesWritten !== undefined && object.bytesWritten !== null)
      ? Long.fromValue(object.bytesWritten)
      : Long.ZERO;
    message.startedAt = object.startedAt ?? undefined;
    message.completedAt = object.completedAt ?? undefined;
    message.completed = object.completed ?? false;
    return message;
  },
};

function createBaseExportTableResponse(): ExportTableResponse {
  return { data: undefined, progress: undefined, error: undefined, completion: undefined };
}

export const ExportTableResponse: MessageFns<ExportTableResponse> = {
  encode(message: ExportTableResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.data !== undefined) {
      writer.uint32(10).bytes(message.data);
    }
    if (message.progress !== undefined) {
      ExportStats.encode(message.progress, writer.uint32(18).fork()).join();
    }
    if (message.error !== undefined) {
      writer.uint32(26).string(message.error);
    }
    if (message.completion !== undefined) {
      ExportStats.encode(message.completion, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExportTableResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportTableResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.data = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.progress = ExportStats.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.completion = ExportStats.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExportTableResponse {
    return {
      data: isSet(object.data) ? bytesFromBase64(object.data) : undefined,
      progress: isSet(object.progress) ? ExportStats.fromJSON(object.progress) : undefined,
      error: isSet(object.error) ? globalThis.String(object.error) : undefined,
      completion: isSet(object.completion) ? ExportStats.fromJSON(object.completion) : undefined,
    };
  },

  toJSON(message: ExportTableResponse): unknown {
    const obj: any = {};
    if (message.data !== undefined) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.progress !== undefined) {
      obj.progress = ExportStats.toJSON(message.progress);
    }
    if (message.error !== undefined) {
      obj.error = message.error;
    }
    if (message.completion !== undefined) {
      obj.completion = ExportStats.toJSON(message.completion);
    }
    return obj;
  },

  create(base?: DeepPartial<ExportTableResponse>): ExportTableResponse {
    return ExportTableResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExportTableResponse>): ExportTableResponse {
    const message = createBaseExportTableResponse();
    message.data = object.data ?? undefined;
    message.progress = (object.progress !== undefined && object.progress !== null)
      ? ExportStats.fromPartial(object.progress)
      : undefined;
    message.error = object.error ?? undefined;
    message.completion = (object.completion !== undefined && object.completion !== null)
      ? ExportStats.fromPartial(object.completion)
      : undefined;
    return message;
  },
};

/** Table service definition */
export type TableServiceDefinition = typeof TableServiceDefinition;
export const TableServiceDefinition = {
  name: "TableService",
  fullName: "sqlstudio.table.TableService",
  methods: {
    getTableData: {
      name: "GetTableData",
      requestType: GetTableDataRequest,
      requestStream: false,
      responseType: GetTableDataResponse,
      responseStream: false,
      options: {},
    },
    getTableDataStream: {
      name: "GetTableDataStream",
      requestType: GetTableDataStreamRequest,
      requestStream: false,
      responseType: TableDataStreamResponse,
      responseStream: true,
      options: {},
    },
    updateTableRow: {
      name: "UpdateTableRow",
      requestType: UpdateTableRowRequest,
      requestStream: false,
      responseType: UpdateTableRowResponse,
      responseStream: false,
      options: {},
    },
    insertTableRow: {
      name: "InsertTableRow",
      requestType: InsertTableRowRequest,
      requestStream: false,
      responseType: InsertTableRowResponse,
      responseStream: false,
      options: {},
    },
    deleteTableRow: {
      name: "DeleteTableRow",
      requestType: DeleteTableRowRequest,
      requestStream: false,
      responseType: DeleteTableRowResponse,
      responseStream: false,
      options: {},
    },
    createTable: {
      name: "CreateTable",
      requestType: CreateTableRequest,
      requestStream: false,
      responseType: CreateTableResponse,
      responseStream: false,
      options: {},
    },
    alterTable: {
      name: "AlterTable",
      requestType: AlterTableRequest,
      requestStream: false,
      responseType: AlterTableResponse,
      responseStream: false,
      options: {},
    },
    dropTable: {
      name: "DropTable",
      requestType: DropTableRequest,
      requestStream: false,
      responseType: DropTableResponse,
      responseStream: false,
      options: {},
    },
    getTableStructure: {
      name: "GetTableStructure",
      requestType: GetTableStructureRequest,
      requestStream: false,
      responseType: GetTableStructureResponse,
      responseStream: false,
      options: {},
    },
    validateTableData: {
      name: "ValidateTableData",
      requestType: ValidateTableDataRequest,
      requestStream: false,
      responseType: ValidateTableDataResponse,
      responseStream: false,
      options: {},
    },
    bulkImport: {
      name: "BulkImport",
      requestType: BulkImportRequest,
      requestStream: false,
      responseType: BulkImportResponse,
      responseStream: true,
      options: {},
    },
    exportTable: {
      name: "ExportTable",
      requestType: ExportTableRequest,
      requestStream: false,
      responseType: ExportTableResponse,
      responseStream: true,
      options: {},
    },
  },
} as const;

function bytesFromBase64(b64: string): Uint8Array {
  const bin = globalThis.atob(b64);
  const arr = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; ++i) {
    arr[i] = bin.charCodeAt(i);
  }
  return arr;
}

function base64FromBytes(arr: Uint8Array): string {
  const bin: string[] = [];
  arr.forEach((byte) => {
    bin.push(globalThis.String.fromCharCode(byte));
  });
  return globalThis.btoa(bin.join(""));
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
