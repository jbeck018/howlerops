// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v5.29.3
// source: database.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "./google/protobuf/timestamp";

export const protobufPackage = "sqlstudio.database";

/** Database connection types */
export enum DatabaseType {
  DATABASE_TYPE_UNSPECIFIED = "DATABASE_TYPE_UNSPECIFIED",
  DATABASE_TYPE_POSTGRESQL = "DATABASE_TYPE_POSTGRESQL",
  DATABASE_TYPE_MYSQL = "DATABASE_TYPE_MYSQL",
  DATABASE_TYPE_SQLITE = "DATABASE_TYPE_SQLITE",
  DATABASE_TYPE_MARIADB = "DATABASE_TYPE_MARIADB",
  DATABASE_TYPE_ELASTICSEARCH = "DATABASE_TYPE_ELASTICSEARCH",
  DATABASE_TYPE_OPENSEARCH = "DATABASE_TYPE_OPENSEARCH",
  DATABASE_TYPE_CLICKHOUSE = "DATABASE_TYPE_CLICKHOUSE",
  DATABASE_TYPE_MONGODB = "DATABASE_TYPE_MONGODB",
  DATABASE_TYPE_TIDB = "DATABASE_TYPE_TIDB",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function databaseTypeFromJSON(object: any): DatabaseType {
  switch (object) {
    case 0:
    case "DATABASE_TYPE_UNSPECIFIED":
      return DatabaseType.DATABASE_TYPE_UNSPECIFIED;
    case 1:
    case "DATABASE_TYPE_POSTGRESQL":
      return DatabaseType.DATABASE_TYPE_POSTGRESQL;
    case 2:
    case "DATABASE_TYPE_MYSQL":
      return DatabaseType.DATABASE_TYPE_MYSQL;
    case 3:
    case "DATABASE_TYPE_SQLITE":
      return DatabaseType.DATABASE_TYPE_SQLITE;
    case 4:
    case "DATABASE_TYPE_MARIADB":
      return DatabaseType.DATABASE_TYPE_MARIADB;
    case 5:
    case "DATABASE_TYPE_ELASTICSEARCH":
      return DatabaseType.DATABASE_TYPE_ELASTICSEARCH;
    case 6:
    case "DATABASE_TYPE_OPENSEARCH":
      return DatabaseType.DATABASE_TYPE_OPENSEARCH;
    case 7:
    case "DATABASE_TYPE_CLICKHOUSE":
      return DatabaseType.DATABASE_TYPE_CLICKHOUSE;
    case 8:
    case "DATABASE_TYPE_MONGODB":
      return DatabaseType.DATABASE_TYPE_MONGODB;
    case 9:
    case "DATABASE_TYPE_TIDB":
      return DatabaseType.DATABASE_TYPE_TIDB;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DatabaseType.UNRECOGNIZED;
  }
}

export function databaseTypeToJSON(object: DatabaseType): string {
  switch (object) {
    case DatabaseType.DATABASE_TYPE_UNSPECIFIED:
      return "DATABASE_TYPE_UNSPECIFIED";
    case DatabaseType.DATABASE_TYPE_POSTGRESQL:
      return "DATABASE_TYPE_POSTGRESQL";
    case DatabaseType.DATABASE_TYPE_MYSQL:
      return "DATABASE_TYPE_MYSQL";
    case DatabaseType.DATABASE_TYPE_SQLITE:
      return "DATABASE_TYPE_SQLITE";
    case DatabaseType.DATABASE_TYPE_MARIADB:
      return "DATABASE_TYPE_MARIADB";
    case DatabaseType.DATABASE_TYPE_ELASTICSEARCH:
      return "DATABASE_TYPE_ELASTICSEARCH";
    case DatabaseType.DATABASE_TYPE_OPENSEARCH:
      return "DATABASE_TYPE_OPENSEARCH";
    case DatabaseType.DATABASE_TYPE_CLICKHOUSE:
      return "DATABASE_TYPE_CLICKHOUSE";
    case DatabaseType.DATABASE_TYPE_MONGODB:
      return "DATABASE_TYPE_MONGODB";
    case DatabaseType.DATABASE_TYPE_TIDB:
      return "DATABASE_TYPE_TIDB";
    case DatabaseType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function databaseTypeToNumber(object: DatabaseType): number {
  switch (object) {
    case DatabaseType.DATABASE_TYPE_UNSPECIFIED:
      return 0;
    case DatabaseType.DATABASE_TYPE_POSTGRESQL:
      return 1;
    case DatabaseType.DATABASE_TYPE_MYSQL:
      return 2;
    case DatabaseType.DATABASE_TYPE_SQLITE:
      return 3;
    case DatabaseType.DATABASE_TYPE_MARIADB:
      return 4;
    case DatabaseType.DATABASE_TYPE_ELASTICSEARCH:
      return 5;
    case DatabaseType.DATABASE_TYPE_OPENSEARCH:
      return 6;
    case DatabaseType.DATABASE_TYPE_CLICKHOUSE:
      return 7;
    case DatabaseType.DATABASE_TYPE_MONGODB:
      return 8;
    case DatabaseType.DATABASE_TYPE_TIDB:
      return 9;
    case DatabaseType.UNRECOGNIZED:
    default:
      return -1;
  }
}

/** SSH authentication methods */
export enum SSHAuthMethod {
  SSH_AUTH_METHOD_UNSPECIFIED = "SSH_AUTH_METHOD_UNSPECIFIED",
  SSH_AUTH_METHOD_PASSWORD = "SSH_AUTH_METHOD_PASSWORD",
  SSH_AUTH_METHOD_PRIVATE_KEY = "SSH_AUTH_METHOD_PRIVATE_KEY",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function sSHAuthMethodFromJSON(object: any): SSHAuthMethod {
  switch (object) {
    case 0:
    case "SSH_AUTH_METHOD_UNSPECIFIED":
      return SSHAuthMethod.SSH_AUTH_METHOD_UNSPECIFIED;
    case 1:
    case "SSH_AUTH_METHOD_PASSWORD":
      return SSHAuthMethod.SSH_AUTH_METHOD_PASSWORD;
    case 2:
    case "SSH_AUTH_METHOD_PRIVATE_KEY":
      return SSHAuthMethod.SSH_AUTH_METHOD_PRIVATE_KEY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SSHAuthMethod.UNRECOGNIZED;
  }
}

export function sSHAuthMethodToJSON(object: SSHAuthMethod): string {
  switch (object) {
    case SSHAuthMethod.SSH_AUTH_METHOD_UNSPECIFIED:
      return "SSH_AUTH_METHOD_UNSPECIFIED";
    case SSHAuthMethod.SSH_AUTH_METHOD_PASSWORD:
      return "SSH_AUTH_METHOD_PASSWORD";
    case SSHAuthMethod.SSH_AUTH_METHOD_PRIVATE_KEY:
      return "SSH_AUTH_METHOD_PRIVATE_KEY";
    case SSHAuthMethod.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function sSHAuthMethodToNumber(object: SSHAuthMethod): number {
  switch (object) {
    case SSHAuthMethod.SSH_AUTH_METHOD_UNSPECIFIED:
      return 0;
    case SSHAuthMethod.SSH_AUTH_METHOD_PASSWORD:
      return 1;
    case SSHAuthMethod.SSH_AUTH_METHOD_PRIVATE_KEY:
      return 2;
    case SSHAuthMethod.UNRECOGNIZED:
    default:
      return -1;
  }
}

/** Connection health status */
export enum HealthStatus {
  HEALTH_STATUS_UNSPECIFIED = "HEALTH_STATUS_UNSPECIFIED",
  HEALTH_STATUS_HEALTHY = "HEALTH_STATUS_HEALTHY",
  HEALTH_STATUS_DEGRADED = "HEALTH_STATUS_DEGRADED",
  HEALTH_STATUS_UNHEALTHY = "HEALTH_STATUS_UNHEALTHY",
  HEALTH_STATUS_UNKNOWN = "HEALTH_STATUS_UNKNOWN",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function healthStatusFromJSON(object: any): HealthStatus {
  switch (object) {
    case 0:
    case "HEALTH_STATUS_UNSPECIFIED":
      return HealthStatus.HEALTH_STATUS_UNSPECIFIED;
    case 1:
    case "HEALTH_STATUS_HEALTHY":
      return HealthStatus.HEALTH_STATUS_HEALTHY;
    case 2:
    case "HEALTH_STATUS_DEGRADED":
      return HealthStatus.HEALTH_STATUS_DEGRADED;
    case 3:
    case "HEALTH_STATUS_UNHEALTHY":
      return HealthStatus.HEALTH_STATUS_UNHEALTHY;
    case 4:
    case "HEALTH_STATUS_UNKNOWN":
      return HealthStatus.HEALTH_STATUS_UNKNOWN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return HealthStatus.UNRECOGNIZED;
  }
}

export function healthStatusToJSON(object: HealthStatus): string {
  switch (object) {
    case HealthStatus.HEALTH_STATUS_UNSPECIFIED:
      return "HEALTH_STATUS_UNSPECIFIED";
    case HealthStatus.HEALTH_STATUS_HEALTHY:
      return "HEALTH_STATUS_HEALTHY";
    case HealthStatus.HEALTH_STATUS_DEGRADED:
      return "HEALTH_STATUS_DEGRADED";
    case HealthStatus.HEALTH_STATUS_UNHEALTHY:
      return "HEALTH_STATUS_UNHEALTHY";
    case HealthStatus.HEALTH_STATUS_UNKNOWN:
      return "HEALTH_STATUS_UNKNOWN";
    case HealthStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function healthStatusToNumber(object: HealthStatus): number {
  switch (object) {
    case HealthStatus.HEALTH_STATUS_UNSPECIFIED:
      return 0;
    case HealthStatus.HEALTH_STATUS_HEALTHY:
      return 1;
    case HealthStatus.HEALTH_STATUS_DEGRADED:
      return 2;
    case HealthStatus.HEALTH_STATUS_UNHEALTHY:
      return 3;
    case HealthStatus.HEALTH_STATUS_UNKNOWN:
      return 4;
    case HealthStatus.UNRECOGNIZED:
    default:
      return -1;
  }
}

/** SSH tunnel configuration for bastion host connections */
export interface SSHTunnelConfig {
  host: string;
  port: number;
  user: string;
  authMethod: SSHAuthMethod;
  password: string;
  privateKey: string;
  privateKeyPath: string;
  knownHostsPath: string;
  strictHostKeyChecking: boolean;
  timeoutSeconds: number;
  keepAliveIntervalSeconds: number;
}

/** VPC configuration for private connections */
export interface VPCConfig {
  vpcId: string;
  subnetId: string;
  securityGroupIds: string[];
  privateLinkService: string;
  endpointServiceName: string;
  customConfig: { [key: string]: string };
}

export interface VPCConfig_CustomConfigEntry {
  key: string;
  value: string;
}

/** Connection configuration */
export interface ConnectionConfig {
  type: DatabaseType;
  host: string;
  port: number;
  database: string;
  username: string;
  password: string;
  sslMode: string;
  connectionTimeout: number;
  idleTimeout: number;
  maxConnections: number;
  maxIdleConnections: number;
  parameters: { [key: string]: string };
  useTunnel: boolean;
  sshTunnel: SSHTunnelConfig | undefined;
  useVpc: boolean;
  vpcConfig: VPCConfig | undefined;
}

export interface ConnectionConfig_ParametersEntry {
  key: string;
  value: string;
}

/** Database connection */
export interface DatabaseConnection {
  id: string;
  name: string;
  description: string;
  config: ConnectionConfig | undefined;
  createdAt: Date | undefined;
  updatedAt: Date | undefined;
  active: boolean;
  createdBy: string;
  tags: { [key: string]: string };
}

export interface DatabaseConnection_TagsEntry {
  key: string;
  value: string;
}

/** Create connection request */
export interface CreateConnectionRequest {
  name: string;
  description: string;
  config: ConnectionConfig | undefined;
  tags: { [key: string]: string };
}

export interface CreateConnectionRequest_TagsEntry {
  key: string;
  value: string;
}

/** Create connection response */
export interface CreateConnectionResponse {
  success: boolean;
  message: string;
  connection: DatabaseConnection | undefined;
}

/** Get connection request */
export interface GetConnectionRequest {
  id: string;
}

/** Get connection response */
export interface GetConnectionResponse {
  success: boolean;
  message: string;
  connection: DatabaseConnection | undefined;
}

/** List connections request */
export interface ListConnectionsRequest {
  page: number;
  pageSize: number;
  filter: string;
  sort: string;
  includeInactive: boolean;
}

/** List connections response */
export interface ListConnectionsResponse {
  success: boolean;
  message: string;
  connections: DatabaseConnection[];
  total: number;
  page: number;
  pageSize: number;
}

/** Update connection request */
export interface UpdateConnectionRequest {
  id: string;
  name: string;
  description: string;
  config: ConnectionConfig | undefined;
  tags: { [key: string]: string };
}

export interface UpdateConnectionRequest_TagsEntry {
  key: string;
  value: string;
}

/** Update connection response */
export interface UpdateConnectionResponse {
  success: boolean;
  message: string;
  connection: DatabaseConnection | undefined;
}

/** Delete connection request */
export interface DeleteConnectionRequest {
  id: string;
}

/** Delete connection response */
export interface DeleteConnectionResponse {
  success: boolean;
  message: string;
}

/** Test connection request */
export interface TestConnectionRequest {
  connectionId: string;
  /** For testing new configs */
  config: ConnectionConfig | undefined;
}

/** Test connection response */
export interface TestConnectionResponse {
  success: boolean;
  message: string;
  responseTimeMs: Long;
  version: string;
  serverInfo: { [key: string]: string };
}

export interface TestConnectionResponse_ServerInfoEntry {
  key: string;
  value: string;
}

/** Get schemas request */
export interface GetSchemasRequest {
  connectionId: string;
}

/** Schema information */
export interface Schema {
  name: string;
  owner: string;
  createdAt: Date | undefined;
  tableCount: Long;
  sizeBytes: Long;
  metadata: { [key: string]: string };
}

export interface Schema_MetadataEntry {
  key: string;
  value: string;
}

/** Get schemas response */
export interface GetSchemasResponse {
  success: boolean;
  message: string;
  schemas: Schema[];
}

/** Get tables request */
export interface GetTablesRequest {
  connectionId: string;
  schemaName: string;
  /** TABLE, VIEW, MATERIALIZED_VIEW */
  tableType: string;
}

/** Table information */
export interface Table {
  name: string;
  schema: string;
  /** TABLE, VIEW, MATERIALIZED_VIEW */
  type: string;
  comment: string;
  createdAt: Date | undefined;
  updatedAt: Date | undefined;
  rowCount: Long;
  sizeBytes: Long;
  owner: string;
  metadata: { [key: string]: string };
}

export interface Table_MetadataEntry {
  key: string;
  value: string;
}

/** Get tables response */
export interface GetTablesResponse {
  success: boolean;
  message: string;
  tables: Table[];
}

/** Get table metadata request */
export interface GetTableMetadataRequest {
  connectionId: string;
  schemaName: string;
  tableName: string;
}

/** Column information */
export interface Column {
  name: string;
  dataType: string;
  nullable: boolean;
  defaultValue: string;
  primaryKey: boolean;
  unique: boolean;
  indexed: boolean;
  comment: string;
  ordinalPosition: number;
  characterMaximumLength: Long;
  numericPrecision: number;
  numericScale: number;
  metadata: { [key: string]: string };
}

export interface Column_MetadataEntry {
  key: string;
  value: string;
}

/** Index information */
export interface Index {
  name: string;
  columns: string[];
  unique: boolean;
  primary: boolean;
  type: string;
  method: string;
  metadata: { [key: string]: string };
}

export interface Index_MetadataEntry {
  key: string;
  value: string;
}

/** Foreign key information */
export interface ForeignKey {
  name: string;
  columns: string[];
  referencedTable: string;
  referencedSchema: string;
  referencedColumns: string[];
  onDelete: string;
  onUpdate: string;
}

/** Table metadata */
export interface TableMetadata {
  table: Table | undefined;
  columns: Column[];
  indexes: Index[];
  foreignKeys: ForeignKey[];
  triggers: string[];
  statistics: { [key: string]: string };
}

export interface TableMetadata_StatisticsEntry {
  key: string;
  value: string;
}

/** Get table metadata response */
export interface GetTableMetadataResponse {
  success: boolean;
  message: string;
  metadata: TableMetadata | undefined;
}

/** Get connection health request */
export interface GetConnectionHealthRequest {
  connectionId: string;
  /** How often to check */
  intervalSeconds: number;
}

/** Connection health response (streaming) */
export interface ConnectionHealthResponse {
  connectionId: string;
  status: HealthStatus;
  message: string;
  timestamp: Date | undefined;
  responseTimeMs: Long;
  activeConnections: number;
  idleConnections: number;
  metrics: { [key: string]: string };
}

export interface ConnectionHealthResponse_MetricsEntry {
  key: string;
  value: string;
}

function createBaseSSHTunnelConfig(): SSHTunnelConfig {
  return {
    host: "",
    port: 0,
    user: "",
    authMethod: SSHAuthMethod.SSH_AUTH_METHOD_UNSPECIFIED,
    password: "",
    privateKey: "",
    privateKeyPath: "",
    knownHostsPath: "",
    strictHostKeyChecking: false,
    timeoutSeconds: 0,
    keepAliveIntervalSeconds: 0,
  };
}

export const SSHTunnelConfig: MessageFns<SSHTunnelConfig> = {
  encode(message: SSHTunnelConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.host !== "") {
      writer.uint32(10).string(message.host);
    }
    if (message.port !== 0) {
      writer.uint32(16).int32(message.port);
    }
    if (message.user !== "") {
      writer.uint32(26).string(message.user);
    }
    if (message.authMethod !== SSHAuthMethod.SSH_AUTH_METHOD_UNSPECIFIED) {
      writer.uint32(32).int32(sSHAuthMethodToNumber(message.authMethod));
    }
    if (message.password !== "") {
      writer.uint32(42).string(message.password);
    }
    if (message.privateKey !== "") {
      writer.uint32(50).string(message.privateKey);
    }
    if (message.privateKeyPath !== "") {
      writer.uint32(58).string(message.privateKeyPath);
    }
    if (message.knownHostsPath !== "") {
      writer.uint32(66).string(message.knownHostsPath);
    }
    if (message.strictHostKeyChecking !== false) {
      writer.uint32(72).bool(message.strictHostKeyChecking);
    }
    if (message.timeoutSeconds !== 0) {
      writer.uint32(80).int32(message.timeoutSeconds);
    }
    if (message.keepAliveIntervalSeconds !== 0) {
      writer.uint32(88).int32(message.keepAliveIntervalSeconds);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SSHTunnelConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSSHTunnelConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.host = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.port = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.user = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.authMethod = sSHAuthMethodFromJSON(reader.int32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.password = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.privateKey = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.privateKeyPath = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.knownHostsPath = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.strictHostKeyChecking = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.timeoutSeconds = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.keepAliveIntervalSeconds = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SSHTunnelConfig {
    return {
      host: isSet(object.host) ? globalThis.String(object.host) : "",
      port: isSet(object.port) ? globalThis.Number(object.port) : 0,
      user: isSet(object.user) ? globalThis.String(object.user) : "",
      authMethod: isSet(object.authMethod)
        ? sSHAuthMethodFromJSON(object.authMethod)
        : SSHAuthMethod.SSH_AUTH_METHOD_UNSPECIFIED,
      password: isSet(object.password) ? globalThis.String(object.password) : "",
      privateKey: isSet(object.privateKey) ? globalThis.String(object.privateKey) : "",
      privateKeyPath: isSet(object.privateKeyPath) ? globalThis.String(object.privateKeyPath) : "",
      knownHostsPath: isSet(object.knownHostsPath) ? globalThis.String(object.knownHostsPath) : "",
      strictHostKeyChecking: isSet(object.strictHostKeyChecking)
        ? globalThis.Boolean(object.strictHostKeyChecking)
        : false,
      timeoutSeconds: isSet(object.timeoutSeconds) ? globalThis.Number(object.timeoutSeconds) : 0,
      keepAliveIntervalSeconds: isSet(object.keepAliveIntervalSeconds)
        ? globalThis.Number(object.keepAliveIntervalSeconds)
        : 0,
    };
  },

  toJSON(message: SSHTunnelConfig): unknown {
    const obj: any = {};
    if (message.host !== "") {
      obj.host = message.host;
    }
    if (message.port !== 0) {
      obj.port = Math.round(message.port);
    }
    if (message.user !== "") {
      obj.user = message.user;
    }
    if (message.authMethod !== SSHAuthMethod.SSH_AUTH_METHOD_UNSPECIFIED) {
      obj.authMethod = sSHAuthMethodToJSON(message.authMethod);
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    if (message.privateKey !== "") {
      obj.privateKey = message.privateKey;
    }
    if (message.privateKeyPath !== "") {
      obj.privateKeyPath = message.privateKeyPath;
    }
    if (message.knownHostsPath !== "") {
      obj.knownHostsPath = message.knownHostsPath;
    }
    if (message.strictHostKeyChecking !== false) {
      obj.strictHostKeyChecking = message.strictHostKeyChecking;
    }
    if (message.timeoutSeconds !== 0) {
      obj.timeoutSeconds = Math.round(message.timeoutSeconds);
    }
    if (message.keepAliveIntervalSeconds !== 0) {
      obj.keepAliveIntervalSeconds = Math.round(message.keepAliveIntervalSeconds);
    }
    return obj;
  },

  create(base?: DeepPartial<SSHTunnelConfig>): SSHTunnelConfig {
    return SSHTunnelConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SSHTunnelConfig>): SSHTunnelConfig {
    const message = createBaseSSHTunnelConfig();
    message.host = object.host ?? "";
    message.port = object.port ?? 0;
    message.user = object.user ?? "";
    message.authMethod = object.authMethod ?? SSHAuthMethod.SSH_AUTH_METHOD_UNSPECIFIED;
    message.password = object.password ?? "";
    message.privateKey = object.privateKey ?? "";
    message.privateKeyPath = object.privateKeyPath ?? "";
    message.knownHostsPath = object.knownHostsPath ?? "";
    message.strictHostKeyChecking = object.strictHostKeyChecking ?? false;
    message.timeoutSeconds = object.timeoutSeconds ?? 0;
    message.keepAliveIntervalSeconds = object.keepAliveIntervalSeconds ?? 0;
    return message;
  },
};

function createBaseVPCConfig(): VPCConfig {
  return {
    vpcId: "",
    subnetId: "",
    securityGroupIds: [],
    privateLinkService: "",
    endpointServiceName: "",
    customConfig: {},
  };
}

export const VPCConfig: MessageFns<VPCConfig> = {
  encode(message: VPCConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.vpcId !== "") {
      writer.uint32(10).string(message.vpcId);
    }
    if (message.subnetId !== "") {
      writer.uint32(18).string(message.subnetId);
    }
    for (const v of message.securityGroupIds) {
      writer.uint32(26).string(v!);
    }
    if (message.privateLinkService !== "") {
      writer.uint32(34).string(message.privateLinkService);
    }
    if (message.endpointServiceName !== "") {
      writer.uint32(42).string(message.endpointServiceName);
    }
    Object.entries(message.customConfig).forEach(([key, value]) => {
      VPCConfig_CustomConfigEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VPCConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVPCConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.vpcId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.subnetId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.securityGroupIds.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.privateLinkService = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.endpointServiceName = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          const entry6 = VPCConfig_CustomConfigEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.customConfig[entry6.key] = entry6.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VPCConfig {
    return {
      vpcId: isSet(object.vpcId) ? globalThis.String(object.vpcId) : "",
      subnetId: isSet(object.subnetId) ? globalThis.String(object.subnetId) : "",
      securityGroupIds: globalThis.Array.isArray(object?.securityGroupIds)
        ? object.securityGroupIds.map((e: any) => globalThis.String(e))
        : [],
      privateLinkService: isSet(object.privateLinkService) ? globalThis.String(object.privateLinkService) : "",
      endpointServiceName: isSet(object.endpointServiceName) ? globalThis.String(object.endpointServiceName) : "",
      customConfig: isObject(object.customConfig)
        ? Object.entries(object.customConfig).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: VPCConfig): unknown {
    const obj: any = {};
    if (message.vpcId !== "") {
      obj.vpcId = message.vpcId;
    }
    if (message.subnetId !== "") {
      obj.subnetId = message.subnetId;
    }
    if (message.securityGroupIds?.length) {
      obj.securityGroupIds = message.securityGroupIds;
    }
    if (message.privateLinkService !== "") {
      obj.privateLinkService = message.privateLinkService;
    }
    if (message.endpointServiceName !== "") {
      obj.endpointServiceName = message.endpointServiceName;
    }
    if (message.customConfig) {
      const entries = Object.entries(message.customConfig);
      if (entries.length > 0) {
        obj.customConfig = {};
        entries.forEach(([k, v]) => {
          obj.customConfig[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<VPCConfig>): VPCConfig {
    return VPCConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VPCConfig>): VPCConfig {
    const message = createBaseVPCConfig();
    message.vpcId = object.vpcId ?? "";
    message.subnetId = object.subnetId ?? "";
    message.securityGroupIds = object.securityGroupIds?.map((e) => e) || [];
    message.privateLinkService = object.privateLinkService ?? "";
    message.endpointServiceName = object.endpointServiceName ?? "";
    message.customConfig = Object.entries(object.customConfig ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseVPCConfig_CustomConfigEntry(): VPCConfig_CustomConfigEntry {
  return { key: "", value: "" };
}

export const VPCConfig_CustomConfigEntry: MessageFns<VPCConfig_CustomConfigEntry> = {
  encode(message: VPCConfig_CustomConfigEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VPCConfig_CustomConfigEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVPCConfig_CustomConfigEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VPCConfig_CustomConfigEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: VPCConfig_CustomConfigEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<VPCConfig_CustomConfigEntry>): VPCConfig_CustomConfigEntry {
    return VPCConfig_CustomConfigEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VPCConfig_CustomConfigEntry>): VPCConfig_CustomConfigEntry {
    const message = createBaseVPCConfig_CustomConfigEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseConnectionConfig(): ConnectionConfig {
  return {
    type: DatabaseType.DATABASE_TYPE_UNSPECIFIED,
    host: "",
    port: 0,
    database: "",
    username: "",
    password: "",
    sslMode: "",
    connectionTimeout: 0,
    idleTimeout: 0,
    maxConnections: 0,
    maxIdleConnections: 0,
    parameters: {},
    useTunnel: false,
    sshTunnel: undefined,
    useVpc: false,
    vpcConfig: undefined,
  };
}

export const ConnectionConfig: MessageFns<ConnectionConfig> = {
  encode(message: ConnectionConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== DatabaseType.DATABASE_TYPE_UNSPECIFIED) {
      writer.uint32(8).int32(databaseTypeToNumber(message.type));
    }
    if (message.host !== "") {
      writer.uint32(18).string(message.host);
    }
    if (message.port !== 0) {
      writer.uint32(24).int32(message.port);
    }
    if (message.database !== "") {
      writer.uint32(34).string(message.database);
    }
    if (message.username !== "") {
      writer.uint32(42).string(message.username);
    }
    if (message.password !== "") {
      writer.uint32(50).string(message.password);
    }
    if (message.sslMode !== "") {
      writer.uint32(58).string(message.sslMode);
    }
    if (message.connectionTimeout !== 0) {
      writer.uint32(64).int32(message.connectionTimeout);
    }
    if (message.idleTimeout !== 0) {
      writer.uint32(72).int32(message.idleTimeout);
    }
    if (message.maxConnections !== 0) {
      writer.uint32(80).int32(message.maxConnections);
    }
    if (message.maxIdleConnections !== 0) {
      writer.uint32(88).int32(message.maxIdleConnections);
    }
    Object.entries(message.parameters).forEach(([key, value]) => {
      ConnectionConfig_ParametersEntry.encode({ key: key as any, value }, writer.uint32(98).fork()).join();
    });
    if (message.useTunnel !== false) {
      writer.uint32(104).bool(message.useTunnel);
    }
    if (message.sshTunnel !== undefined) {
      SSHTunnelConfig.encode(message.sshTunnel, writer.uint32(114).fork()).join();
    }
    if (message.useVpc !== false) {
      writer.uint32(120).bool(message.useVpc);
    }
    if (message.vpcConfig !== undefined) {
      VPCConfig.encode(message.vpcConfig, writer.uint32(130).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConnectionConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnectionConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = databaseTypeFromJSON(reader.int32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.host = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.port = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.database = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.password = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.sslMode = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.connectionTimeout = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.idleTimeout = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.maxConnections = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.maxIdleConnections = reader.int32();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          const entry12 = ConnectionConfig_ParametersEntry.decode(reader, reader.uint32());
          if (entry12.value !== undefined) {
            message.parameters[entry12.key] = entry12.value;
          }
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.useTunnel = reader.bool();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.sshTunnel = SSHTunnelConfig.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.useVpc = reader.bool();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.vpcConfig = VPCConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConnectionConfig {
    return {
      type: isSet(object.type) ? databaseTypeFromJSON(object.type) : DatabaseType.DATABASE_TYPE_UNSPECIFIED,
      host: isSet(object.host) ? globalThis.String(object.host) : "",
      port: isSet(object.port) ? globalThis.Number(object.port) : 0,
      database: isSet(object.database) ? globalThis.String(object.database) : "",
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
      sslMode: isSet(object.sslMode) ? globalThis.String(object.sslMode) : "",
      connectionTimeout: isSet(object.connectionTimeout) ? globalThis.Number(object.connectionTimeout) : 0,
      idleTimeout: isSet(object.idleTimeout) ? globalThis.Number(object.idleTimeout) : 0,
      maxConnections: isSet(object.maxConnections) ? globalThis.Number(object.maxConnections) : 0,
      maxIdleConnections: isSet(object.maxIdleConnections) ? globalThis.Number(object.maxIdleConnections) : 0,
      parameters: isObject(object.parameters)
        ? Object.entries(object.parameters).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      useTunnel: isSet(object.useTunnel) ? globalThis.Boolean(object.useTunnel) : false,
      sshTunnel: isSet(object.sshTunnel) ? SSHTunnelConfig.fromJSON(object.sshTunnel) : undefined,
      useVpc: isSet(object.useVpc) ? globalThis.Boolean(object.useVpc) : false,
      vpcConfig: isSet(object.vpcConfig) ? VPCConfig.fromJSON(object.vpcConfig) : undefined,
    };
  },

  toJSON(message: ConnectionConfig): unknown {
    const obj: any = {};
    if (message.type !== DatabaseType.DATABASE_TYPE_UNSPECIFIED) {
      obj.type = databaseTypeToJSON(message.type);
    }
    if (message.host !== "") {
      obj.host = message.host;
    }
    if (message.port !== 0) {
      obj.port = Math.round(message.port);
    }
    if (message.database !== "") {
      obj.database = message.database;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    if (message.sslMode !== "") {
      obj.sslMode = message.sslMode;
    }
    if (message.connectionTimeout !== 0) {
      obj.connectionTimeout = Math.round(message.connectionTimeout);
    }
    if (message.idleTimeout !== 0) {
      obj.idleTimeout = Math.round(message.idleTimeout);
    }
    if (message.maxConnections !== 0) {
      obj.maxConnections = Math.round(message.maxConnections);
    }
    if (message.maxIdleConnections !== 0) {
      obj.maxIdleConnections = Math.round(message.maxIdleConnections);
    }
    if (message.parameters) {
      const entries = Object.entries(message.parameters);
      if (entries.length > 0) {
        obj.parameters = {};
        entries.forEach(([k, v]) => {
          obj.parameters[k] = v;
        });
      }
    }
    if (message.useTunnel !== false) {
      obj.useTunnel = message.useTunnel;
    }
    if (message.sshTunnel !== undefined) {
      obj.sshTunnel = SSHTunnelConfig.toJSON(message.sshTunnel);
    }
    if (message.useVpc !== false) {
      obj.useVpc = message.useVpc;
    }
    if (message.vpcConfig !== undefined) {
      obj.vpcConfig = VPCConfig.toJSON(message.vpcConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<ConnectionConfig>): ConnectionConfig {
    return ConnectionConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConnectionConfig>): ConnectionConfig {
    const message = createBaseConnectionConfig();
    message.type = object.type ?? DatabaseType.DATABASE_TYPE_UNSPECIFIED;
    message.host = object.host ?? "";
    message.port = object.port ?? 0;
    message.database = object.database ?? "";
    message.username = object.username ?? "";
    message.password = object.password ?? "";
    message.sslMode = object.sslMode ?? "";
    message.connectionTimeout = object.connectionTimeout ?? 0;
    message.idleTimeout = object.idleTimeout ?? 0;
    message.maxConnections = object.maxConnections ?? 0;
    message.maxIdleConnections = object.maxIdleConnections ?? 0;
    message.parameters = Object.entries(object.parameters ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.useTunnel = object.useTunnel ?? false;
    message.sshTunnel = (object.sshTunnel !== undefined && object.sshTunnel !== null)
      ? SSHTunnelConfig.fromPartial(object.sshTunnel)
      : undefined;
    message.useVpc = object.useVpc ?? false;
    message.vpcConfig = (object.vpcConfig !== undefined && object.vpcConfig !== null)
      ? VPCConfig.fromPartial(object.vpcConfig)
      : undefined;
    return message;
  },
};

function createBaseConnectionConfig_ParametersEntry(): ConnectionConfig_ParametersEntry {
  return { key: "", value: "" };
}

export const ConnectionConfig_ParametersEntry: MessageFns<ConnectionConfig_ParametersEntry> = {
  encode(message: ConnectionConfig_ParametersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConnectionConfig_ParametersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnectionConfig_ParametersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConnectionConfig_ParametersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ConnectionConfig_ParametersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<ConnectionConfig_ParametersEntry>): ConnectionConfig_ParametersEntry {
    return ConnectionConfig_ParametersEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConnectionConfig_ParametersEntry>): ConnectionConfig_ParametersEntry {
    const message = createBaseConnectionConfig_ParametersEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseDatabaseConnection(): DatabaseConnection {
  return {
    id: "",
    name: "",
    description: "",
    config: undefined,
    createdAt: undefined,
    updatedAt: undefined,
    active: false,
    createdBy: "",
    tags: {},
  };
}

export const DatabaseConnection: MessageFns<DatabaseConnection> = {
  encode(message: DatabaseConnection, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.config !== undefined) {
      ConnectionConfig.encode(message.config, writer.uint32(34).fork()).join();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(42).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(50).fork()).join();
    }
    if (message.active !== false) {
      writer.uint32(56).bool(message.active);
    }
    if (message.createdBy !== "") {
      writer.uint32(66).string(message.createdBy);
    }
    Object.entries(message.tags).forEach(([key, value]) => {
      DatabaseConnection_TagsEntry.encode({ key: key as any, value }, writer.uint32(74).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DatabaseConnection {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDatabaseConnection();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.config = ConnectionConfig.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.active = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.createdBy = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          const entry9 = DatabaseConnection_TagsEntry.decode(reader, reader.uint32());
          if (entry9.value !== undefined) {
            message.tags[entry9.key] = entry9.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DatabaseConnection {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      config: isSet(object.config) ? ConnectionConfig.fromJSON(object.config) : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      active: isSet(object.active) ? globalThis.Boolean(object.active) : false,
      createdBy: isSet(object.createdBy) ? globalThis.String(object.createdBy) : "",
      tags: isObject(object.tags)
        ? Object.entries(object.tags).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: DatabaseConnection): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.config !== undefined) {
      obj.config = ConnectionConfig.toJSON(message.config);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    if (message.active !== false) {
      obj.active = message.active;
    }
    if (message.createdBy !== "") {
      obj.createdBy = message.createdBy;
    }
    if (message.tags) {
      const entries = Object.entries(message.tags);
      if (entries.length > 0) {
        obj.tags = {};
        entries.forEach(([k, v]) => {
          obj.tags[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<DatabaseConnection>): DatabaseConnection {
    return DatabaseConnection.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DatabaseConnection>): DatabaseConnection {
    const message = createBaseDatabaseConnection();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.config = (object.config !== undefined && object.config !== null)
      ? ConnectionConfig.fromPartial(object.config)
      : undefined;
    message.createdAt = object.createdAt ?? undefined;
    message.updatedAt = object.updatedAt ?? undefined;
    message.active = object.active ?? false;
    message.createdBy = object.createdBy ?? "";
    message.tags = Object.entries(object.tags ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseDatabaseConnection_TagsEntry(): DatabaseConnection_TagsEntry {
  return { key: "", value: "" };
}

export const DatabaseConnection_TagsEntry: MessageFns<DatabaseConnection_TagsEntry> = {
  encode(message: DatabaseConnection_TagsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DatabaseConnection_TagsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDatabaseConnection_TagsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DatabaseConnection_TagsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: DatabaseConnection_TagsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<DatabaseConnection_TagsEntry>): DatabaseConnection_TagsEntry {
    return DatabaseConnection_TagsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DatabaseConnection_TagsEntry>): DatabaseConnection_TagsEntry {
    const message = createBaseDatabaseConnection_TagsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCreateConnectionRequest(): CreateConnectionRequest {
  return { name: "", description: "", config: undefined, tags: {} };
}

export const CreateConnectionRequest: MessageFns<CreateConnectionRequest> = {
  encode(message: CreateConnectionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.config !== undefined) {
      ConnectionConfig.encode(message.config, writer.uint32(26).fork()).join();
    }
    Object.entries(message.tags).forEach(([key, value]) => {
      CreateConnectionRequest_TagsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateConnectionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateConnectionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.config = ConnectionConfig.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = CreateConnectionRequest_TagsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.tags[entry4.key] = entry4.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateConnectionRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      config: isSet(object.config) ? ConnectionConfig.fromJSON(object.config) : undefined,
      tags: isObject(object.tags)
        ? Object.entries(object.tags).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: CreateConnectionRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.config !== undefined) {
      obj.config = ConnectionConfig.toJSON(message.config);
    }
    if (message.tags) {
      const entries = Object.entries(message.tags);
      if (entries.length > 0) {
        obj.tags = {};
        entries.forEach(([k, v]) => {
          obj.tags[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<CreateConnectionRequest>): CreateConnectionRequest {
    return CreateConnectionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateConnectionRequest>): CreateConnectionRequest {
    const message = createBaseCreateConnectionRequest();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.config = (object.config !== undefined && object.config !== null)
      ? ConnectionConfig.fromPartial(object.config)
      : undefined;
    message.tags = Object.entries(object.tags ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseCreateConnectionRequest_TagsEntry(): CreateConnectionRequest_TagsEntry {
  return { key: "", value: "" };
}

export const CreateConnectionRequest_TagsEntry: MessageFns<CreateConnectionRequest_TagsEntry> = {
  encode(message: CreateConnectionRequest_TagsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateConnectionRequest_TagsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateConnectionRequest_TagsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateConnectionRequest_TagsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CreateConnectionRequest_TagsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateConnectionRequest_TagsEntry>): CreateConnectionRequest_TagsEntry {
    return CreateConnectionRequest_TagsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateConnectionRequest_TagsEntry>): CreateConnectionRequest_TagsEntry {
    const message = createBaseCreateConnectionRequest_TagsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCreateConnectionResponse(): CreateConnectionResponse {
  return { success: false, message: "", connection: undefined };
}

export const CreateConnectionResponse: MessageFns<CreateConnectionResponse> = {
  encode(message: CreateConnectionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.connection !== undefined) {
      DatabaseConnection.encode(message.connection, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateConnectionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateConnectionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.connection = DatabaseConnection.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateConnectionResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      connection: isSet(object.connection) ? DatabaseConnection.fromJSON(object.connection) : undefined,
    };
  },

  toJSON(message: CreateConnectionResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.connection !== undefined) {
      obj.connection = DatabaseConnection.toJSON(message.connection);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateConnectionResponse>): CreateConnectionResponse {
    return CreateConnectionResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateConnectionResponse>): CreateConnectionResponse {
    const message = createBaseCreateConnectionResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.connection = (object.connection !== undefined && object.connection !== null)
      ? DatabaseConnection.fromPartial(object.connection)
      : undefined;
    return message;
  },
};

function createBaseGetConnectionRequest(): GetConnectionRequest {
  return { id: "" };
}

export const GetConnectionRequest: MessageFns<GetConnectionRequest> = {
  encode(message: GetConnectionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetConnectionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetConnectionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetConnectionRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: GetConnectionRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create(base?: DeepPartial<GetConnectionRequest>): GetConnectionRequest {
    return GetConnectionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetConnectionRequest>): GetConnectionRequest {
    const message = createBaseGetConnectionRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseGetConnectionResponse(): GetConnectionResponse {
  return { success: false, message: "", connection: undefined };
}

export const GetConnectionResponse: MessageFns<GetConnectionResponse> = {
  encode(message: GetConnectionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.connection !== undefined) {
      DatabaseConnection.encode(message.connection, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetConnectionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetConnectionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.connection = DatabaseConnection.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetConnectionResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      connection: isSet(object.connection) ? DatabaseConnection.fromJSON(object.connection) : undefined,
    };
  },

  toJSON(message: GetConnectionResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.connection !== undefined) {
      obj.connection = DatabaseConnection.toJSON(message.connection);
    }
    return obj;
  },

  create(base?: DeepPartial<GetConnectionResponse>): GetConnectionResponse {
    return GetConnectionResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetConnectionResponse>): GetConnectionResponse {
    const message = createBaseGetConnectionResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.connection = (object.connection !== undefined && object.connection !== null)
      ? DatabaseConnection.fromPartial(object.connection)
      : undefined;
    return message;
  },
};

function createBaseListConnectionsRequest(): ListConnectionsRequest {
  return { page: 0, pageSize: 0, filter: "", sort: "", includeInactive: false };
}

export const ListConnectionsRequest: MessageFns<ListConnectionsRequest> = {
  encode(message: ListConnectionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.page !== 0) {
      writer.uint32(8).int32(message.page);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.filter !== "") {
      writer.uint32(26).string(message.filter);
    }
    if (message.sort !== "") {
      writer.uint32(34).string(message.sort);
    }
    if (message.includeInactive !== false) {
      writer.uint32(40).bool(message.includeInactive);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListConnectionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListConnectionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.filter = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sort = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.includeInactive = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListConnectionsRequest {
    return {
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      sort: isSet(object.sort) ? globalThis.String(object.sort) : "",
      includeInactive: isSet(object.includeInactive) ? globalThis.Boolean(object.includeInactive) : false,
    };
  },

  toJSON(message: ListConnectionsRequest): unknown {
    const obj: any = {};
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.sort !== "") {
      obj.sort = message.sort;
    }
    if (message.includeInactive !== false) {
      obj.includeInactive = message.includeInactive;
    }
    return obj;
  },

  create(base?: DeepPartial<ListConnectionsRequest>): ListConnectionsRequest {
    return ListConnectionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListConnectionsRequest>): ListConnectionsRequest {
    const message = createBaseListConnectionsRequest();
    message.page = object.page ?? 0;
    message.pageSize = object.pageSize ?? 0;
    message.filter = object.filter ?? "";
    message.sort = object.sort ?? "";
    message.includeInactive = object.includeInactive ?? false;
    return message;
  },
};

function createBaseListConnectionsResponse(): ListConnectionsResponse {
  return { success: false, message: "", connections: [], total: 0, page: 0, pageSize: 0 };
}

export const ListConnectionsResponse: MessageFns<ListConnectionsResponse> = {
  encode(message: ListConnectionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    for (const v of message.connections) {
      DatabaseConnection.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.total !== 0) {
      writer.uint32(32).int32(message.total);
    }
    if (message.page !== 0) {
      writer.uint32(40).int32(message.page);
    }
    if (message.pageSize !== 0) {
      writer.uint32(48).int32(message.pageSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListConnectionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListConnectionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.connections.push(DatabaseConnection.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListConnectionsResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      connections: globalThis.Array.isArray(object?.connections)
        ? object.connections.map((e: any) => DatabaseConnection.fromJSON(e))
        : [],
      total: isSet(object.total) ? globalThis.Number(object.total) : 0,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
    };
  },

  toJSON(message: ListConnectionsResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.connections?.length) {
      obj.connections = message.connections.map((e) => DatabaseConnection.toJSON(e));
    }
    if (message.total !== 0) {
      obj.total = Math.round(message.total);
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    return obj;
  },

  create(base?: DeepPartial<ListConnectionsResponse>): ListConnectionsResponse {
    return ListConnectionsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListConnectionsResponse>): ListConnectionsResponse {
    const message = createBaseListConnectionsResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.connections = object.connections?.map((e) => DatabaseConnection.fromPartial(e)) || [];
    message.total = object.total ?? 0;
    message.page = object.page ?? 0;
    message.pageSize = object.pageSize ?? 0;
    return message;
  },
};

function createBaseUpdateConnectionRequest(): UpdateConnectionRequest {
  return { id: "", name: "", description: "", config: undefined, tags: {} };
}

export const UpdateConnectionRequest: MessageFns<UpdateConnectionRequest> = {
  encode(message: UpdateConnectionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.config !== undefined) {
      ConnectionConfig.encode(message.config, writer.uint32(34).fork()).join();
    }
    Object.entries(message.tags).forEach(([key, value]) => {
      UpdateConnectionRequest_TagsEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateConnectionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateConnectionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.config = ConnectionConfig.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          const entry5 = UpdateConnectionRequest_TagsEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.tags[entry5.key] = entry5.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateConnectionRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      config: isSet(object.config) ? ConnectionConfig.fromJSON(object.config) : undefined,
      tags: isObject(object.tags)
        ? Object.entries(object.tags).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: UpdateConnectionRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.config !== undefined) {
      obj.config = ConnectionConfig.toJSON(message.config);
    }
    if (message.tags) {
      const entries = Object.entries(message.tags);
      if (entries.length > 0) {
        obj.tags = {};
        entries.forEach(([k, v]) => {
          obj.tags[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateConnectionRequest>): UpdateConnectionRequest {
    return UpdateConnectionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateConnectionRequest>): UpdateConnectionRequest {
    const message = createBaseUpdateConnectionRequest();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.config = (object.config !== undefined && object.config !== null)
      ? ConnectionConfig.fromPartial(object.config)
      : undefined;
    message.tags = Object.entries(object.tags ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseUpdateConnectionRequest_TagsEntry(): UpdateConnectionRequest_TagsEntry {
  return { key: "", value: "" };
}

export const UpdateConnectionRequest_TagsEntry: MessageFns<UpdateConnectionRequest_TagsEntry> = {
  encode(message: UpdateConnectionRequest_TagsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateConnectionRequest_TagsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateConnectionRequest_TagsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateConnectionRequest_TagsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: UpdateConnectionRequest_TagsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateConnectionRequest_TagsEntry>): UpdateConnectionRequest_TagsEntry {
    return UpdateConnectionRequest_TagsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateConnectionRequest_TagsEntry>): UpdateConnectionRequest_TagsEntry {
    const message = createBaseUpdateConnectionRequest_TagsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseUpdateConnectionResponse(): UpdateConnectionResponse {
  return { success: false, message: "", connection: undefined };
}

export const UpdateConnectionResponse: MessageFns<UpdateConnectionResponse> = {
  encode(message: UpdateConnectionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.connection !== undefined) {
      DatabaseConnection.encode(message.connection, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateConnectionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateConnectionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.connection = DatabaseConnection.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateConnectionResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      connection: isSet(object.connection) ? DatabaseConnection.fromJSON(object.connection) : undefined,
    };
  },

  toJSON(message: UpdateConnectionResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.connection !== undefined) {
      obj.connection = DatabaseConnection.toJSON(message.connection);
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateConnectionResponse>): UpdateConnectionResponse {
    return UpdateConnectionResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateConnectionResponse>): UpdateConnectionResponse {
    const message = createBaseUpdateConnectionResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.connection = (object.connection !== undefined && object.connection !== null)
      ? DatabaseConnection.fromPartial(object.connection)
      : undefined;
    return message;
  },
};

function createBaseDeleteConnectionRequest(): DeleteConnectionRequest {
  return { id: "" };
}

export const DeleteConnectionRequest: MessageFns<DeleteConnectionRequest> = {
  encode(message: DeleteConnectionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteConnectionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteConnectionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteConnectionRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: DeleteConnectionRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteConnectionRequest>): DeleteConnectionRequest {
    return DeleteConnectionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteConnectionRequest>): DeleteConnectionRequest {
    const message = createBaseDeleteConnectionRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseDeleteConnectionResponse(): DeleteConnectionResponse {
  return { success: false, message: "" };
}

export const DeleteConnectionResponse: MessageFns<DeleteConnectionResponse> = {
  encode(message: DeleteConnectionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteConnectionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteConnectionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteConnectionResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: DeleteConnectionResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteConnectionResponse>): DeleteConnectionResponse {
    return DeleteConnectionResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteConnectionResponse>): DeleteConnectionResponse {
    const message = createBaseDeleteConnectionResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseTestConnectionRequest(): TestConnectionRequest {
  return { connectionId: "", config: undefined };
}

export const TestConnectionRequest: MessageFns<TestConnectionRequest> = {
  encode(message: TestConnectionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.connectionId !== "") {
      writer.uint32(10).string(message.connectionId);
    }
    if (message.config !== undefined) {
      ConnectionConfig.encode(message.config, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TestConnectionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestConnectionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.connectionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.config = ConnectionConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TestConnectionRequest {
    return {
      connectionId: isSet(object.connectionId) ? globalThis.String(object.connectionId) : "",
      config: isSet(object.config) ? ConnectionConfig.fromJSON(object.config) : undefined,
    };
  },

  toJSON(message: TestConnectionRequest): unknown {
    const obj: any = {};
    if (message.connectionId !== "") {
      obj.connectionId = message.connectionId;
    }
    if (message.config !== undefined) {
      obj.config = ConnectionConfig.toJSON(message.config);
    }
    return obj;
  },

  create(base?: DeepPartial<TestConnectionRequest>): TestConnectionRequest {
    return TestConnectionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TestConnectionRequest>): TestConnectionRequest {
    const message = createBaseTestConnectionRequest();
    message.connectionId = object.connectionId ?? "";
    message.config = (object.config !== undefined && object.config !== null)
      ? ConnectionConfig.fromPartial(object.config)
      : undefined;
    return message;
  },
};

function createBaseTestConnectionResponse(): TestConnectionResponse {
  return { success: false, message: "", responseTimeMs: Long.ZERO, version: "", serverInfo: {} };
}

export const TestConnectionResponse: MessageFns<TestConnectionResponse> = {
  encode(message: TestConnectionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (!message.responseTimeMs.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.responseTimeMs.toString());
    }
    if (message.version !== "") {
      writer.uint32(34).string(message.version);
    }
    Object.entries(message.serverInfo).forEach(([key, value]) => {
      TestConnectionResponse_ServerInfoEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TestConnectionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestConnectionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.responseTimeMs = Long.fromString(reader.int64().toString());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          const entry5 = TestConnectionResponse_ServerInfoEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.serverInfo[entry5.key] = entry5.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TestConnectionResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      responseTimeMs: isSet(object.responseTimeMs) ? Long.fromValue(object.responseTimeMs) : Long.ZERO,
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      serverInfo: isObject(object.serverInfo)
        ? Object.entries(object.serverInfo).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: TestConnectionResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (!message.responseTimeMs.equals(Long.ZERO)) {
      obj.responseTimeMs = (message.responseTimeMs || Long.ZERO).toString();
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.serverInfo) {
      const entries = Object.entries(message.serverInfo);
      if (entries.length > 0) {
        obj.serverInfo = {};
        entries.forEach(([k, v]) => {
          obj.serverInfo[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<TestConnectionResponse>): TestConnectionResponse {
    return TestConnectionResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TestConnectionResponse>): TestConnectionResponse {
    const message = createBaseTestConnectionResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.responseTimeMs = (object.responseTimeMs !== undefined && object.responseTimeMs !== null)
      ? Long.fromValue(object.responseTimeMs)
      : Long.ZERO;
    message.version = object.version ?? "";
    message.serverInfo = Object.entries(object.serverInfo ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseTestConnectionResponse_ServerInfoEntry(): TestConnectionResponse_ServerInfoEntry {
  return { key: "", value: "" };
}

export const TestConnectionResponse_ServerInfoEntry: MessageFns<TestConnectionResponse_ServerInfoEntry> = {
  encode(message: TestConnectionResponse_ServerInfoEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TestConnectionResponse_ServerInfoEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestConnectionResponse_ServerInfoEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TestConnectionResponse_ServerInfoEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: TestConnectionResponse_ServerInfoEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<TestConnectionResponse_ServerInfoEntry>): TestConnectionResponse_ServerInfoEntry {
    return TestConnectionResponse_ServerInfoEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TestConnectionResponse_ServerInfoEntry>): TestConnectionResponse_ServerInfoEntry {
    const message = createBaseTestConnectionResponse_ServerInfoEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseGetSchemasRequest(): GetSchemasRequest {
  return { connectionId: "" };
}

export const GetSchemasRequest: MessageFns<GetSchemasRequest> = {
  encode(message: GetSchemasRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.connectionId !== "") {
      writer.uint32(10).string(message.connectionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSchemasRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSchemasRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.connectionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSchemasRequest {
    return { connectionId: isSet(object.connectionId) ? globalThis.String(object.connectionId) : "" };
  },

  toJSON(message: GetSchemasRequest): unknown {
    const obj: any = {};
    if (message.connectionId !== "") {
      obj.connectionId = message.connectionId;
    }
    return obj;
  },

  create(base?: DeepPartial<GetSchemasRequest>): GetSchemasRequest {
    return GetSchemasRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetSchemasRequest>): GetSchemasRequest {
    const message = createBaseGetSchemasRequest();
    message.connectionId = object.connectionId ?? "";
    return message;
  },
};

function createBaseSchema(): Schema {
  return { name: "", owner: "", createdAt: undefined, tableCount: Long.ZERO, sizeBytes: Long.ZERO, metadata: {} };
}

export const Schema: MessageFns<Schema> = {
  encode(message: Schema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.owner !== "") {
      writer.uint32(18).string(message.owner);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(26).fork()).join();
    }
    if (!message.tableCount.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.tableCount.toString());
    }
    if (!message.sizeBytes.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.sizeBytes.toString());
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      Schema_MetadataEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Schema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.tableCount = Long.fromString(reader.int64().toString());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.sizeBytes = Long.fromString(reader.int64().toString());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          const entry6 = Schema_MetadataEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.metadata[entry6.key] = entry6.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Schema {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      tableCount: isSet(object.tableCount) ? Long.fromValue(object.tableCount) : Long.ZERO,
      sizeBytes: isSet(object.sizeBytes) ? Long.fromValue(object.sizeBytes) : Long.ZERO,
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Schema): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (!message.tableCount.equals(Long.ZERO)) {
      obj.tableCount = (message.tableCount || Long.ZERO).toString();
    }
    if (!message.sizeBytes.equals(Long.ZERO)) {
      obj.sizeBytes = (message.sizeBytes || Long.ZERO).toString();
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<Schema>): Schema {
    return Schema.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Schema>): Schema {
    const message = createBaseSchema();
    message.name = object.name ?? "";
    message.owner = object.owner ?? "";
    message.createdAt = object.createdAt ?? undefined;
    message.tableCount = (object.tableCount !== undefined && object.tableCount !== null)
      ? Long.fromValue(object.tableCount)
      : Long.ZERO;
    message.sizeBytes = (object.sizeBytes !== undefined && object.sizeBytes !== null)
      ? Long.fromValue(object.sizeBytes)
      : Long.ZERO;
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseSchema_MetadataEntry(): Schema_MetadataEntry {
  return { key: "", value: "" };
}

export const Schema_MetadataEntry: MessageFns<Schema_MetadataEntry> = {
  encode(message: Schema_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Schema_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSchema_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Schema_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Schema_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Schema_MetadataEntry>): Schema_MetadataEntry {
    return Schema_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Schema_MetadataEntry>): Schema_MetadataEntry {
    const message = createBaseSchema_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseGetSchemasResponse(): GetSchemasResponse {
  return { success: false, message: "", schemas: [] };
}

export const GetSchemasResponse: MessageFns<GetSchemasResponse> = {
  encode(message: GetSchemasResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    for (const v of message.schemas) {
      Schema.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSchemasResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSchemasResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.schemas.push(Schema.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSchemasResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      schemas: globalThis.Array.isArray(object?.schemas) ? object.schemas.map((e: any) => Schema.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetSchemasResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.schemas?.length) {
      obj.schemas = message.schemas.map((e) => Schema.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GetSchemasResponse>): GetSchemasResponse {
    return GetSchemasResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetSchemasResponse>): GetSchemasResponse {
    const message = createBaseGetSchemasResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.schemas = object.schemas?.map((e) => Schema.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetTablesRequest(): GetTablesRequest {
  return { connectionId: "", schemaName: "", tableType: "" };
}

export const GetTablesRequest: MessageFns<GetTablesRequest> = {
  encode(message: GetTablesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.connectionId !== "") {
      writer.uint32(10).string(message.connectionId);
    }
    if (message.schemaName !== "") {
      writer.uint32(18).string(message.schemaName);
    }
    if (message.tableType !== "") {
      writer.uint32(26).string(message.tableType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTablesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTablesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.connectionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.schemaName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tableType = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTablesRequest {
    return {
      connectionId: isSet(object.connectionId) ? globalThis.String(object.connectionId) : "",
      schemaName: isSet(object.schemaName) ? globalThis.String(object.schemaName) : "",
      tableType: isSet(object.tableType) ? globalThis.String(object.tableType) : "",
    };
  },

  toJSON(message: GetTablesRequest): unknown {
    const obj: any = {};
    if (message.connectionId !== "") {
      obj.connectionId = message.connectionId;
    }
    if (message.schemaName !== "") {
      obj.schemaName = message.schemaName;
    }
    if (message.tableType !== "") {
      obj.tableType = message.tableType;
    }
    return obj;
  },

  create(base?: DeepPartial<GetTablesRequest>): GetTablesRequest {
    return GetTablesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetTablesRequest>): GetTablesRequest {
    const message = createBaseGetTablesRequest();
    message.connectionId = object.connectionId ?? "";
    message.schemaName = object.schemaName ?? "";
    message.tableType = object.tableType ?? "";
    return message;
  },
};

function createBaseTable(): Table {
  return {
    name: "",
    schema: "",
    type: "",
    comment: "",
    createdAt: undefined,
    updatedAt: undefined,
    rowCount: Long.ZERO,
    sizeBytes: Long.ZERO,
    owner: "",
    metadata: {},
  };
}

export const Table: MessageFns<Table> = {
  encode(message: Table, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.schema !== "") {
      writer.uint32(18).string(message.schema);
    }
    if (message.type !== "") {
      writer.uint32(26).string(message.type);
    }
    if (message.comment !== "") {
      writer.uint32(34).string(message.comment);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(42).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(50).fork()).join();
    }
    if (!message.rowCount.equals(Long.ZERO)) {
      writer.uint32(56).int64(message.rowCount.toString());
    }
    if (!message.sizeBytes.equals(Long.ZERO)) {
      writer.uint32(64).int64(message.sizeBytes.toString());
    }
    if (message.owner !== "") {
      writer.uint32(74).string(message.owner);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      Table_MetadataEntry.encode({ key: key as any, value }, writer.uint32(82).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Table {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTable();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.schema = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.comment = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.rowCount = Long.fromString(reader.int64().toString());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.sizeBytes = Long.fromString(reader.int64().toString());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          const entry10 = Table_MetadataEntry.decode(reader, reader.uint32());
          if (entry10.value !== undefined) {
            message.metadata[entry10.key] = entry10.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Table {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      schema: isSet(object.schema) ? globalThis.String(object.schema) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      rowCount: isSet(object.rowCount) ? Long.fromValue(object.rowCount) : Long.ZERO,
      sizeBytes: isSet(object.sizeBytes) ? Long.fromValue(object.sizeBytes) : Long.ZERO,
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Table): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.schema !== "") {
      obj.schema = message.schema;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    if (!message.rowCount.equals(Long.ZERO)) {
      obj.rowCount = (message.rowCount || Long.ZERO).toString();
    }
    if (!message.sizeBytes.equals(Long.ZERO)) {
      obj.sizeBytes = (message.sizeBytes || Long.ZERO).toString();
    }
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<Table>): Table {
    return Table.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Table>): Table {
    const message = createBaseTable();
    message.name = object.name ?? "";
    message.schema = object.schema ?? "";
    message.type = object.type ?? "";
    message.comment = object.comment ?? "";
    message.createdAt = object.createdAt ?? undefined;
    message.updatedAt = object.updatedAt ?? undefined;
    message.rowCount = (object.rowCount !== undefined && object.rowCount !== null)
      ? Long.fromValue(object.rowCount)
      : Long.ZERO;
    message.sizeBytes = (object.sizeBytes !== undefined && object.sizeBytes !== null)
      ? Long.fromValue(object.sizeBytes)
      : Long.ZERO;
    message.owner = object.owner ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseTable_MetadataEntry(): Table_MetadataEntry {
  return { key: "", value: "" };
}

export const Table_MetadataEntry: MessageFns<Table_MetadataEntry> = {
  encode(message: Table_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Table_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTable_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Table_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Table_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Table_MetadataEntry>): Table_MetadataEntry {
    return Table_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Table_MetadataEntry>): Table_MetadataEntry {
    const message = createBaseTable_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseGetTablesResponse(): GetTablesResponse {
  return { success: false, message: "", tables: [] };
}

export const GetTablesResponse: MessageFns<GetTablesResponse> = {
  encode(message: GetTablesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    for (const v of message.tables) {
      Table.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTablesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTablesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tables.push(Table.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTablesResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      tables: globalThis.Array.isArray(object?.tables) ? object.tables.map((e: any) => Table.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetTablesResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.tables?.length) {
      obj.tables = message.tables.map((e) => Table.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GetTablesResponse>): GetTablesResponse {
    return GetTablesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetTablesResponse>): GetTablesResponse {
    const message = createBaseGetTablesResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.tables = object.tables?.map((e) => Table.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetTableMetadataRequest(): GetTableMetadataRequest {
  return { connectionId: "", schemaName: "", tableName: "" };
}

export const GetTableMetadataRequest: MessageFns<GetTableMetadataRequest> = {
  encode(message: GetTableMetadataRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.connectionId !== "") {
      writer.uint32(10).string(message.connectionId);
    }
    if (message.schemaName !== "") {
      writer.uint32(18).string(message.schemaName);
    }
    if (message.tableName !== "") {
      writer.uint32(26).string(message.tableName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTableMetadataRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTableMetadataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.connectionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.schemaName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tableName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTableMetadataRequest {
    return {
      connectionId: isSet(object.connectionId) ? globalThis.String(object.connectionId) : "",
      schemaName: isSet(object.schemaName) ? globalThis.String(object.schemaName) : "",
      tableName: isSet(object.tableName) ? globalThis.String(object.tableName) : "",
    };
  },

  toJSON(message: GetTableMetadataRequest): unknown {
    const obj: any = {};
    if (message.connectionId !== "") {
      obj.connectionId = message.connectionId;
    }
    if (message.schemaName !== "") {
      obj.schemaName = message.schemaName;
    }
    if (message.tableName !== "") {
      obj.tableName = message.tableName;
    }
    return obj;
  },

  create(base?: DeepPartial<GetTableMetadataRequest>): GetTableMetadataRequest {
    return GetTableMetadataRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetTableMetadataRequest>): GetTableMetadataRequest {
    const message = createBaseGetTableMetadataRequest();
    message.connectionId = object.connectionId ?? "";
    message.schemaName = object.schemaName ?? "";
    message.tableName = object.tableName ?? "";
    return message;
  },
};

function createBaseColumn(): Column {
  return {
    name: "",
    dataType: "",
    nullable: false,
    defaultValue: "",
    primaryKey: false,
    unique: false,
    indexed: false,
    comment: "",
    ordinalPosition: 0,
    characterMaximumLength: Long.ZERO,
    numericPrecision: 0,
    numericScale: 0,
    metadata: {},
  };
}

export const Column: MessageFns<Column> = {
  encode(message: Column, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.dataType !== "") {
      writer.uint32(18).string(message.dataType);
    }
    if (message.nullable !== false) {
      writer.uint32(24).bool(message.nullable);
    }
    if (message.defaultValue !== "") {
      writer.uint32(34).string(message.defaultValue);
    }
    if (message.primaryKey !== false) {
      writer.uint32(40).bool(message.primaryKey);
    }
    if (message.unique !== false) {
      writer.uint32(48).bool(message.unique);
    }
    if (message.indexed !== false) {
      writer.uint32(56).bool(message.indexed);
    }
    if (message.comment !== "") {
      writer.uint32(66).string(message.comment);
    }
    if (message.ordinalPosition !== 0) {
      writer.uint32(72).int32(message.ordinalPosition);
    }
    if (!message.characterMaximumLength.equals(Long.ZERO)) {
      writer.uint32(80).int64(message.characterMaximumLength.toString());
    }
    if (message.numericPrecision !== 0) {
      writer.uint32(88).int32(message.numericPrecision);
    }
    if (message.numericScale !== 0) {
      writer.uint32(96).int32(message.numericScale);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      Column_MetadataEntry.encode({ key: key as any, value }, writer.uint32(106).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Column {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseColumn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.dataType = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.nullable = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.defaultValue = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.primaryKey = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.unique = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.indexed = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.comment = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.ordinalPosition = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.characterMaximumLength = Long.fromString(reader.int64().toString());
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.numericPrecision = reader.int32();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.numericScale = reader.int32();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          const entry13 = Column_MetadataEntry.decode(reader, reader.uint32());
          if (entry13.value !== undefined) {
            message.metadata[entry13.key] = entry13.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Column {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      dataType: isSet(object.dataType) ? globalThis.String(object.dataType) : "",
      nullable: isSet(object.nullable) ? globalThis.Boolean(object.nullable) : false,
      defaultValue: isSet(object.defaultValue) ? globalThis.String(object.defaultValue) : "",
      primaryKey: isSet(object.primaryKey) ? globalThis.Boolean(object.primaryKey) : false,
      unique: isSet(object.unique) ? globalThis.Boolean(object.unique) : false,
      indexed: isSet(object.indexed) ? globalThis.Boolean(object.indexed) : false,
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      ordinalPosition: isSet(object.ordinalPosition) ? globalThis.Number(object.ordinalPosition) : 0,
      characterMaximumLength: isSet(object.characterMaximumLength)
        ? Long.fromValue(object.characterMaximumLength)
        : Long.ZERO,
      numericPrecision: isSet(object.numericPrecision) ? globalThis.Number(object.numericPrecision) : 0,
      numericScale: isSet(object.numericScale) ? globalThis.Number(object.numericScale) : 0,
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Column): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.dataType !== "") {
      obj.dataType = message.dataType;
    }
    if (message.nullable !== false) {
      obj.nullable = message.nullable;
    }
    if (message.defaultValue !== "") {
      obj.defaultValue = message.defaultValue;
    }
    if (message.primaryKey !== false) {
      obj.primaryKey = message.primaryKey;
    }
    if (message.unique !== false) {
      obj.unique = message.unique;
    }
    if (message.indexed !== false) {
      obj.indexed = message.indexed;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.ordinalPosition !== 0) {
      obj.ordinalPosition = Math.round(message.ordinalPosition);
    }
    if (!message.characterMaximumLength.equals(Long.ZERO)) {
      obj.characterMaximumLength = (message.characterMaximumLength || Long.ZERO).toString();
    }
    if (message.numericPrecision !== 0) {
      obj.numericPrecision = Math.round(message.numericPrecision);
    }
    if (message.numericScale !== 0) {
      obj.numericScale = Math.round(message.numericScale);
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<Column>): Column {
    return Column.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Column>): Column {
    const message = createBaseColumn();
    message.name = object.name ?? "";
    message.dataType = object.dataType ?? "";
    message.nullable = object.nullable ?? false;
    message.defaultValue = object.defaultValue ?? "";
    message.primaryKey = object.primaryKey ?? false;
    message.unique = object.unique ?? false;
    message.indexed = object.indexed ?? false;
    message.comment = object.comment ?? "";
    message.ordinalPosition = object.ordinalPosition ?? 0;
    message.characterMaximumLength =
      (object.characterMaximumLength !== undefined && object.characterMaximumLength !== null)
        ? Long.fromValue(object.characterMaximumLength)
        : Long.ZERO;
    message.numericPrecision = object.numericPrecision ?? 0;
    message.numericScale = object.numericScale ?? 0;
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseColumn_MetadataEntry(): Column_MetadataEntry {
  return { key: "", value: "" };
}

export const Column_MetadataEntry: MessageFns<Column_MetadataEntry> = {
  encode(message: Column_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Column_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseColumn_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Column_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Column_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Column_MetadataEntry>): Column_MetadataEntry {
    return Column_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Column_MetadataEntry>): Column_MetadataEntry {
    const message = createBaseColumn_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseIndex(): Index {
  return { name: "", columns: [], unique: false, primary: false, type: "", method: "", metadata: {} };
}

export const Index: MessageFns<Index> = {
  encode(message: Index, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.columns) {
      writer.uint32(18).string(v!);
    }
    if (message.unique !== false) {
      writer.uint32(24).bool(message.unique);
    }
    if (message.primary !== false) {
      writer.uint32(32).bool(message.primary);
    }
    if (message.type !== "") {
      writer.uint32(42).string(message.type);
    }
    if (message.method !== "") {
      writer.uint32(50).string(message.method);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      Index_MetadataEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Index {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIndex();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.columns.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.unique = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.primary = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.method = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          const entry7 = Index_MetadataEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.metadata[entry7.key] = entry7.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Index {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      columns: globalThis.Array.isArray(object?.columns) ? object.columns.map((e: any) => globalThis.String(e)) : [],
      unique: isSet(object.unique) ? globalThis.Boolean(object.unique) : false,
      primary: isSet(object.primary) ? globalThis.Boolean(object.primary) : false,
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      method: isSet(object.method) ? globalThis.String(object.method) : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Index): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.columns?.length) {
      obj.columns = message.columns;
    }
    if (message.unique !== false) {
      obj.unique = message.unique;
    }
    if (message.primary !== false) {
      obj.primary = message.primary;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.method !== "") {
      obj.method = message.method;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<Index>): Index {
    return Index.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Index>): Index {
    const message = createBaseIndex();
    message.name = object.name ?? "";
    message.columns = object.columns?.map((e) => e) || [];
    message.unique = object.unique ?? false;
    message.primary = object.primary ?? false;
    message.type = object.type ?? "";
    message.method = object.method ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseIndex_MetadataEntry(): Index_MetadataEntry {
  return { key: "", value: "" };
}

export const Index_MetadataEntry: MessageFns<Index_MetadataEntry> = {
  encode(message: Index_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Index_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIndex_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Index_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Index_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Index_MetadataEntry>): Index_MetadataEntry {
    return Index_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Index_MetadataEntry>): Index_MetadataEntry {
    const message = createBaseIndex_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseForeignKey(): ForeignKey {
  return {
    name: "",
    columns: [],
    referencedTable: "",
    referencedSchema: "",
    referencedColumns: [],
    onDelete: "",
    onUpdate: "",
  };
}

export const ForeignKey: MessageFns<ForeignKey> = {
  encode(message: ForeignKey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.columns) {
      writer.uint32(18).string(v!);
    }
    if (message.referencedTable !== "") {
      writer.uint32(26).string(message.referencedTable);
    }
    if (message.referencedSchema !== "") {
      writer.uint32(34).string(message.referencedSchema);
    }
    for (const v of message.referencedColumns) {
      writer.uint32(42).string(v!);
    }
    if (message.onDelete !== "") {
      writer.uint32(50).string(message.onDelete);
    }
    if (message.onUpdate !== "") {
      writer.uint32(58).string(message.onUpdate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ForeignKey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseForeignKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.columns.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.referencedTable = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.referencedSchema = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.referencedColumns.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.onDelete = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.onUpdate = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ForeignKey {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      columns: globalThis.Array.isArray(object?.columns) ? object.columns.map((e: any) => globalThis.String(e)) : [],
      referencedTable: isSet(object.referencedTable) ? globalThis.String(object.referencedTable) : "",
      referencedSchema: isSet(object.referencedSchema) ? globalThis.String(object.referencedSchema) : "",
      referencedColumns: globalThis.Array.isArray(object?.referencedColumns)
        ? object.referencedColumns.map((e: any) => globalThis.String(e))
        : [],
      onDelete: isSet(object.onDelete) ? globalThis.String(object.onDelete) : "",
      onUpdate: isSet(object.onUpdate) ? globalThis.String(object.onUpdate) : "",
    };
  },

  toJSON(message: ForeignKey): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.columns?.length) {
      obj.columns = message.columns;
    }
    if (message.referencedTable !== "") {
      obj.referencedTable = message.referencedTable;
    }
    if (message.referencedSchema !== "") {
      obj.referencedSchema = message.referencedSchema;
    }
    if (message.referencedColumns?.length) {
      obj.referencedColumns = message.referencedColumns;
    }
    if (message.onDelete !== "") {
      obj.onDelete = message.onDelete;
    }
    if (message.onUpdate !== "") {
      obj.onUpdate = message.onUpdate;
    }
    return obj;
  },

  create(base?: DeepPartial<ForeignKey>): ForeignKey {
    return ForeignKey.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ForeignKey>): ForeignKey {
    const message = createBaseForeignKey();
    message.name = object.name ?? "";
    message.columns = object.columns?.map((e) => e) || [];
    message.referencedTable = object.referencedTable ?? "";
    message.referencedSchema = object.referencedSchema ?? "";
    message.referencedColumns = object.referencedColumns?.map((e) => e) || [];
    message.onDelete = object.onDelete ?? "";
    message.onUpdate = object.onUpdate ?? "";
    return message;
  },
};

function createBaseTableMetadata(): TableMetadata {
  return { table: undefined, columns: [], indexes: [], foreignKeys: [], triggers: [], statistics: {} };
}

export const TableMetadata: MessageFns<TableMetadata> = {
  encode(message: TableMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.table !== undefined) {
      Table.encode(message.table, writer.uint32(10).fork()).join();
    }
    for (const v of message.columns) {
      Column.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.indexes) {
      Index.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.foreignKeys) {
      ForeignKey.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.triggers) {
      writer.uint32(42).string(v!);
    }
    Object.entries(message.statistics).forEach(([key, value]) => {
      TableMetadata_StatisticsEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TableMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTableMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.table = Table.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.columns.push(Column.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.indexes.push(Index.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.foreignKeys.push(ForeignKey.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.triggers.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          const entry6 = TableMetadata_StatisticsEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.statistics[entry6.key] = entry6.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TableMetadata {
    return {
      table: isSet(object.table) ? Table.fromJSON(object.table) : undefined,
      columns: globalThis.Array.isArray(object?.columns) ? object.columns.map((e: any) => Column.fromJSON(e)) : [],
      indexes: globalThis.Array.isArray(object?.indexes) ? object.indexes.map((e: any) => Index.fromJSON(e)) : [],
      foreignKeys: globalThis.Array.isArray(object?.foreignKeys)
        ? object.foreignKeys.map((e: any) => ForeignKey.fromJSON(e))
        : [],
      triggers: globalThis.Array.isArray(object?.triggers) ? object.triggers.map((e: any) => globalThis.String(e)) : [],
      statistics: isObject(object.statistics)
        ? Object.entries(object.statistics).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: TableMetadata): unknown {
    const obj: any = {};
    if (message.table !== undefined) {
      obj.table = Table.toJSON(message.table);
    }
    if (message.columns?.length) {
      obj.columns = message.columns.map((e) => Column.toJSON(e));
    }
    if (message.indexes?.length) {
      obj.indexes = message.indexes.map((e) => Index.toJSON(e));
    }
    if (message.foreignKeys?.length) {
      obj.foreignKeys = message.foreignKeys.map((e) => ForeignKey.toJSON(e));
    }
    if (message.triggers?.length) {
      obj.triggers = message.triggers;
    }
    if (message.statistics) {
      const entries = Object.entries(message.statistics);
      if (entries.length > 0) {
        obj.statistics = {};
        entries.forEach(([k, v]) => {
          obj.statistics[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<TableMetadata>): TableMetadata {
    return TableMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TableMetadata>): TableMetadata {
    const message = createBaseTableMetadata();
    message.table = (object.table !== undefined && object.table !== null) ? Table.fromPartial(object.table) : undefined;
    message.columns = object.columns?.map((e) => Column.fromPartial(e)) || [];
    message.indexes = object.indexes?.map((e) => Index.fromPartial(e)) || [];
    message.foreignKeys = object.foreignKeys?.map((e) => ForeignKey.fromPartial(e)) || [];
    message.triggers = object.triggers?.map((e) => e) || [];
    message.statistics = Object.entries(object.statistics ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseTableMetadata_StatisticsEntry(): TableMetadata_StatisticsEntry {
  return { key: "", value: "" };
}

export const TableMetadata_StatisticsEntry: MessageFns<TableMetadata_StatisticsEntry> = {
  encode(message: TableMetadata_StatisticsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TableMetadata_StatisticsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTableMetadata_StatisticsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TableMetadata_StatisticsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: TableMetadata_StatisticsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<TableMetadata_StatisticsEntry>): TableMetadata_StatisticsEntry {
    return TableMetadata_StatisticsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TableMetadata_StatisticsEntry>): TableMetadata_StatisticsEntry {
    const message = createBaseTableMetadata_StatisticsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseGetTableMetadataResponse(): GetTableMetadataResponse {
  return { success: false, message: "", metadata: undefined };
}

export const GetTableMetadataResponse: MessageFns<GetTableMetadataResponse> = {
  encode(message: GetTableMetadataResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.metadata !== undefined) {
      TableMetadata.encode(message.metadata, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTableMetadataResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTableMetadataResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.metadata = TableMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTableMetadataResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      metadata: isSet(object.metadata) ? TableMetadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: GetTableMetadataResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.metadata !== undefined) {
      obj.metadata = TableMetadata.toJSON(message.metadata);
    }
    return obj;
  },

  create(base?: DeepPartial<GetTableMetadataResponse>): GetTableMetadataResponse {
    return GetTableMetadataResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetTableMetadataResponse>): GetTableMetadataResponse {
    const message = createBaseGetTableMetadataResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? TableMetadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseGetConnectionHealthRequest(): GetConnectionHealthRequest {
  return { connectionId: "", intervalSeconds: 0 };
}

export const GetConnectionHealthRequest: MessageFns<GetConnectionHealthRequest> = {
  encode(message: GetConnectionHealthRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.connectionId !== "") {
      writer.uint32(10).string(message.connectionId);
    }
    if (message.intervalSeconds !== 0) {
      writer.uint32(16).int32(message.intervalSeconds);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetConnectionHealthRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetConnectionHealthRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.connectionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.intervalSeconds = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetConnectionHealthRequest {
    return {
      connectionId: isSet(object.connectionId) ? globalThis.String(object.connectionId) : "",
      intervalSeconds: isSet(object.intervalSeconds) ? globalThis.Number(object.intervalSeconds) : 0,
    };
  },

  toJSON(message: GetConnectionHealthRequest): unknown {
    const obj: any = {};
    if (message.connectionId !== "") {
      obj.connectionId = message.connectionId;
    }
    if (message.intervalSeconds !== 0) {
      obj.intervalSeconds = Math.round(message.intervalSeconds);
    }
    return obj;
  },

  create(base?: DeepPartial<GetConnectionHealthRequest>): GetConnectionHealthRequest {
    return GetConnectionHealthRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetConnectionHealthRequest>): GetConnectionHealthRequest {
    const message = createBaseGetConnectionHealthRequest();
    message.connectionId = object.connectionId ?? "";
    message.intervalSeconds = object.intervalSeconds ?? 0;
    return message;
  },
};

function createBaseConnectionHealthResponse(): ConnectionHealthResponse {
  return {
    connectionId: "",
    status: HealthStatus.HEALTH_STATUS_UNSPECIFIED,
    message: "",
    timestamp: undefined,
    responseTimeMs: Long.ZERO,
    activeConnections: 0,
    idleConnections: 0,
    metrics: {},
  };
}

export const ConnectionHealthResponse: MessageFns<ConnectionHealthResponse> = {
  encode(message: ConnectionHealthResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.connectionId !== "") {
      writer.uint32(10).string(message.connectionId);
    }
    if (message.status !== HealthStatus.HEALTH_STATUS_UNSPECIFIED) {
      writer.uint32(16).int32(healthStatusToNumber(message.status));
    }
    if (message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(34).fork()).join();
    }
    if (!message.responseTimeMs.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.responseTimeMs.toString());
    }
    if (message.activeConnections !== 0) {
      writer.uint32(48).int32(message.activeConnections);
    }
    if (message.idleConnections !== 0) {
      writer.uint32(56).int32(message.idleConnections);
    }
    Object.entries(message.metrics).forEach(([key, value]) => {
      ConnectionHealthResponse_MetricsEntry.encode({ key: key as any, value }, writer.uint32(66).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConnectionHealthResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnectionHealthResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.connectionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = healthStatusFromJSON(reader.int32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.responseTimeMs = Long.fromString(reader.int64().toString());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.activeConnections = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.idleConnections = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          const entry8 = ConnectionHealthResponse_MetricsEntry.decode(reader, reader.uint32());
          if (entry8.value !== undefined) {
            message.metrics[entry8.key] = entry8.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConnectionHealthResponse {
    return {
      connectionId: isSet(object.connectionId) ? globalThis.String(object.connectionId) : "",
      status: isSet(object.status) ? healthStatusFromJSON(object.status) : HealthStatus.HEALTH_STATUS_UNSPECIFIED,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      responseTimeMs: isSet(object.responseTimeMs) ? Long.fromValue(object.responseTimeMs) : Long.ZERO,
      activeConnections: isSet(object.activeConnections) ? globalThis.Number(object.activeConnections) : 0,
      idleConnections: isSet(object.idleConnections) ? globalThis.Number(object.idleConnections) : 0,
      metrics: isObject(object.metrics)
        ? Object.entries(object.metrics).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: ConnectionHealthResponse): unknown {
    const obj: any = {};
    if (message.connectionId !== "") {
      obj.connectionId = message.connectionId;
    }
    if (message.status !== HealthStatus.HEALTH_STATUS_UNSPECIFIED) {
      obj.status = healthStatusToJSON(message.status);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (!message.responseTimeMs.equals(Long.ZERO)) {
      obj.responseTimeMs = (message.responseTimeMs || Long.ZERO).toString();
    }
    if (message.activeConnections !== 0) {
      obj.activeConnections = Math.round(message.activeConnections);
    }
    if (message.idleConnections !== 0) {
      obj.idleConnections = Math.round(message.idleConnections);
    }
    if (message.metrics) {
      const entries = Object.entries(message.metrics);
      if (entries.length > 0) {
        obj.metrics = {};
        entries.forEach(([k, v]) => {
          obj.metrics[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<ConnectionHealthResponse>): ConnectionHealthResponse {
    return ConnectionHealthResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConnectionHealthResponse>): ConnectionHealthResponse {
    const message = createBaseConnectionHealthResponse();
    message.connectionId = object.connectionId ?? "";
    message.status = object.status ?? HealthStatus.HEALTH_STATUS_UNSPECIFIED;
    message.message = object.message ?? "";
    message.timestamp = object.timestamp ?? undefined;
    message.responseTimeMs = (object.responseTimeMs !== undefined && object.responseTimeMs !== null)
      ? Long.fromValue(object.responseTimeMs)
      : Long.ZERO;
    message.activeConnections = object.activeConnections ?? 0;
    message.idleConnections = object.idleConnections ?? 0;
    message.metrics = Object.entries(object.metrics ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseConnectionHealthResponse_MetricsEntry(): ConnectionHealthResponse_MetricsEntry {
  return { key: "", value: "" };
}

export const ConnectionHealthResponse_MetricsEntry: MessageFns<ConnectionHealthResponse_MetricsEntry> = {
  encode(message: ConnectionHealthResponse_MetricsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConnectionHealthResponse_MetricsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnectionHealthResponse_MetricsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConnectionHealthResponse_MetricsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ConnectionHealthResponse_MetricsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<ConnectionHealthResponse_MetricsEntry>): ConnectionHealthResponse_MetricsEntry {
    return ConnectionHealthResponse_MetricsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConnectionHealthResponse_MetricsEntry>): ConnectionHealthResponse_MetricsEntry {
    const message = createBaseConnectionHealthResponse_MetricsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

/** Database service definition */
export type DatabaseServiceDefinition = typeof DatabaseServiceDefinition;
export const DatabaseServiceDefinition = {
  name: "DatabaseService",
  fullName: "sqlstudio.database.DatabaseService",
  methods: {
    createConnection: {
      name: "CreateConnection",
      requestType: CreateConnectionRequest,
      requestStream: false,
      responseType: CreateConnectionResponse,
      responseStream: false,
      options: {},
    },
    getConnection: {
      name: "GetConnection",
      requestType: GetConnectionRequest,
      requestStream: false,
      responseType: GetConnectionResponse,
      responseStream: false,
      options: {},
    },
    listConnections: {
      name: "ListConnections",
      requestType: ListConnectionsRequest,
      requestStream: false,
      responseType: ListConnectionsResponse,
      responseStream: false,
      options: {},
    },
    updateConnection: {
      name: "UpdateConnection",
      requestType: UpdateConnectionRequest,
      requestStream: false,
      responseType: UpdateConnectionResponse,
      responseStream: false,
      options: {},
    },
    deleteConnection: {
      name: "DeleteConnection",
      requestType: DeleteConnectionRequest,
      requestStream: false,
      responseType: DeleteConnectionResponse,
      responseStream: false,
      options: {},
    },
    testConnection: {
      name: "TestConnection",
      requestType: TestConnectionRequest,
      requestStream: false,
      responseType: TestConnectionResponse,
      responseStream: false,
      options: {},
    },
    getSchemas: {
      name: "GetSchemas",
      requestType: GetSchemasRequest,
      requestStream: false,
      responseType: GetSchemasResponse,
      responseStream: false,
      options: {},
    },
    getTables: {
      name: "GetTables",
      requestType: GetTablesRequest,
      requestStream: false,
      responseType: GetTablesResponse,
      responseStream: false,
      options: {},
    },
    getTableMetadata: {
      name: "GetTableMetadata",
      requestType: GetTableMetadataRequest,
      requestStream: false,
      responseType: GetTableMetadataResponse,
      responseStream: false,
      options: {},
    },
    getConnectionHealth: {
      name: "GetConnectionHealth",
      requestType: GetConnectionHealthRequest,
      requestStream: false,
      responseType: ConnectionHealthResponse,
      responseStream: true,
      options: {},
    },
  },
} as const;

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
