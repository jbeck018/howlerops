# =============================================================================
# SQL Studio Backend - Continuous Integration Workflow
# =============================================================================
# This workflow provides fast feedback for developers by running tests and
# linting on every pull request and push to main branch. It's optimized for
# speed with parallel jobs and aggressive caching.
#
# Triggers:
# - Pull requests targeting main branch
# - Direct pushes to main branch
# - Manual workflow dispatch
#
# Jobs:
# 1. test: Runs unit and integration tests with coverage
# 2. lint: Runs golangci-lint for code quality checks
# 3. build: Verifies the application compiles successfully
#
# Success Criteria:
# - All tests pass with no race conditions
# - Code meets linting standards
# - Application builds without errors
# =============================================================================

name: CI

on:
  # Run on pull requests to main
  pull_request:
    branches:
      - main
    paths:
      - 'backend-go/**'
      - '.github/workflows/ci.yml'

  # Run on pushes to main (after merge)
  push:
    branches:
      - main
    paths:
      - 'backend-go/**'
      - '.github/workflows/ci.yml'

  # Allow manual triggering
  workflow_dispatch:

# Cancel in-progress runs for the same PR/branch
# This saves CI minutes and provides faster feedback
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  GO_VERSION: '1.24'
  GOLANGCI_LINT_VERSION: 'v1.61'
  # CGO is required for SQLite driver (mattn/go-sqlite3)
  CGO_ENABLED: 1

jobs:
  # ---------------------------------------------------------------------------
  # Job 1: Run Tests
  # ---------------------------------------------------------------------------
  test:
    name: Run Tests
    runs-on: ubuntu-latest

    # Add status check permissions for PR comments
    permissions:
      contents: read
      pull-requests: write
      checks: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          # Fetch all history for accurate coverage reporting
          fetch-depth: 0

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          # Cache Go modules and build cache for faster subsequent runs
          cache: true
          cache-dependency-path: backend-go/go.sum

      - name: Install system dependencies
        run: |
          # Install GCC and SQLite development libraries
          # Required for building with CGO_ENABLED=1
          sudo apt-get update -qq
          sudo apt-get install -y -qq \
            gcc \
            musl-dev \
            sqlite3 \
            libsqlite3-dev

      - name: Download Go modules
        working-directory: ./backend-go
        run: |
          # Download dependencies with retries for transient failures
          go mod download
          go mod verify

      - name: Run go vet
        working-directory: ./backend-go
        run: |
          # Static analysis to find suspicious constructs
          # Exit on first error for fast feedback
          go vet ./...

      - name: Run tests with race detection
        working-directory: ./backend-go
        run: |
          # Run tests with:
          # -v: Verbose output for debugging failures
          # -race: Race condition detection (critical for concurrent code)
          # -coverprofile: Generate coverage report
          # -covermode=atomic: Thread-safe coverage collection (required with -race)
          # -timeout: Prevent hanging tests (default 10m)
          # -shuffle=on: Randomize test execution to catch order dependencies
          go test \
            -v \
            -race \
            -coverprofile=coverage.out \
            -covermode=atomic \
            -timeout=10m \
            -shuffle=on \
            ./...

      - name: Generate coverage report
        working-directory: ./backend-go
        run: |
          # Calculate total coverage percentage
          COVERAGE=$(go tool cover -func=coverage.out | grep total | awk '{print $3}')
          echo "Total test coverage: $COVERAGE"
          echo "COVERAGE=$COVERAGE" >> $GITHUB_ENV

      - name: Check coverage threshold
        working-directory: ./backend-go
        run: |
          # Fail if coverage drops below 60%
          # Adjust this threshold based on your project standards
          COVERAGE_NUM=$(echo $COVERAGE | sed 's/%//')
          THRESHOLD=60

          if (( $(echo "$COVERAGE_NUM < $THRESHOLD" | bc -l) )); then
            echo "ERROR: Coverage $COVERAGE is below threshold ${THRESHOLD}%"
            exit 1
          else
            echo "SUCCESS: Coverage $COVERAGE meets threshold ${THRESHOLD}%"
          fi

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v4
        with:
          file: ./backend-go/coverage.out
          flags: backend-go
          fail_ci_if_error: false
          # Codecov token (optional for public repos)
          token: ${{ secrets.CODECOV_TOKEN }}

      - name: Upload coverage artifact
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report
          path: backend-go/coverage.out
          retention-days: 30

      - name: Comment PR with coverage
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const coverage = process.env.COVERAGE;
            const body = `### Test Coverage Report\n\n` +
                        `Total Coverage: **${coverage}**\n\n` +
                        `[View full coverage report in artifacts](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})`;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.name,
              body: body
            });

  # ---------------------------------------------------------------------------
  # Job 2: Linting and Code Quality
  # ---------------------------------------------------------------------------
  lint:
    name: Lint Code
    runs-on: ubuntu-latest

    permissions:
      contents: read
      pull-requests: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true
          cache-dependency-path: backend-go/go.sum

      - name: Install system dependencies
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y -qq gcc musl-dev sqlite3 libsqlite3-dev

      - name: Run golangci-lint
        uses: golangci/golangci-lint-action@v6
        with:
          # Version of golangci-lint to use
          version: ${{ env.GOLANGCI_LINT_VERSION }}

          # Path to golangci-lint config file
          # Create .golangci.yml in backend-go/ for custom rules
          working-directory: backend-go

          # Arguments to pass to golangci-lint
          args: >-
            --timeout=10m
            --verbose
            --max-issues-per-linter=0
            --max-same-issues=0

          # Cache golangci-lint analysis results for faster runs
          only-new-issues: false

          # Skip build cache (use Go setup-go cache instead)
          skip-cache: false
          skip-pkg-cache: false
          skip-build-cache: false

      - name: Check code formatting
        working-directory: ./backend-go
        run: |
          # Verify code is formatted with gofmt
          # This is redundant with golangci-lint but provides clear error messages
          UNFORMATTED=$(gofmt -l .)
          if [ -n "$UNFORMATTED" ]; then
            echo "ERROR: The following files are not formatted:"
            echo "$UNFORMATTED"
            echo ""
            echo "Run 'gofmt -w .' to format your code"
            exit 1
          fi

      - name: Check for common security issues
        working-directory: ./backend-go
        run: |
          # Install gosec for security scanning
          go install github.com/securego/gosec/v2/cmd/gosec@latest

          # Run security scan
          # -exclude-dir: Skip test files and vendor
          # -severity: Only report medium and above
          gosec -exclude-dir=vendor -exclude-dir=test -severity medium ./...

  # ---------------------------------------------------------------------------
  # Job 3: Build Verification
  # ---------------------------------------------------------------------------
  build:
    name: Build Verification
    runs-on: ubuntu-latest

    # Build matrix for multiple platforms
    # This ensures the code compiles on all target platforms
    strategy:
      matrix:
        goos: [linux, darwin, windows]
        goarch: [amd64, arm64]
        exclude:
          # Windows arm64 is not commonly used
          - goos: windows
            goarch: arm64

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true
          cache-dependency-path: backend-go/go.sum

      - name: Install system dependencies (Linux only)
        if: matrix.goos == 'linux'
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y -qq gcc musl-dev sqlite3 libsqlite3-dev

      - name: Download Go modules
        working-directory: ./backend-go
        run: go mod download

      - name: Build binary
        working-directory: ./backend-go
        env:
          GOOS: ${{ matrix.goos }}
          GOARCH: ${{ matrix.goarch }}
          # CGO is only enabled for linux builds in CI
          # Cross-compiling with CGO requires platform-specific toolchains
          CGO_ENABLED: ${{ matrix.goos == 'linux' && '1' || '0' }}
        run: |
          # Build with production flags
          OUTPUT_NAME="sql-studio-backend"
          if [ "$GOOS" = "windows" ]; then
            OUTPUT_NAME="${OUTPUT_NAME}.exe"
          fi

          # Build command
          go build \
            -v \
            -trimpath \
            -ldflags="-s -w \
              -X 'main.Version=dev' \
              -X 'main.BuildTime=$(date -u +%Y-%m-%dT%H:%M:%SZ)' \
              -X 'main.GitCommit=${{ github.sha }}'" \
            -o "$OUTPUT_NAME" \
            ./cmd/server/main.go

          # Verify binary was created
          ls -lh "$OUTPUT_NAME"

      - name: Test binary runs
        working-directory: ./backend-go
        # Only test on Linux (SQLite support)
        if: matrix.goos == 'linux'
        run: |
          chmod +x sql-studio-backend
          # Test binary shows version (will fail if version flags not set)
          timeout 5s ./sql-studio-backend --version || true

  # ---------------------------------------------------------------------------
  # Job 4: Dependency Security Check
  # ---------------------------------------------------------------------------
  security:
    name: Security Scan
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Run govulncheck
        working-directory: ./backend-go
        run: |
          # Install Go's official vulnerability scanner
          go install golang.org/x/vuln/cmd/govulncheck@latest

          # Scan for known vulnerabilities in dependencies
          govulncheck ./...

      - name: Run Nancy (Sonatype dependency check)
        working-directory: ./backend-go
        continue-on-error: true
        run: |
          # Install Nancy for additional vulnerability scanning
          go install github.com/sonatype-nexus-community/nancy@latest

          # Generate dependency list and scan
          go list -json -deps ./... | nancy sleuth

# =============================================================================
# Workflow Summary
# =============================================================================
# This CI workflow runs on every PR and push to main, providing:
#
# 1. Fast Feedback (3-5 minutes typical runtime)
#    - Parallel job execution
#    - Aggressive caching of dependencies
#    - Incremental linting (only new issues)
#
# 2. Comprehensive Testing
#    - Unit and integration tests
#    - Race condition detection
#    - Coverage reporting with thresholds
#
# 3. Code Quality
#    - Linting with golangci-lint (20+ linters)
#    - Security scanning with gosec
#    - Formatting verification
#
# 4. Build Verification
#    - Multi-platform compilation checks
#    - Version embedding verification
#
# 5. Security
#    - Dependency vulnerability scanning
#    - CVE detection in Go modules
#
# To customize:
# - Adjust coverage threshold in test job (currently 60%)
# - Add/remove platforms in build matrix
# - Configure linters in backend-go/.golangci.yml
# - Set CODECOV_TOKEN secret for private repos
# =============================================================================
