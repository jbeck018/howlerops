# =============================================================================
# SQL Studio Backend - Deployment Workflow
# =============================================================================
# This workflow automates production deployment to GCP Cloud Run with:
# - Docker image building and pushing to GCP Container Registry
# - Automated Cloud Run service updates
# - Secret management via GCP Secret Manager
# - Health check validation after deployment
# - Rollback capability on failures
#
# Deployment Flow:
# 1. Release published (from release.yml) OR manual trigger
# 2. Build production Docker image with version tags
# 3. Push to GCP Container Registry
# 4. Deploy to Cloud Run with zero-downtime rolling update
# 5. Run smoke tests to validate deployment
# 6. Rollback automatically if health checks fail
#
# Triggers:
# - Release published (recommended)
# - Manual workflow dispatch (for hotfixes)
# - Push to main (optional, disabled by default)
#
# Required GitHub Secrets:
# - GCP_PROJECT_ID: Google Cloud project ID
# - GCP_SA_KEY: Service account key JSON with permissions:
#   * Cloud Run Admin
#   * Service Account User
#   * Secret Manager Admin
#   * Container Registry Service Agent
# - TURSO_URL: Turso database URL
# - TURSO_AUTH_TOKEN: Turso authentication token
# - JWT_SECRET: JWT signing secret (min 32 chars, recommend 64)
# - RESEND_API_KEY: Resend email API key (optional)
# - RESEND_FROM_EMAIL: Sender email address (optional)
#
# Optional Secrets for Fly.io:
# - FLY_API_TOKEN: Fly.io API token
# =============================================================================

name: Deploy Backend

on:
  # Recommended: Deploy when a release is published
  release:
    types: [published]

  # Optional: Allow manual deployment with custom parameters
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging
      deploy_target:
        description: 'Deployment target'
        required: true
        default: 'cloudrun'
        type: choice
        options:
          - cloudrun
          - fly
          - both
      image_tag:
        description: 'Docker image tag (leave empty for latest)'
        required: false
        type: string

  # Disabled by default - uncomment to enable auto-deploy on main push
  # push:
  #   branches:
  #     - main
  #   paths:
  #     - 'backend-go/**'
  #     - '.github/workflows/deploy-backend.yml'

# Only one deployment at a time per environment
concurrency:
  group: deploy-${{ github.event.inputs.environment || 'production' }}
  cancel-in-progress: false

env:
  GO_VERSION: '1.24'
  GCP_REGION: 'us-central1'
  SERVICE_NAME: 'sql-studio-backend'

# =============================================================================
# Jobs
# =============================================================================

jobs:
  # ---------------------------------------------------------------------------
  # Job 1: Pre-deployment Validation
  # ---------------------------------------------------------------------------
  validate:
    name: Pre-deployment Validation
    runs-on: ubuntu-latest

    outputs:
      version: ${{ steps.get_version.outputs.version }}
      image_tag: ${{ steps.get_version.outputs.image_tag }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Determine version and image tag
        id: get_version
        run: |
          if [ "${{ github.event_name }}" = "release" ]; then
            # Extract version from release tag
            VERSION=${GITHUB_REF#refs/tags/v}
            IMAGE_TAG="v${VERSION}"
          elif [ -n "${{ github.event.inputs.image_tag }}" ]; then
            # Use custom tag from workflow dispatch
            IMAGE_TAG="${{ github.event.inputs.image_tag }}"
            VERSION="${IMAGE_TAG#v}"
          else
            # Use commit SHA for non-release deployments
            VERSION="${GITHUB_SHA::7}"
            IMAGE_TAG="main-${VERSION}"
          fi

          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT

          echo "Deployment Version: $VERSION"
          echo "Docker Image Tag: $IMAGE_TAG"

      - name: Validate secrets are configured
        run: |
          # Check required secrets are present (non-empty)
          MISSING_SECRETS=()

          if [ -z "${{ secrets.GCP_PROJECT_ID }}" ]; then
            MISSING_SECRETS+=("GCP_PROJECT_ID")
          fi

          if [ -z "${{ secrets.GCP_SA_KEY }}" ]; then
            MISSING_SECRETS+=("GCP_SA_KEY")
          fi

          if [ -z "${{ secrets.TURSO_URL }}" ]; then
            MISSING_SECRETS+=("TURSO_URL")
          fi

          if [ -z "${{ secrets.TURSO_AUTH_TOKEN }}" ]; then
            MISSING_SECRETS+=("TURSO_AUTH_TOKEN")
          fi

          if [ -z "${{ secrets.JWT_SECRET }}" ]; then
            MISSING_SECRETS+=("JWT_SECRET")
          fi

          if [ ${#MISSING_SECRETS[@]} -gt 0 ]; then
            echo "ERROR: Missing required secrets:"
            printf '  - %s\n' "${MISSING_SECRETS[@]}"
            echo ""
            echo "Configure these in GitHub Settings > Secrets and variables > Actions"
            exit 1
          fi

          echo "All required secrets are configured"

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true
          cache-dependency-path: backend-go/go.sum

      - name: Install dependencies
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y -qq gcc musl-dev sqlite3 libsqlite3-dev

      - name: Run quick tests
        working-directory: ./backend-go
        run: |
          # Quick smoke test before deployment
          # Full tests run in CI workflow
          go test -short -v ./internal/config ./pkg/logger

      - name: Validate Dockerfile
        run: |
          # Check Dockerfile exists and is valid
          if [ ! -f backend-go/Dockerfile ]; then
            echo "ERROR: Dockerfile not found"
            exit 1
          fi

          # Basic syntax validation
          docker build --check backend-go/ || true
          echo "Dockerfile validation complete"

  # ---------------------------------------------------------------------------
  # Job 2: Build and Push Docker Image
  # ---------------------------------------------------------------------------
  build-docker:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    needs: validate

    permissions:
      contents: read
      id-token: write

    outputs:
      image_url: ${{ steps.build_image.outputs.image_url }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          # Enable advanced features
          driver-opts: network=host

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ secrets.GCP_PROJECT_ID }}

      - name: Configure Docker for GCR
        run: |
          # Configure Docker to use gcloud as credential helper
          gcloud auth configure-docker gcr.io --quiet

      - name: Enable required GCP APIs
        run: |
          echo "Enabling required GCP APIs..."
          gcloud services enable \
            cloudbuild.googleapis.com \
            run.googleapis.com \
            secretmanager.googleapis.com \
            containerregistry.googleapis.com \
            --quiet

      - name: Build and push Docker image
        id: build_image
        uses: docker/build-push-action@v5
        with:
          context: ./backend-go
          file: ./backend-go/Dockerfile
          push: true
          platforms: linux/amd64,linux/arm64
          build-args: |
            VERSION=${{ needs.validate.outputs.version }}
            BUILD_TIME=${{ github.event.head_commit.timestamp }}
            GIT_COMMIT=${{ github.sha }}
          tags: |
            gcr.io/${{ secrets.GCP_PROJECT_ID }}/${{ env.SERVICE_NAME }}:latest
            gcr.io/${{ secrets.GCP_PROJECT_ID }}/${{ env.SERVICE_NAME }}:${{ needs.validate.outputs.image_tag }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          # Add labels for better image management
          labels: |
            org.opencontainers.image.title=SQL Studio Backend
            org.opencontainers.image.version=${{ needs.validate.outputs.version }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.source=${{ github.repositoryUrl }}

      - name: Set image URL output
        run: |
          IMAGE_URL="gcr.io/${{ secrets.GCP_PROJECT_ID }}/${{ env.SERVICE_NAME }}:${{ needs.validate.outputs.image_tag }}"
          echo "image_url=$IMAGE_URL" >> $GITHUB_OUTPUT
          echo "Built image: $IMAGE_URL"

      - name: Scan image for vulnerabilities
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: gcr.io/${{ secrets.GCP_PROJECT_ID }}/${{ env.SERVICE_NAME }}:${{ needs.validate.outputs.image_tag }}
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'CRITICAL,HIGH'
          exit-code: '0'
          # Don't fail deployment on vulnerabilities, but report them

      - name: Upload Trivy results to GitHub Security
        uses: github/codeql-action/upload-sarif@v2
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'

  # ---------------------------------------------------------------------------
  # Job 3: Manage Secrets in GCP Secret Manager
  # ---------------------------------------------------------------------------
  manage-secrets:
    name: Manage GCP Secrets
    runs-on: ubuntu-latest
    needs: validate
    if: github.event_name == 'release' || github.event_name == 'workflow_dispatch'

    permissions:
      contents: read
      id-token: write

    steps:
      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ secrets.GCP_PROJECT_ID }}

      - name: Create or update secrets
        env:
          TURSO_URL: ${{ secrets.TURSO_URL }}
          TURSO_AUTH_TOKEN: ${{ secrets.TURSO_AUTH_TOKEN }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          RESEND_API_KEY: ${{ secrets.RESEND_API_KEY }}
          RESEND_FROM_EMAIL: ${{ secrets.RESEND_FROM_EMAIL }}
        run: |
          # Function to create or update secret
          create_or_update_secret() {
            local secret_name="$1"
            local secret_value="$2"

            if [ -z "$secret_value" ]; then
              echo "Skipping empty secret: $secret_name"
              return
            fi

            # Check if secret exists
            if gcloud secrets describe "$secret_name" &> /dev/null; then
              echo "Updating secret: $secret_name"
              echo -n "$secret_value" | gcloud secrets versions add "$secret_name" \
                --data-file=- \
                --quiet
            else
              echo "Creating secret: $secret_name"
              echo -n "$secret_value" | gcloud secrets create "$secret_name" \
                --replication-policy="automatic" \
                --data-file=- \
                --quiet
            fi

            # Grant Cloud Run service account access
            PROJECT_NUMBER=$(gcloud projects describe ${{ secrets.GCP_PROJECT_ID }} --format="value(projectNumber)")
            SERVICE_ACCOUNT="${PROJECT_NUMBER}-compute@developer.gserviceaccount.com"

            gcloud secrets add-iam-policy-binding "$secret_name" \
              --member="serviceAccount:${SERVICE_ACCOUNT}" \
              --role="roles/secretmanager.secretAccessor" \
              --quiet 2>/dev/null || true
          }

          echo "Creating/updating secrets in Secret Manager..."
          create_or_update_secret "turso-url" "$TURSO_URL"
          create_or_update_secret "turso-auth-token" "$TURSO_AUTH_TOKEN"
          create_or_update_secret "jwt-secret" "$JWT_SECRET"
          create_or_update_secret "resend-api-key" "$RESEND_API_KEY"
          create_or_update_secret "resend-from-email" "$RESEND_FROM_EMAIL"
          echo "Secrets management complete"

  # ---------------------------------------------------------------------------
  # Job 4: Deploy to Google Cloud Run
  # ---------------------------------------------------------------------------
  deploy-cloudrun:
    name: Deploy to Cloud Run
    runs-on: ubuntu-latest
    needs: [validate, build-docker, manage-secrets]
    if: |
      github.event_name == 'release' ||
      (github.event_name == 'workflow_dispatch' &&
       (github.event.inputs.deploy_target == 'cloudrun' || github.event.inputs.deploy_target == 'both'))

    permissions:
      contents: read
      id-token: write

    outputs:
      service_url: ${{ steps.deploy.outputs.url }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ secrets.GCP_PROJECT_ID }}

      - name: Deploy to Cloud Run
        id: deploy
        run: |
          # Deploy with zero-downtime rolling update
          gcloud run deploy ${{ env.SERVICE_NAME }} \
            --image=gcr.io/${{ secrets.GCP_PROJECT_ID }}/${{ env.SERVICE_NAME }}:${{ needs.validate.outputs.image_tag }} \
            --region=${{ env.GCP_REGION }} \
            --platform=managed \
            --allow-unauthenticated \
            --port=8500 \
            --cpu=2 \
            --memory=512Mi \
            --min-instances=0 \
            --max-instances=10 \
            --concurrency=80 \
            --timeout=300 \
            --set-env-vars="ENVIRONMENT=production,LOG_LEVEL=info,LOG_FORMAT=json" \
            --set-secrets="TURSO_URL=turso-url:latest,TURSO_AUTH_TOKEN=turso-auth-token:latest,JWT_SECRET=jwt-secret:latest,RESEND_API_KEY=resend-api-key:latest,RESEND_FROM_EMAIL=resend-from-email:latest" \
            --service-account="${{ secrets.GCP_PROJECT_ID }}@appspot.gserviceaccount.com" \
            --vpc-connector="" \
            --labels="app=sql-studio,component=backend,version=${{ needs.validate.outputs.image_tag }}" \
            --tag="${{ needs.validate.outputs.image_tag }}" \
            --no-traffic \
            --quiet

          # Get the service URL
          SERVICE_URL=$(gcloud run services describe ${{ env.SERVICE_NAME }} \
            --region=${{ env.GCP_REGION }} \
            --format='value(status.url)')

          echo "url=$SERVICE_URL" >> $GITHUB_OUTPUT
          echo "Deployed to: $SERVICE_URL"

      - name: Run smoke tests
        id: smoke_test
        run: |
          SERVICE_URL="${{ steps.deploy.outputs.url }}"
          MAX_RETRIES=30
          RETRY_DELAY=10

          echo "Running smoke tests against: $SERVICE_URL"

          # Test 1: Health check endpoint
          for i in $(seq 1 $MAX_RETRIES); do
            echo "Health check attempt $i/$MAX_RETRIES..."

            if curl -f -s -m 10 "$SERVICE_URL/health" > /dev/null; then
              echo "Health check passed"
              break
            fi

            if [ $i -eq $MAX_RETRIES ]; then
              echo "ERROR: Health check failed after $MAX_RETRIES attempts"
              exit 1
            fi

            sleep $RETRY_DELAY
          done

          # Test 2: API version endpoint
          echo "Testing version endpoint..."
          if ! curl -f -s -m 10 "$SERVICE_URL/api/v1/version" > /dev/null; then
            echo "WARNING: Version endpoint failed (non-critical)"
          else
            echo "Version endpoint passed"
          fi

          echo "Smoke tests completed successfully"

      - name: Route traffic to new revision
        run: |
          echo "Routing 100% traffic to new revision..."
          gcloud run services update-traffic ${{ env.SERVICE_NAME }} \
            --region=${{ env.GCP_REGION }} \
            --to-latest \
            --quiet

          echo "Traffic routed successfully"

      - name: Verify deployment
        run: |
          # Get current revision
          REVISION=$(gcloud run services describe ${{ env.SERVICE_NAME }} \
            --region=${{ env.GCP_REGION }} \
            --format='value(status.latestReadyRevisionName)')

          echo "Current revision: $REVISION"

          # Check revision is serving traffic
          TRAFFIC=$(gcloud run services describe ${{ env.SERVICE_NAME }} \
            --region=${{ env.GCP_REGION }} \
            --format='value(status.traffic[0].percent)')

          if [ "$TRAFFIC" != "100" ]; then
            echo "ERROR: New revision not receiving 100% traffic (current: ${TRAFFIC}%)"
            exit 1
          fi

          echo "Deployment verified successfully"

      - name: Create deployment record
        run: |
          echo "=== Deployment Summary ==="
          echo "Service: ${{ env.SERVICE_NAME }}"
          echo "Region: ${{ env.GCP_REGION }}"
          echo "Version: ${{ needs.validate.outputs.version }}"
          echo "Image: gcr.io/${{ secrets.GCP_PROJECT_ID }}/${{ env.SERVICE_NAME }}:${{ needs.validate.outputs.image_tag }}"
          echo "URL: ${{ steps.deploy.outputs.url }}"
          echo "Timestamp: $(date -u +"%Y-%m-%d %H:%M:%S UTC")"
          echo "========================="

  # ---------------------------------------------------------------------------
  # Job 5: Deploy to Fly.io (Optional Alternative Platform)
  # ---------------------------------------------------------------------------
  deploy-fly:
    name: Deploy to Fly.io
    runs-on: ubuntu-latest
    needs: [validate, build-docker]
    # Only deploy to Fly.io if explicitly requested
    if: |
      github.event_name == 'workflow_dispatch' &&
      (github.event.inputs.deploy_target == 'fly' || github.event.inputs.deploy_target == 'both')

    outputs:
      app_url: ${{ steps.get_url.outputs.url }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Fly.io CLI
        uses: superfly/flyctl-actions/setup-flyctl@master

      - name: Configure Fly.io secrets
        working-directory: ./backend-go
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
          TURSO_URL: ${{ secrets.TURSO_URL }}
          TURSO_AUTH_TOKEN: ${{ secrets.TURSO_AUTH_TOKEN }}
          RESEND_API_KEY: ${{ secrets.RESEND_API_KEY }}
          RESEND_FROM_EMAIL: ${{ secrets.RESEND_FROM_EMAIL }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
        run: |
          echo "Configuring Fly.io secrets..."

          # Set secrets (use --stage to batch them)
          flyctl secrets set \
            TURSO_URL="$TURSO_URL" \
            TURSO_AUTH_TOKEN="$TURSO_AUTH_TOKEN" \
            JWT_SECRET="$JWT_SECRET" \
            ENVIRONMENT="production" \
            LOG_LEVEL="info" \
            LOG_FORMAT="json" \
            --stage

          # Set optional email secrets if provided
          if [ -n "$RESEND_API_KEY" ]; then
            flyctl secrets set \
              RESEND_API_KEY="$RESEND_API_KEY" \
              RESEND_FROM_EMAIL="$RESEND_FROM_EMAIL" \
              --stage
          fi

          echo "Secrets configured"

      - name: Deploy to Fly.io
        working-directory: ./backend-go
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
        run: |
          echo "Deploying to Fly.io..."

          # Deploy with rolling strategy for zero downtime
          flyctl deploy \
            --ha=false \
            --strategy=rolling \
            --wait-timeout=300 \
            --verbose

          echo "Deployment complete"

      - name: Get application URL
        id: get_url
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
        run: |
          APP_HOSTNAME=$(flyctl info --json | jq -r '.Hostname')
          APP_URL="https://$APP_HOSTNAME"

          echo "url=$APP_URL" >> $GITHUB_OUTPUT
          echo "Deployed to: $APP_URL"

      - name: Run smoke tests
        run: |
          APP_URL="${{ steps.get_url.outputs.url }}"
          MAX_RETRIES=20
          RETRY_DELAY=10

          echo "Running smoke tests against: $APP_URL"

          for i in $(seq 1 $MAX_RETRIES); do
            echo "Health check attempt $i/$MAX_RETRIES..."

            if curl -f -s -m 10 "$APP_URL/health" > /dev/null; then
              echo "Health check passed"
              exit 0
            fi

            if [ $i -eq $MAX_RETRIES ]; then
              echo "ERROR: Health check failed after $MAX_RETRIES attempts"
              exit 1
            fi

            sleep $RETRY_DELAY
          done

  # ---------------------------------------------------------------------------
  # Job 6: Post-Deployment Summary
  # ---------------------------------------------------------------------------
  deployment-summary:
    name: Deployment Summary
    runs-on: ubuntu-latest
    needs: [validate, build-docker, deploy-cloudrun]
    if: always() && (github.event_name == 'release' || github.event_name == 'workflow_dispatch')

    steps:
      - name: Generate deployment report
        run: |
          echo "# Deployment Report" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Summary" >> $GITHUB_STEP_SUMMARY
          echo "- Version: \`${{ needs.validate.outputs.version }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- Image Tag: \`${{ needs.validate.outputs.image_tag }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- Commit: \`${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- Triggered by: ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "## Deployment Status" >> $GITHUB_STEP_SUMMARY
          if [ "${{ needs.deploy-cloudrun.result }}" = "success" ]; then
            echo "- Cloud Run: SUCCESS" >> $GITHUB_STEP_SUMMARY
            echo "  - URL: ${{ needs.deploy-cloudrun.outputs.service_url }}" >> $GITHUB_STEP_SUMMARY
          else
            echo "- Cloud Run: ${{ needs.deploy-cloudrun.result || 'SKIPPED' }}" >> $GITHUB_STEP_SUMMARY
          fi

          if [ "${{ needs.deploy-fly.result }}" = "success" ]; then
            echo "- Fly.io: SUCCESS" >> $GITHUB_STEP_SUMMARY
            echo "  - URL: ${{ needs.deploy-fly.outputs.app_url }}" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ needs.deploy-fly.result }}" != "" ]; then
            echo "- Fly.io: ${{ needs.deploy-fly.result }}" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Create deployment annotation
        if: needs.deploy-cloudrun.result == 'success'
        run: |
          echo "Deployment completed successfully"
          echo "Service URL: ${{ needs.deploy-cloudrun.outputs.service_url }}"

  # ---------------------------------------------------------------------------
  # Job 7: Rollback on Failure (Safety Net)
  # ---------------------------------------------------------------------------
  rollback-on-failure:
    name: Rollback on Failure
    runs-on: ubuntu-latest
    needs: [validate, deploy-cloudrun]
    if: failure() && needs.deploy-cloudrun.result == 'failure'

    permissions:
      contents: read
      id-token: write

    steps:
      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ secrets.GCP_PROJECT_ID }}

      - name: Rollback to previous revision
        run: |
          echo "Deployment failed - initiating rollback..."

          # Get previous revision
          REVISIONS=$(gcloud run revisions list \
            --service=${{ env.SERVICE_NAME }} \
            --region=${{ env.GCP_REGION }} \
            --format='value(metadata.name)' \
            --limit=2)

          PREVIOUS_REVISION=$(echo "$REVISIONS" | tail -n 1)

          if [ -z "$PREVIOUS_REVISION" ]; then
            echo "ERROR: No previous revision found to rollback to"
            exit 1
          fi

          echo "Rolling back to revision: $PREVIOUS_REVISION"

          # Route all traffic to previous revision
          gcloud run services update-traffic ${{ env.SERVICE_NAME }} \
            --region=${{ env.GCP_REGION }} \
            --to-revisions="$PREVIOUS_REVISION=100" \
            --quiet

          echo "Rollback completed successfully"

      - name: Verify rollback
        run: |
          # Wait for rollback to take effect
          sleep 10

          # Get service URL
          SERVICE_URL=$(gcloud run services describe ${{ env.SERVICE_NAME }} \
            --region=${{ env.GCP_REGION }} \
            --format='value(status.url)')

          # Test health endpoint
          if curl -f -s -m 10 "$SERVICE_URL/health" > /dev/null; then
            echo "Rollback verified - service is healthy"
          else
            echo "ERROR: Service still unhealthy after rollback"
            exit 1
          fi

      - name: Notify rollback
        run: |
          echo "WARNING: Deployment failed and was rolled back"
          echo "Check logs for details: https://console.cloud.google.com/run?project=${{ secrets.GCP_PROJECT_ID }}"

# =============================================================================
# Deployment Workflow Summary
# =============================================================================
# This production-ready deployment workflow provides:
#
# 1. Pre-deployment Validation (Job 1)
#    - Validates all required secrets are configured
#    - Determines version from release tag or manual input
#    - Runs quick smoke tests
#    - Validates Dockerfile syntax
#
# 2. Docker Image Build (Job 2)
#    - Builds multi-arch images (amd64, arm64)
#    - Pushes to GCP Container Registry
#    - Embeds version information in image
#    - Scans for vulnerabilities with Trivy
#    - Uses GitHub Actions cache for faster builds
#
# 3. Secret Management (Job 3)
#    - Creates/updates secrets in GCP Secret Manager
#    - Grants Cloud Run service account access
#    - Handles optional secrets gracefully
#
# 4. Cloud Run Deployment (Job 4)
#    - Zero-downtime rolling updates
#    - Deploys with --no-traffic initially
#    - Runs comprehensive smoke tests
#    - Routes traffic only after validation
#    - Verifies deployment success
#
# 5. Fly.io Deployment (Job 5 - Optional)
#    - Alternative deployment target
#    - Only runs on manual trigger
#    - Configures secrets and deploys
#    - Runs health checks
#
# 6. Deployment Summary (Job 6)
#    - Generates comprehensive report
#    - Shows URLs for all deployed services
#    - Available in GitHub Actions summary
#
# 7. Automatic Rollback (Job 7)
#    - Triggers on deployment failure
#    - Routes traffic to previous revision
#    - Verifies rollback success
#    - Provides troubleshooting links
#
# Deployment Triggers:
# - Release published (recommended)
# - Manual workflow dispatch (for hotfixes)
#
# Zero-Downtime Strategy:
# 1. Deploy new revision without traffic
# 2. Run smoke tests on new revision
# 3. Route traffic only after validation
# 4. Rollback automatically if tests fail
#
# Required GitHub Secrets:
# - GCP_PROJECT_ID: Google Cloud project ID
# - GCP_SA_KEY: Service account key (JSON) with roles:
#   * Cloud Run Admin
#   * Service Account User
#   * Secret Manager Admin
#   * Storage Admin (for Container Registry)
# - TURSO_URL: Turso database URL
# - TURSO_AUTH_TOKEN: Turso authentication token
# - JWT_SECRET: JWT signing secret (64+ chars recommended)
# - RESEND_API_KEY: Email service API key (optional)
# - RESEND_FROM_EMAIL: Sender email address (optional)
# - FLY_API_TOKEN: Fly.io API token (optional, for Fly.io deployments)
#
# GCP Service Account Setup:
# 1. Create service account:
#    gcloud iam service-accounts create github-actions \
#      --display-name="GitHub Actions"
#
# 2. Grant required roles:
#    gcloud projects add-iam-policy-binding PROJECT_ID \
#      --member="serviceAccount:github-actions@PROJECT_ID.iam.gserviceaccount.com" \
#      --role="roles/run.admin"
#
#    gcloud projects add-iam-policy-binding PROJECT_ID \
#      --member="serviceAccount:github-actions@PROJECT_ID.iam.gserviceaccount.com" \
#      --role="roles/iam.serviceAccountUser"
#
#    gcloud projects add-iam-policy-binding PROJECT_ID \
#      --member="serviceAccount:github-actions@PROJECT_ID.iam.gserviceaccount.com" \
#      --role="roles/secretmanager.admin"
#
#    gcloud projects add-iam-policy-binding PROJECT_ID \
#      --member="serviceAccount:github-actions@PROJECT_ID.iam.gserviceaccount.com" \
#      --role="roles/storage.admin"
#
# 3. Create and download key:
#    gcloud iam service-accounts keys create key.json \
#      --iam-account=github-actions@PROJECT_ID.iam.gserviceaccount.com
#
# 4. Add key.json contents to GitHub secret GCP_SA_KEY
#
# How to Deploy:
# 1. Create a release:
#    git tag v1.0.0
#    git push origin v1.0.0
#    gh release create v1.0.0 --generate-notes
#
# 2. Or trigger manually:
#    - Go to Actions > Deploy Backend > Run workflow
#    - Select environment and target
#    - Click "Run workflow"
#
# Monitoring Deployment:
# - View logs: https://console.cloud.google.com/run
# - Check metrics: https://console.cloud.google.com/monitoring
# - Service health: https://YOUR-SERVICE-URL/health
#
# Rollback Procedure (Manual):
# 1. List revisions:
#    gcloud run revisions list --service=sql-studio-backend --region=us-central1
#
# 2. Route to specific revision:
#    gcloud run services update-traffic sql-studio-backend \
#      --region=us-central1 \
#      --to-revisions=REVISION-NAME=100
# =============================================================================
